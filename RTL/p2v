use Getopt::Long;
use FileHandle;

($pverilog, $verilog);
($norun, $help, $verbose, $debug) = (0,0,0,0);
($P_FILE, $V_FILE);



sub p2v {
  print "DBG-MSG : I am In \n";
  my $noOfArguments = @_;

  if( $noOfArguments < 2 || $_[0] eq '-h') {
	&p2v_usage;
  }
  else { # if correct no. of inputs 
	for(my $i = 0; $i < $noOfArguments; $i++){
	  if    ($_[$i] eq "-p"){$pverilog = $_[$i+1];}
	  elsif ($_[$i] eq "-v"){$verilog  = $_[$i+1];}
	  elsif ($_[$i] eq "-debug")  {$debug = 1 ;}
	  elsif ($_[$i] eq "-norun")  {$norun = 1 ;}
	  elsif ($_[$i] eq "-verbose"){$verbose = 1 ;}
	} #for

	&init();
	&readPseudoVerilog;
	&finish();
  }
}

sub init() {
  $V_FILE   = new FileHandle "> $verilog"  or print STDERR  "$!: $verilog";
}

sub finish() {
  close($V_FILE);
}

########################################################################
sub genFlop() {
  my ($flopArgs) = @_;
  my @flopArgs = split(/\s+/,$flopArgs);
  my %flopArgs;
  
  # get args
  foreach my $arg (@flopArgs) {
    if ($arg =~ /^\.(\S+)=(\S+)$/) {
      $flopArgs{$1} = $2;
    }
  }

  # clk and rst edges
  if (!defined($flopArgs{'clkedge'})) {$flopArgs{'clkedge'} = "pos";}
  if (!defined($flopArgs{'rstedge'})) {$flopArgs{'rstedge'} = "neg";}
  my $clkedge = $flopArgs{'clkedge'}."edge";
  my $rstedge = $flopArgs{'rstedge'}."edge";
  if ($rstedge =~ /neg/) {
    $rstprefix = "!";
  } else {
    $rstprefix = "";
  }

  # output reg name
  my $outname = $flopArgs{'out'};
  $outname =~ s/\[.*\]//;
  

  #find width
  my $width = netWidth($flopArgs{'out'});
  my $declWidth = "";
  if ($width > 1) {
    $declWidth = '['.&netRange($flopArgs{'out'}) .']';
  }

  print $V_FILE qq^
reg $declWidth $outname;
always @($clkedge $flopArgs{'clk'} or $rstedge $flopArgs{'rst'}) begin
  if ($rstprefix $flopArgs{'rst'}) {
    $flopArgs{'out'} <= ${width}'b0;
  } else {
    $flopArgs{'out'} <= $flopArgs{'in'};
  }
end\n
^;
} #sub genFlops


########################################################################
sub genDatapath {
  my ($datapathArgs) = @_;
  my @datapathArgs = split(/\s+/,$datapathArgs);
  my %datapathArgs;
  my @in;
  my $expression;

  # get args
  foreach my $arg (@datapathArgs) {
    if ($arg =~ /^\.(\S+)=(\S+)$/) {
      $datapathArgs{$1} = $2;
    }
  }

  if ($datapathArgs{'in'} =~ /"(.*)"/) {
    @in = split(/,/,$1);
  } else {
    @in = ($datapathArgs{'in'});
  }

  $expression = $in[0];
  for (my $i=1; $i <=$#in; $i++) {
    $expression .= " ".$datapathArgs{'op'}." ".$in[$i];
  } #for

  # output reg name
  my $outname = $datapathArgs{'out'};
  $outname =~ s/\[.*\]//;
  my $declWidth = netDeclRange($datapathArgs{'out'});

  print $V_FILE qq^
wire $declWidth $outname;
assign $datapathArgs{'out'} = $expression;\n
^;

} # sub genDatapath


########################################################################
sub genFifo {
  my ($fifoArgs) = @_;

  $_ = $fifoArgs;
  s/^\./-/;
  s/\s+\./ -/g;
  $fifoArgs = $_;

  # get args
  foreach my $arg (@fifoArgs) {
    if ($arg =~ /^\.(\S+)=(\S+)$/) {
      $fifoArgs{$1} = $2;
    }
  }


  $fifoHDL   = new Fifo;
  $fifoHDL->makeFifo($fifoArgs);
  $instStr = $fifoHDL->getInstance();

  print $V_FILE qq^
$instStr;
^;
} # sub genFifo

########################################################################
sub genCombo {
  my ($comboArgs) = @_;

  $_ = $comboArgs;
  s/^\./-/;
  s/\s+\./ -/g;
  $comboArgs = $_;

  # get args
  foreach my $arg (@comboArgs) {
    if ($arg =~ /^\.(\S+)=(\S+)$/) {
      $comboArgs{$1} = $2;
    }
  }


  my $comboHDL   = new Combo;
  my $comboStr = $comboHDL->makeCombo($comboArgs);

  print $V_FILE qq^
$comboStr;
^;
} # sub genCombo

########################################################################

sub readPseudoVerilog {
  $P_FILE   = new FileHandle "$pverilog"   or print STDERR "$!: $pverilog\n";
  my $pLineCount = 0;
  my $pLine = <$P_FILE>;
  $pLineCount++;

  while ($pLine) {
	print $pLine if ($debug);
	if ($pLine =~ /^\s*::/) {
	  ## this is a pseudo verilog construct
	  print $pLine if ($debug);
	  print $V_FILE "// p2v: Autogenerated code follows\n" ;
	  print $V_FILE "// $pLine" ;
	  if ($pLine =~ /^\s*::\s*flop\s*\((.*)\)/) {
		print "p2v: Found flop at $pLineCount\n" if ($debug);
		&genFlop($1);
	  } elsif ($pLine =~ /^\s*::\s*datapath\s*\((.*)\)/) {
		print "p2v: Found datapath at $pLineCount\n" if ($debug);
		&genDatapath($1);
	  } elsif ($pLine =~ /^\s*::\s*fifo\s*\((.*)\)/) {
		print "p2v: Found fifo at $pLineCount\n" if ($debug);
		&genFifo($1);
	  } elsif ($pLine =~ /^\s*::\s*combo\s*\((.*)\)/) {
		print "p2v: Found combo at $pLineCount\n" if ($debug);
		&genCombo($1);
	  }
	  print $V_FILE "// p2v: Autogenerated code ends\n\n" ;
	}
	$pLine = <$P_FILE>;
	$pLineCount++;
  }
  close($P_FILE);
} #sub readPseudoVerilog


########################################################################
sub log2 {
    my ($num) = @_;
    return(log($num)/log(2));
}

sub int_log2 {
    my ($num) = @_;
    return int log2 $num;
}

sub netWidth {
  my ($sig) = @_;
  my $width = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$width = $1 - $2 + 1;
  }
  return($width);
}

sub netMSB {
  my ($sig) = @_;
  my $msb = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$msb = $1;
  }
  return($msb);
}

sub netLSB {
  my ($sig) = @_;
  my $lsb = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$lsb = $1;
  }
  return($lsb);
}

sub netRange {
  my ($sig) = @_;
  my $range;
  if ($sig =~ /\[(\d+:\d+)\]/) {
	$range = $1;
  }
  else {$range = "";}
  return($range);
}

sub netDeclRange {
  my ($sig) = @_;
  my $declRange;
  if ($sig =~ /\[(\d+:\d+)\]/) {
	$declRange = "[".$1."]";
  }
  else {$declRange = "";}
  return($declRange);
}

########################################################################
sub p2v_usage {
    print"Usage: $0 -p psuedo_verilog_file -v verilog_file [-verbose -debug -norun -help]\n";
	return;
}


1;
