#use Getopt::Long qw(GetOptionsFromString);

package Fifo;
## rename this to proton::RTL::Fifo

sub new {
  ###############################################################
  # Configuration is stored in the following variables = defaults
  my $inst = {
	      file    => "fifo.v",
	      name    => "fifo",
	      iname   => "fifo1",
	      clk     => "clk",
	      rst     => "rst_",
	      clkedge => "posedge",
	      rstedge => "negedge",
	      width   => 31,
	      depth   => 8,
	      type    => "flop", ##storage type: flop/ram
	      data_in => "data_in",
	      data_out=> "data_out",
	      empty   => "empty",
	      full    => "full",
	      rd_en   => "rd_en",
	      wr_en   => "wr_en"
	     };
  ###############################################################
  bless $inst, 'Fifo';
  return $inst;
}



sub makeFifo() {
  my ($self,@args) = @_;
  my $V_FILE;

  &init($self,@args);
  if ($help) {
    &usage();
  } else {
    &genCode($self);
  } #if...else
}


sub init() {
  my ($self, $args) =  @_;
  if (!defined($args)) {
    $args = "";
  }
  my $parseResult = Getopt::Long::GetOptionsFromString($args , 
						       "file=s"     => \$self->{'file'},
						       "name=s"     => \$self->{'name'},
						       "iname=s"    => \$self->{'iname'},
						       "clk=s"      => \$self->{'clk'},
						       "rst=s"      => \$self->{'rst'},
						       "clkedge=s"  => \$self->{'clkedge'},
						       "rstedge=s"  => \$self->{'rstedge'},
						       "width=s"    => \$self->{'width'},
						       "depth=s"    => \$self->{'depth'},
						       "data_in=s"  => \$self->{'data_in'},
						       "data_out=s" => \$self->{'data_out'},
						       "empty=s"    => \$self->{'empty'},
						       "type=s"     => \$self->{'type'},
						       "full=s"     => \$self->{'full'},
						       "rd_en=s"    => \$self->{'rd_en'},
						       "wr_en=s"    => \$self->{'wr_en'},
						       "h"          => \$self->{'help'},
						       "help"       => \$self->{'help'},
						       "debug"      => \$self->{'debug'},
						       "verbose"    => \$self->{'verbose'},
						      );
} #sub init

sub genCode {
  my ($self) = @_;

  my $file    = $self->{'file'};
  my $name    = $self->{'name'};
  my $clk     = $self->{'clk'};
  my $rst     = $self->{'rst'};
  my $clkedge = $self->{'clkedge'};
  my $rstedge = $self->{'rstedge'};
  my $width   = $self->{'width'};
  my $depth   = $self->{'depth'};
  my $type    = $self->{'type'};
  my $data_in = $self->{'data_in'};
  my $data_out= $self->{'data_out'};
  my $empty   = $self->{'empty'};
  my $full    = $self->{'full'};
  my $rd_en   = $self->{'rd_en'};
  my $wr_en   = $self->{'wr_en'};

  my $addrBits = log2($depth);

  $V_FILE   = new FileHandle "> $file"  or print STDERR  "$!: $file ";

print $V_FILE qq^
///////////////////////////////////////////////////////////////////////////////
//////////////////// Autogenerated code for fifo ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////
module $name (
  $clk,
  $rst,
  $data_in,
  $data_out,
  $rd_en,
  $wr_en,
  $empty,
  $full);
 
parameter FIFO_WIDTH = $width;
parameter FIFO_DEPTH = $depth;
parameter ADDR_WIDTH = $addrBits;

input  $clk;
input  $rst;
output $empty;
output $full;
input  $rd_en;
input  $wr_en;
input  [FIFO_WIDTH-1:0] $data_in;
output [FIFO_WIDTH-1:0] $data_out;

reg  [ADDR_WIDTH-1:0] wr_pointer;
reg  [ADDR_WIDTH-1:0] rd_pointer;
reg  [ADDR_WIDTH:0]   count;
reg  [FIFO_WIDTH-1:0] $data_out ;
wire [FIFO_WIDTH-1:0] data_ram ;

always @ ($clkedge clk or $rstedge $rst) begin
  if (!$rst) begin
    wr_pointer <= 0;
    rd_pointer <= 0;
    $data_out  <= 0;
  end else begin
    if (wr_en ) begin
      wr_pointer <= wr_pointer + 1;
    end
    if (rd_en) begin
      rd_pointer <= rd_pointer + 1;
      $data_out <= data_ram;
    end
  end // else: !if(!$rst)
end // always @ ($clkedge clk or $rstedge $rst)

always @ ($clkedge clk or $rstedge $rst) begin
  if (!$rst) begin
    count <= 0;
  end else if ($rd_en && (!$wr_en) && (count != 0)) begin
    count <= count - 1;
  end else if ($wr_en && (!$rd_en) && (count != FIFO_DEPTH)) begin
    count <= count + 1;
  end //if
end //always

assign $full  = (count == FIFO_DEPTH);
assign $empty = (count == 0);

${name}_${type} ${name}_${type} (
   .wr_en    ($wr_en)
  ,.wr_addr  (wr_pointer)
  ,.data_in  ($data_in)
  ,.$clk      ($clk)
  ,.$rst      ($rst)
  ,.rd_en    ($rd_en)
  ,.rd_addr  (rd_pointer)
  ,.data_out (data_ram));
endmodule


module ${name}_${type} (
  ,$clk
  ,$rst
  ,wr_en
  ,wr_addr
  ,data_in
  ,rd_en
  ,rd_addr
  ,data_out);

parameter DATA_WIDTH = $width;
parameter DATA_DEPTH = $depth;
parameter ADDR_WIDTH = $addrBits;

input  $clk;
input  $rst;
input  rd_en;
input  wr_en;
input  [ADDR_WIDTH-1:0] rd_addr;
input  [ADDR_WIDTH-1:0] wr_addr;
input  [DATA_WIDTH-1:0] data_in;
output [DATA_WIDTH-1:0] data_out;

reg  [DATA_WIDTH-1:0] data_out;
reg  [DATA_DEPTH-1:0] flop_wr_en;
reg  [DATA_WIDTH-1:0] data_rd;
^;

for (my $i=0; $i<$depth; $i++) {
print $V_FILE qq^
reg  [DATA_WIDTH-1:0] flop_${i};^;
}

print $V_FILE qq^

always @ (wr_addr or wr_en) begin
  flop_wr_en = 0;
  case(wr_addr) ^;
for (my $i=0; $i<$depth; $i++) {
print $V_FILE qq^
    $i : flop_wr_en[$i] = wr_en;^;
}
print $V_FILE qq^
    default: flop_wr_en = {DATA_DEPTH{wr_en}};
  endcase
end
^;

for (my $i=0; $i<$depth; $i++) {
print $V_FILE qq^
always @ ($clkedge clk or $rstedge $rst) begin
  if (!$rst) begin
    flop_${i} <= 0;
  end else if (flop_wr_en[$i]) begin
    flop_${i} <= data_in;
  end
end
^;
}

print $V_FILE qq^
always @ (rd_addr) begin
  case(rd_addr) ^;
for (my $i=0; $i<$depth; $i++) {
print $V_FILE qq^
    $i : data_rd = flop_${i};^;
}
print $V_FILE qq^
    default: data_rd = {DATA_WIDTH{1'bx}};
  endcase
end
^;

print $V_FILE qq^
always @ ($clkedge clk or $rstedge $rst) begin
  if (!$rst) begin
    data_out <= 0;
  end else if (rd_en) begin
    data_out <= data_rd;
  end
end

endmodule
^;



} #sub genCode

########################################################################
sub getInstance {
  my ($self) = @_;
  my $instStr;


  $instStr = "$self->{'name'} $self->{'iname'} ( 
  .$self->{'clk'}       ($self->{'clk'})
  .$self->{'rst'}       ($self->{'rst'})
  .$self->{'data_in'}   ($self->{'data_in'})
  .$self->{'data_out'}  ($self->{'data_out'})
  .$self->{'rd_en'}     ($self->{'rd_en'})
  .$self->{'wr_en'}     ($self->{'wr_en'})
  .$self->{'empty'}     ($self->{'empty'})
  .$self->{'full'}      ($self->{'full'})
   )\n\n";

  return $instStr;
}

########################################################################
sub log2 {
    my ($num) = @_;
    if ($num == 1) {
      return(1)
    } else {
      return(POSIX::ceil(log($num)/log(2)));
    }
}

sub int_log2 {
    my ($num) = @_;
    return int log2 $num;
}

sub netWidth {
  my ($sig) = @_;
  my $width = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$width = $1 - $2 + 1;
  }
  return($width);
}

sub netMSB {
  my ($sig) = @_;
  my $msb = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$msb = $1;
  }
  return($msb);
}

sub netLSB {
  my ($sig) = @_;
  my $lsb = 1;
  if ($sig =~ /\[(\d+):(\d+)\]/) {
	$lsb = $1;
  }
  return($lsb);
}

sub netRange {
  my ($sig) = @_;
  my $range;
  if ($sig =~ /\[(\d+:\d+)\]/) {
	$range = $1;
  }
  else {$range = "";}
  return($range);
}

sub netDeclRange {
  my ($sig) = @_;
  my $declRange;
  if ($sig =~ /\[(\d+:\d+)\]/) {
	$declRange = "[".$1."]";
  }
  else {$declRange = "";}
  return($declRange);
}

########################################################################
sub usage {
 	print"Usage: $0 \n";	
        print "                       -help\n";
	print "                       -file=<verilog_file>\n";
	print "                       -name=<fifo_module_name>\n";
	print "                       -iname=<fifo_instance_name>\n";
        print "                       -clk=<clock_pin>\n";
        print "                       -reset=<reset_pin>\n";
        print "                       -clkedge=<clock_edge>\n";
        print "                       -rstedge=<reset_edge>\n";
        print "                       -width=<width>\n";
        print "                       -depth=<depth>\n";
        print "                       -typw=<storage_type>\n";
        print "                       -data_in=<data_in>\n";
        print "                       -data_out=<data_out>\n";
        print "                       -empty=<empty>\n";
        print "                       -full=<full>\n";
        print "                       -rd_en=<rd_en>\n";
        print "                       -wr_en=<wr_en>\n";
        print "                       -debug\n";
	return;
}




1;
