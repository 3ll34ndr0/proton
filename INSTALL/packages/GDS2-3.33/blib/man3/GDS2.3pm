.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GDS2 3"
.TH GDS2 3 "2014-09-27" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GDS2 \- GDS2 stream module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is \s-1GDS2,\s0 a module for creating programs to read and/or write \s-1GDS2\s0 files.
.PP
Send feedback/suggestions to
perl \-le '$_=q(Zpbhgnpe@pvnt.uxa);$_=~tr/n\-sa\-gt\-zh\-mZ/a\-zS/;print;'
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Author: Ken Schumack (c) 1999\-2014. All rights reserved.
This module is free software. It may be used, redistributed
and/or modified under the terms of the Perl Artistic License.
( see http://www.perl.com/pub/a/language/misc/Artistic.html )
 Have fun, Ken
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1GDS2\s0 allows you to read and write \s-1GDS2\s0 files record by record in a
stream fashion which inherently uses little memory. It is capable but
not fast. If you have large files you may be happier using
http://sourceforge.net/projects/gds2/
.SH "Examples"
.IX Header "Examples"
.Vb 10
\&  Layer change:
\&    here\*(Aqs a bare bones script to change all layer 59 to 66 given a file to
\&    read and a new file to create.
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use GDS2;
\&    my $fileName1 = $ARGV[0];
\&    my $fileName2 = $ARGV[1];
\&    my $gds2File1 = new GDS2(\-fileName => $fileName1);
\&    my $gds2File2 = new GDS2(\-fileName => ">$fileName2");
\&    while (my $record = $gds2File1 \-> readGds2Record)
\&    {
\&        if ($gds2File1 \-> returnLayer == 59)
\&        {
\&            $gds2File2 \-> printLayer(\-num=>66);
\&        }
\&        else
\&        {
\&            $gds2File2 \-> printRecord(\-data=>$record);
\&        }
\&    }
\&
\&
\&  Gds2 dump:
\&    here\*(Aqs a complete program to dump the contents of a stream file.
\&    #!/usr/bin/perl \-w
\&    use GDS2;
\&    $\e="\en";
\&    my $gds2File = new GDS2(\-fileName=>$ARGV[0]);
\&    while ($gds2File \-> readGds2Record)
\&    {
\&        print $gds2File \-> returnRecordAsString;
\&    }
\&
\&
\&  Gds2 dump in GDT format: which is smaller and easier to parse \- http://sourceforge.net/projects/gds2/
\&    #!/usr/bin/perl \-w
\&    use GDS2;
\&    my $gds2File = new GDS2(\-fileName=>$ARGV[0]);
\&    while ($gds2File \-> readGds2Record)
\&    {
\&        print $gds2File \-> returnRecordAsString(\-compact=>1);
\&    }
\&
\&  Dump from the command line of a bzip2 compressed file:
\&  perl \-MGDS2 \-MFileHandle \-MIPC::Open3 \-e \*(Aq$f1=new FileHandle;$f0=new FileHandle;open3($f0,$f1,$f1,"bzcat test.gds.bz2");$gds=new GDS2(\-fileHandle=>$f1);while($gds\->readGds2Record){print $gds\->returnRecordAsString(\-compact=>1)}\*(Aq
\&
\&  Create a complete GDS2 stream file from scratch:
\&    #!/usr/bin/perl \-w
\&    use GDS2;
\&    my $gds2File = new GDS2(\-fileName=>\*(Aq>test.gds\*(Aq);
\&    $gds2File \-> printInitLib(\-name=>\*(Aqtestlib\*(Aq);
\&    $gds2File \-> printBgnstr(\-name=>\*(Aqtest\*(Aq);
\&    $gds2File \-> printPath(
\&                    \-layer=>6,
\&                    \-pathType=>0,
\&                    \-width=>2.4,
\&                    \-xy=>[0,0, 10.5,0, 10.5,3.3],
\&                 );
\&    $gds2File \-> printSref(
\&                    \-name=>\*(Aqcontact\*(Aq,
\&                    \-xy=>[4,5.5],
\&                 );
\&    $gds2File \-> printAref(
\&                    \-name=>\*(Aqcontact\*(Aq,
\&                    \-columns=>2,
\&                    \-rows=>3,
\&                    \-xy=>[0,0, 10,0, 0,15],
\&                 );
\&    $gds2File \-> printEndstr;
\&    $gds2File \-> printBgnstr(\-name => \*(Aqcontact\*(Aq);
\&    $gds2File \-> printBoundary(
\&                    \-layer=>10,
\&                    \-xy=>[0,0, 1,0, 1,1, 0,1],
\&                 );
\&    $gds2File \-> printEndstr;
\&    $gds2File \-> printEndlib();
.Ve
.PP
################################################################################
.SH "METHODS"
.IX Header "METHODS"
.SS "new \- open gds2 file"
.IX Subsection "new - open gds2 file"
.Vb 3
\&  usage:
\&  my $gds2File  = new GDS2(\-fileName => "filename.gds2"); ## to read
\&  my $gds2File2 = new GDS2(\-fileName => ">filename.gds2"); ## to write
\&
\&  \-or\- provide your own fileHandle:
\&
\&  my $gds2File  = new GDS2(\-fileHandle => $fh); ## e.g. to attach to a compression/decompression pipe
.Ve
.SS "fileNum \- file number..."
.IX Subsection "fileNum - file number..."
.Vb 1
\&  usage:
.Ve
.SS "close \- close gds2 file"
.IX Subsection "close - close gds2 file"
.Vb 7
\&  usage:
\&  $gds2File \-> close;
\&   \-or\-
\&  $gds2File \-> close(\-markEnd=>1); ## \-\- some systems have trouble closing files
\&  $gds2File \-> close(\-pad=>2048);  ## \-\- pad end with \e0\*(Aqs till file size is a
\&                                   ## multiple of number. Note: old reel to reel tapes on Calma
\&                                   ## systems used 2048 byte blocks
.Ve
.SH "High Level Write Methods"
.IX Header "High Level Write Methods"
.SS "\fIprintInitLib()\fP \- Does all the things needed to start a library, writes \s-1HEADER,BGNLIB,LIBNAME\s0,and \s-1UNITS\s0 records"
.IX Subsection "printInitLib() - Does all the things needed to start a library, writes HEADER,BGNLIB,LIBNAME,and UNITS records"
The default is to create a library with a default unit of 1 micron that has a resolution of 1000. To get this set uUnit to 0.001 (1/1000) and the dbUnit to 1/1000th of a micron (1e\-9).
   usage:
     \f(CW$gds2File\fR \-> printInitLib(\-name    => \*(L"testlib\*(R",  ## required
                               \-isoDate => 0|1         ## (optional) use \s-1ISO 4\s0 digit date 2001 vs 101
                               \-uUnit   => real number ## (optional) default is 0.001
                               \-dbUnit  => real number ## (optional) default is 1e\-9
                              );
.PP
.Vb 1
\&     ## defaults to current date for library date
\&
\&   note:
\&     remember to close library with printEndlib()
.Ve
.SS "printBgnstr \- Does all the things needed to start a structure definition"
.IX Subsection "printBgnstr - Does all the things needed to start a structure definition"
.Vb 4
\&   usage:
\&    $gds2File \-> printBgnstr(\-name => "nand3" ## writes BGNSTR and STRNAME records
\&                             \-isoDate => 1|0  ## (optional) use ISO 4 digit date 2001 vs 101
\&                             );
\&
\&   note:
\&     remember to close with printEndstr()
.Ve
.SS "printPath \- prints a gds2 path"
.IX Subsection "printPath - prints a gds2 path"
.Vb 7
\&  usage:
\&    $gds2File \-> printPath(
\&                    \-layer=>#,
\&                    \-dataType=>#,     ##optional
\&                    \-pathType=>#,
\&                    \-width=>#.#,
\&                    \-unitWidth=>#,    ## (optional) directly specify width in data base units (vs \-width which is multipled by resolution)
\&
\&                    \-xy=>\e@array,     ## array of reals
\&                      # \-or\-
\&                    \-xyInt=>\e@array,  ## array of internal ints (optional \-wks better if you are modifying an existing GDS2 file)
\&                  );
\&
\&  note:
\&    layer defaults to 0 if \-layer not used
\&    pathType defaults to 0 if \-pathType not used
\&      pathType 0 = square end
\&               1 = round end
\&               2 = square \- extended 1/2 width
\&               4 = custom plus variable path extension...
\&    width defaults to 0.0 if \-width not used
.Ve
.SS "printBoundary \- prints a gds2 boundary"
.IX Subsection "printBoundary - prints a gds2 boundary"
.Vb 4
\&  usage:
\&    $gds2File \-> printBoundary(
\&                    \-layer=>#,
\&                    \-dataType=>#,
\&
\&                    \-xy=>\e@array,     ## ref to array of reals
\&                      # \-or\-
\&                    \-xyInt=>\e@array,  ## ref to array of internal ints (optional \-wks better if you are modifying an existing GDS2 file)
\&                 );
\&
\&  note:
\&    layer defaults to 0 if \-layer not used
\&    dataType defaults to 0 if \-dataType not used
.Ve
.SS "printSref \- prints a gds2 Structure REFerence"
.IX Subsection "printSref - prints a gds2 Structure REFerence"
.Vb 3
\&  usage:
\&    $gds2File \-> printSref(
\&                    \-name=>string,   ## Name of structure
\&
\&                    \-xy=>\e@array,    ## ref to array of reals
\&                      # \-or\-
\&                    \-xyInt=>\e@array, ## ref to array of internal ints (optional \-wks better than \-xy if you are modifying an existing GDS2 file)
\&
\&                    \-angle=>#.#,     ## (optional) Default is 0.0
\&                    \-mag=>#.#,       ## (optional) Default is 1.0
\&                    \-reflect=>0|1    ## (optional)
\&                 );
\&
\&  note:
\&    best not to specify angle or mag if not needed
.Ve
.SS "printAref \- prints a gds2 Array REFerence"
.IX Subsection "printAref - prints a gds2 Array REFerence"
.Vb 5
\&  usage:
\&    $gds2File \-> printAref(
\&                    \-name=>string,   ## Name of structure
\&                    \-columns=>#,     ## Default is 1
\&                    \-rows=>#,        ## Default is 1
\&
\&                    \-xy=>\e@array,    ## ref to array of reals
\&                      # \-or\-
\&                    \-xyInt=>\e@array, ## ref to array of internal ints (optional \-wks better if you are modifying an existing GDS2 file)
\&
\&                    \-angle=>#.#,     ## (optional) Default is 0.0
\&                    \-mag=>#.#,       ## (optional) Default is 1.0
\&                    \-reflect=>0|1    ## (optional)
\&                 );
\&
\&  note:
\&    best not to specify angle or mag if not needed
\&    xyList: 1st coord: origin, 2nd coord: X of col * xSpacing + origin, 3rd coord: Y of row * ySpacing + origin
.Ve
.SS "printText \- prints a gds2 Text"
.IX Subsection "printText - prints a gds2 Text"
.Vb 8
\&  usage:
\&    $gds2File \-> printText(
\&                    \-string=>string,
\&                    \-layer=>#,      ## Default is 0
\&                    \-textType=>#,   ## Default is 0
\&                    \-font=>#,       ## 0\-3
\&                    \-top, or \-middle, \-bottom,     ##optional vertical presentation
\&                    \-left, or \-center, or \-right,  ##optional horizontal presentation
\&
\&                    \-xy=>\e@array,     ## ref to array of reals
\&                      # \-or\-
\&                    \-xyInt=>\e@array,  ## ref to array of internal ints (optional \-wks better if you are modifying an existing GDS2 file)
\&
\&                    \-x=>#.#,          ## optional way of passing in x value
\&                    \-y=>#.#,          ## optional way of passing in y value
\&                    \-angle=>#.#,      ## (optional) Default is 0.0
\&                    \-mag=>#.#,        ## (optional) Default is 1.0
\&                    \-reflect=>#,      ## (optional) Default is 0
\&                 );
\&
\&  note:
\&    best not to specify reflect, angle or mag if not needed
.Ve
.SH "Low Level Generic Write Methods"
.IX Header "Low Level Generic Write Methods"
.SS "\fIsaveGds2Record()\fP \- low level method to create a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.IX Subsection "saveGds2Record() - low level method to create a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.Vb 1
\&  NOTE: THIS ONLY USES GDS2 OBJECT TO GET RESOLUTION
\&
\&  usage:
\&    saveGds2Record(
\&            \-type=>string,
\&            \-data=>data_If_Needed, ##optional for some types
\&            \-scale=>#.#,           ##optional number to scale data to. I.E \-scale=>0.5 #default is NOT to scale
\&            \-snap=>#.#,            ##optional number to snap data to I.E. \-snap=>0.005 #default is 1 resolution unit, typically 0.001
\&    );
\&
\&  examples:
\&    my $gds2File = new GDS2(\-fileName => ">$fileName");
\&    my $record = $gds2File \-> saveGds2Record(\-type=>\*(Aqheader\*(Aq,\-data=>3);
\&    $gds2FileOut \-> printGds2Record(\-type=>\*(Aqrecord\*(Aq,\-data=>$record);
.Ve
.SS "\fIprintGds2Record()\fP \- low level method to print a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.IX Subsection "printGds2Record() - low level method to print a gds2 record given record type and data (if required). Data of more than one item should be given as a list."
.Vb 7
\&  usage:
\&    printGds2Record(
\&            \-type=>string,
\&            \-data=>data_If_Needed, ##optional for some types
\&            \-scale=>#.#,           ##optional number to scale data to. I.E \-scale=>0.5 #default is NOT to scale
\&            \-snap=>#.#,            ##optional number to snap data to I.E. \-snap=>0.005 #default is 1 resolution unit, typically 0.001
\&    );
\&
\&  examples:
\&    my $gds2File = new GDS2(\-fileName => ">$fileName");
\&
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqheader\*(Aq,\-data=>3);
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqbgnlib\*(Aq,\-data=>[99,12,1,22,33,0,99,12,1,22,33,9]);
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqlibname\*(Aq,\-data=>"testlib");
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqunits\*(Aq,\-data=>[0.001, 1e\-9]);
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqbgnstr\*(Aq,\-data=>[99,12,1,22,33,0,99,12,1,22,33,9]);
\&    ...
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqendstr\*(Aq);
\&    $gds2File \-> printGds2Record(\-type=>\*(Aqendlib\*(Aq);
\&
\&  Note: the special record type of \*(Aqrecord\*(Aq can be used to copy a complete record
\&  just read in:
\&    while (my $record = $gds2FileIn \-> readGds2Record())
\&    {
\&        $gds2FileOut \-> printGds2Record(\-type=>\*(Aqrecord\*(Aq,\-data=>$record);
\&    }
.Ve
.SS "printRecord \- prints a record just read"
.IX Subsection "printRecord - prints a record just read"
.Vb 4
\&  usage:
\&    $gds2File \-> printRecord(
\&                  \-data => $record
\&                );
.Ve
.SH "Low Level Generic Read Methods"
.IX Header "Low Level Generic Read Methods"
.SS "readGds2Record \- reads record header and data section"
.IX Subsection "readGds2Record - reads record header and data section"
.Vb 8
\&  usage:
\&  while ($gds2File \-> readGds2Record)
\&  {
\&      if ($gds2File \-> returnRecordTypeString eq \*(AqLAYER\*(Aq)
\&      {
\&          $layersFound[$gds2File \-> layer] = 1;
\&      }
\&  }
.Ve
.SS "readGds2RecordHeader \- only reads gds2 record header section (2 bytes)"
.IX Subsection "readGds2RecordHeader - only reads gds2 record header section (2 bytes)"
.Vb 10
\&  slightly faster if you just want a certain thing...
\&  usage:
\&  while ($gds2File \-> readGds2RecordHeader)
\&  {
\&      if ($gds2File \-> returnRecordTypeString eq \*(AqLAYER\*(Aq)
\&      {
\&          $gds2File \-> readGds2RecordData;
\&          $layersFound[$gds2File \-> returnLayer] = 1;
\&      }
\&  }
.Ve
.SS "readGds2RecordData \- only reads record data section"
.IX Subsection "readGds2RecordData - only reads record data section"
.Vb 10
\&  slightly faster if you just want a certain thing...
\&  usage:
\&  while ($gds2File \-> readGds2RecordHeader)
\&  {
\&      if ($gds2File \-> returnRecordTypeString eq \*(AqLAYER\*(Aq)
\&      {
\&          $gds2File \-> readGds2RecordData;
\&          $layersFound[$gds2File \-> returnLayer] = 1;
\&      }
\&  }
.Ve
.SH "Low Level Generic Evaluation Methods"
.IX Header "Low Level Generic Evaluation Methods"
.SS "returnRecordType \- returns current (read) record type as integer"
.IX Subsection "returnRecordType - returns current (read) record type as integer"
.Vb 5
\&  usage:
\&  if ($gds2File \-> returnRecordType == 6)
\&  {
\&      print "found STRNAME";
\&  }
.Ve
.SS "returnRecordTypeString \- returns current (read) record type as string"
.IX Subsection "returnRecordTypeString - returns current (read) record type as string"
.Vb 5
\&  usage:
\&  if ($gds2File \-> returnRecordTypeString eq \*(AqLAYER\*(Aq)
\&  {
\&      code goes here...
\&  }
.Ve
.SS "returnRecordAsString \- returns current (read) record as a string"
.IX Subsection "returnRecordAsString - returns current (read) record as a string"
.Vb 5
\&  usage:
\&  while ($gds2File \-> readGds2Record)
\&  {
\&      print $gds2File \-> returnRecordAsString(\-compact=>1);
\&  }
.Ve
.SS "returnXyAsArray \- returns current (read) \s-1XY\s0 record as an array"
.IX Subsection "returnXyAsArray - returns current (read) XY record as an array"
.Vb 7
\&  usage:
\&    $gds2File \-> returnXyAsArray(
\&                    \-asInteger => 0|1    ## (optional) default is true. Return integer
\&                                         ## array or if false return array of reals.
\&                    \-withClosure => 0|1  ## (optional) default is true. Whether to
\&                                         ##return a rectangle with 5 or 4 points.
\&               );
\&
\&  example:
\&  while ($gds2File \-> readGds2Record)
\&  {
\&      my @xy = $gds2File \-> returnXyAsArray if ($gds2File \-> isXy);
\&  }
.Ve
.SS "returnRecordAsPerl \- returns current (read) record as a perl command to facilitate the creation of parameterized gds2 data with perl."
.IX Subsection "returnRecordAsPerl - returns current (read) record as a perl command to facilitate the creation of parameterized gds2 data with perl."
.Vb 8
\&  usage:
\&  #!/usr/local/bin/perl
\&  use GDS2;
\&  my $gds2File = new GDS2(\-fileName=>"test.gds");
\&  while ($gds2File \-> readGds2Record)
\&  {
\&      print $gds2File \-> returnRecordAsPerl;
\&  }
.Ve
.SH "Low Level Specific Write Methods"
.IX Header "Low Level Specific Write Methods"
.SS "printAngle \- prints \s-1ANGLE\s0 record"
.IX Subsection "printAngle - prints ANGLE record"
.Vb 2
\&  usage:
\&    $gds2File \-> printAngle(\-num=>#.#);
.Ve
.SS "printAttrtable \- prints \s-1ATTRTABLE\s0 record"
.IX Subsection "printAttrtable - prints ATTRTABLE record"
.Vb 2
\&  usage:
\&    $gds2File \-> printAttrtable(\-string=>$string);
.Ve
.SS "printBgnextn \- prints \s-1BGNEXTN\s0 record"
.IX Subsection "printBgnextn - prints BGNEXTN record"
.Vb 2
\&  usage:
\&    $gds2File \-> printBgnextn(\-num=>#.#);
.Ve
.SS "printBgnlib \- prints \s-1BGNLIB\s0 record"
.IX Subsection "printBgnlib - prints BGNLIB record"
.Vb 4
\&  usage:
\&    $gds2File \-> printBgnlib(
\&                            \-isoDate => 0|1 ## (optional) use ISO 4 digit date 2001 vs 101
\&                           );
.Ve
.SS "printBox \- prints \s-1BOX\s0 record"
.IX Subsection "printBox - prints BOX record"
.Vb 2
\&  usage:
\&    $gds2File \-> printBox;
.Ve
.SS "printBoxtype \- prints \s-1BOXTYPE\s0 record"
.IX Subsection "printBoxtype - prints BOXTYPE record"
.Vb 2
\&  usage:
\&    $gds2File \-> printBoxtype(\-num=>#);
.Ve
.SS "printColrow \- prints \s-1COLROW\s0 record"
.IX Subsection "printColrow - prints COLROW record"
.Vb 2
\&  usage:
\&    $gds2File \-> printBoxtype(\-columns=>#, \-rows=>#);
.Ve
.SS "printDatatype \- prints \s-1DATATYPE\s0 record"
.IX Subsection "printDatatype - prints DATATYPE record"
.Vb 2
\&  usage:
\&    $gds2File \-> printDatatype(\-num=>#);
.Ve
.SS "printElkey \- prints \s-1ELKEY\s0 record"
.IX Subsection "printElkey - prints ELKEY record"
.Vb 2
\&  usage:
\&    $gds2File \-> printElkey(\-num=>#);
.Ve
.SS "printEndel \- closes an element definition"
.IX Subsection "printEndel - closes an element definition"
.SS "printEndextn \- prints path end extension record"
.IX Subsection "printEndextn - prints path end extension record"
.Vb 2
\&  usage:
\&    $gds2File printEndextn \-> (\-num=>#.#);
.Ve
.SS "printEndlib \- closes a library definition"
.IX Subsection "printEndlib - closes a library definition"
.SS "printEndstr \- closes a structure definition"
.IX Subsection "printEndstr - closes a structure definition"
.SS "printEndmasks \- prints a \s-1ENDMASKS\s0"
.IX Subsection "printEndmasks - prints a ENDMASKS"
.SS "printFonts \- prints a \s-1FONTS\s0 record"
.IX Subsection "printFonts - prints a FONTS record"
.Vb 2
\&  usage:
\&    $gds2File \-> printFonts(\-string=>\*(Aqnames_of_font_files\*(Aq);
.Ve
.SS "printHeader \- Prints a rev 3 header"
.IX Subsection "printHeader - Prints a rev 3 header"
.Vb 4
\&  usage:
\&    $gds2File \-> printHeader(
\&                  \-num => #  ## optional, defaults to 3. valid revs are 0,3,4,5,and 600
\&                );
.Ve
.SS "printLayer \- prints a \s-1LAYER\s0 number"
.IX Subsection "printLayer - prints a LAYER number"
.Vb 4
\&  usage:
\&    $gds2File \-> printLayer(
\&                  \-num => #  ## optional, defaults to 0.
\&                );
.Ve
.SS "printLibname \- Prints library name"
.IX Subsection "printLibname - Prints library name"
.Vb 2
\&  usage:
\&    printLibname(\-name=>$name);
.Ve
.SS "printPathtype \- prints a \s-1PATHTYPE\s0 number"
.IX Subsection "printPathtype - prints a PATHTYPE number"
.Vb 4
\&  usage:
\&    $gds2File \-> printPathtype(
\&                  \-num => #  ## optional, defaults to 0.
\&                );
.Ve
.SS "printMag \- prints a \s-1MAG\s0 number"
.IX Subsection "printMag - prints a MAG number"
.Vb 4
\&  usage:
\&    $gds2File \-> printMag(
\&                  \-num => #.#  ## optional, defaults to 0.0
\&                );
.Ve
.SS "printNodetype \- prints a \s-1NODETYPE\s0 number"
.IX Subsection "printNodetype - prints a NODETYPE number"
.Vb 4
\&  usage:
\&    $gds2File \-> printNodetype(
\&                  \-num => #
\&                );
.Ve
.SS "printPresentation \- prints a text presentation record"
.IX Subsection "printPresentation - prints a text presentation record"
.Vb 6
\&  usage:
\&    $gds2File \-> printPresentation(
\&                  \-font => #,  ##optional, defaults to 0, valid numbers are 0\-3
\&                  \-top, ||\-middle, || \-bottom, ## vertical justification
\&                  \-left, ||\-center, || \-right, ## horizontal justification
\&                );
\&
\&  example:
\&    gds2File \-> printPresentation(\-font=>0,\-top,\-left);
.Ve
.SS "printPropattr \- prints a property id number"
.IX Subsection "printPropattr - prints a property id number"
.Vb 2
\&  usage:
\&    $gds2File \-> printPropattr( \-num => # );
.Ve
.SS "printPropvalue \- prints a property value string"
.IX Subsection "printPropvalue - prints a property value string"
.Vb 2
\&  usage:
\&    $gds2File \-> printPropvalue( \-string => $string );
.Ve
.SS "printSname \- prints a \s-1SNAME\s0 string"
.IX Subsection "printSname - prints a SNAME string"
.Vb 2
\&  usage:
\&    $gds2File \-> printSname( \-name => $cellName );
.Ve
.SS "printStrans \- prints a \s-1STRANS\s0 record"
.IX Subsection "printStrans - prints a STRANS record"
.Vb 2
\&  usage:
\&    $gds2File \-> printStrans( \-reflect );
.Ve
.SS "printString \- prints a \s-1STRING\s0 record"
.IX Subsection "printString - prints a STRING record"
.Vb 2
\&  usage:
\&    $gds2File \-> printSname( \-string => $text );
.Ve
.SS "printStrname \- prints a structure name string"
.IX Subsection "printStrname - prints a structure name string"
.Vb 2
\&  usage:
\&    $gds2File \-> printStrname( \-name => $cellName );
.Ve
.SS "printTexttype \- prints a text type number"
.IX Subsection "printTexttype - prints a text type number"
.Vb 2
\&  usage:
\&    $gds2File \-> printTexttype( \-num => # );
.Ve
.SS "printUnits \- Prints units record."
.IX Subsection "printUnits - Prints units record."
.Vb 3
\&  options:
\&    \-uUnit   => real number ## (optional) default is 0.001
\&    \-dbUnit  => real number ## (optional) default is 1e\-9
.Ve
.SS "printWidth \- prints a width number"
.IX Subsection "printWidth - prints a width number"
.Vb 2
\&  usage:
\&    $gds2File \-> printWidth( \-num => # );
.Ve
.SS "printXy \- prints an \s-1XY\s0 array"
.IX Subsection "printXy - prints an XY array"
.Vb 4
\&  usage:
\&    $gds2File \-> printXy( \-xyInt => \e@arrayGds2Ints );
\&    \-or\-
\&    $gds2File \-> printXy( \-xy => \e@arrayReals );
\&
\&    \-xyInt most useful if reading and modifying... \-xy if creating from scratch
.Ve
.SH "Low Level Specific Evaluation Methods"
.IX Header "Low Level Specific Evaluation Methods"
.SS "returnFilePosition \- return current byte position (\s-1NOT\s0 zero based)"
.IX Subsection "returnFilePosition - return current byte position (NOT zero based)"
.Vb 2
\&  usage:
\&    my $position = $gds2File \-> returnFilePosition;
.Ve
.SS "returnBgnextn \- returns bgnextn if record is \s-1BGNEXTN\s0 else returns 0"
.IX Subsection "returnBgnextn - returns bgnextn if record is BGNEXTN else returns 0"
.Vb 1
\&  usage:
.Ve
.SS "returnDatatype \- returns datatype # if record is \s-1DATATYPE\s0 else returns \-1"
.IX Subsection "returnDatatype - returns datatype # if record is DATATYPE else returns -1"
.Vb 2
\&  usage:
\&    $dataTypesFound[$gds2File \-> returnDatatype] = 1;
.Ve
.SS "returnEndextn\- returns endextn if record is \s-1ENDEXTN\s0 else returns 0"
.IX Subsection "returnEndextn- returns endextn if record is ENDEXTN else returns 0"
.Vb 1
\&  usage:
.Ve
.SS "returnLayer \- returns layer # if record is \s-1LAYER\s0 else returns \-1"
.IX Subsection "returnLayer - returns layer # if record is LAYER else returns -1"
.Vb 2
\&  usage:
\&    $layersFound[$gds2File \-> returnLayer] = 1;
.Ve
.SS "returnPathtype \- returns pathtype # if record is \s-1PATHTYPE\s0 else returns \-1"
.IX Subsection "returnPathtype - returns pathtype # if record is PATHTYPE else returns -1"
.Vb 1
\&  usage:
.Ve
.SS "returnPropattr \- returns propattr # if record is \s-1PROPATTR\s0 else returns \-1"
.IX Subsection "returnPropattr - returns propattr # if record is PROPATTR else returns -1"
.Vb 1
\&  usage:
.Ve
.SS "returnPropvalue \- returns propvalue string if record is \s-1PROPVALUE\s0 else returns ''"
.IX Subsection "returnPropvalue - returns propvalue string if record is PROPVALUE else returns ''"
.Vb 1
\&  usage:
.Ve
.SS "returnSname \- return string if record type is \s-1SNAME\s0 else ''"
.IX Subsection "returnSname - return string if record type is SNAME else ''"
.SS "returnString \- return string if record type is \s-1STRING\s0 else ''"
.IX Subsection "returnString - return string if record type is STRING else ''"
.SS "returnStrname \- return string if record type is \s-1STRNAME\s0 else ''"
.IX Subsection "returnStrname - return string if record type is STRNAME else ''"
.SS "returnTexttype \- returns texttype # if record is \s-1TEXTTYPE\s0 else returns \-1"
.IX Subsection "returnTexttype - returns texttype # if record is TEXTTYPE else returns -1"
.Vb 2
\&  usage:
\&    $TextTypesFound[$gds2File \-> returnTexttype] = 1;
.Ve
.SS "returnWidth \- returns width # if record is \s-1WIDTH\s0 else returns \-1"
.IX Subsection "returnWidth - returns width # if record is WIDTH else returns -1"
.Vb 1
\&  usage:
.Ve
.SH "Low Level Specific Boolean Methods"
.IX Header "Low Level Specific Boolean Methods"
.SS "isAref \- return 0 or 1 depending on whether current record is an aref"
.IX Subsection "isAref - return 0 or 1 depending on whether current record is an aref"
.SS "isBgnlib \- return 0 or 1 depending on whether current record is a bgnlib"
.IX Subsection "isBgnlib - return 0 or 1 depending on whether current record is a bgnlib"
.SS "isBgnstr \- return 0 or 1 depending on whether current record is a bgnstr"
.IX Subsection "isBgnstr - return 0 or 1 depending on whether current record is a bgnstr"
.SS "isBoundary \- return 0 or 1 depending on whether current record is a boundary"
.IX Subsection "isBoundary - return 0 or 1 depending on whether current record is a boundary"
.SS "isDatatype \- return 0 or 1 depending on whether current record is datatype"
.IX Subsection "isDatatype - return 0 or 1 depending on whether current record is datatype"
.SS "isEndlib \- return 0 or 1 depending on whether current record is endlib"
.IX Subsection "isEndlib - return 0 or 1 depending on whether current record is endlib"
.SS "isEndel \- return 0 or 1 depending on whether current record is endel"
.IX Subsection "isEndel - return 0 or 1 depending on whether current record is endel"
.SS "isEndstr \- return 0 or 1 depending on whether current record is endstr"
.IX Subsection "isEndstr - return 0 or 1 depending on whether current record is endstr"
.SS "isHeader \- return 0 or 1 depending on whether current record is a header"
.IX Subsection "isHeader - return 0 or 1 depending on whether current record is a header"
.SS "isLibname \- return 0 or 1 depending on whether current record is a libname"
.IX Subsection "isLibname - return 0 or 1 depending on whether current record is a libname"
.SS "isPath \- return 0 or 1 depending on whether current record is a path"
.IX Subsection "isPath - return 0 or 1 depending on whether current record is a path"
.SS "isSref \- return 0 or 1 depending on whether current record is an sref"
.IX Subsection "isSref - return 0 or 1 depending on whether current record is an sref"
.SS "isSrfname \- return 0 or 1 depending on whether current record is an srfname"
.IX Subsection "isSrfname - return 0 or 1 depending on whether current record is an srfname"
.SS "isText \- return 0 or 1 depending on whether current record is a text"
.IX Subsection "isText - return 0 or 1 depending on whether current record is a text"
.SS "isUnits \- return 0 or 1 depending on whether current record is units"
.IX Subsection "isUnits - return 0 or 1 depending on whether current record is units"
.SS "isLayer \- return 0 or 1 depending on whether current record is layer"
.IX Subsection "isLayer - return 0 or 1 depending on whether current record is layer"
.SS "isStrname \- return 0 or 1 depending on whether current record is strname"
.IX Subsection "isStrname - return 0 or 1 depending on whether current record is strname"
.SS "isWidth \- return 0 or 1 depending on whether current record is width"
.IX Subsection "isWidth - return 0 or 1 depending on whether current record is width"
.SS "isXy \- return 0 or 1 depending on whether current record is xy"
.IX Subsection "isXy - return 0 or 1 depending on whether current record is xy"
.SS "isSname \- return 0 or 1 depending on whether current record is sname"
.IX Subsection "isSname - return 0 or 1 depending on whether current record is sname"
.SS "isColrow \- return 0 or 1 depending on whether current record is colrow"
.IX Subsection "isColrow - return 0 or 1 depending on whether current record is colrow"
.SS "isTextnode \- return 0 or 1 depending on whether current record is a textnode"
.IX Subsection "isTextnode - return 0 or 1 depending on whether current record is a textnode"
.SS "isNode \- return 0 or 1 depending on whether current record is a node"
.IX Subsection "isNode - return 0 or 1 depending on whether current record is a node"
.SS "isTexttype \- return 0 or 1 depending on whether current record is a texttype"
.IX Subsection "isTexttype - return 0 or 1 depending on whether current record is a texttype"
.SS "isPresentation \- return 0 or 1 depending on whether current record is a presentation"
.IX Subsection "isPresentation - return 0 or 1 depending on whether current record is a presentation"
.SS "isSpacing \- return 0 or 1 depending on whether current record is a spacing"
.IX Subsection "isSpacing - return 0 or 1 depending on whether current record is a spacing"
.SS "isString \- return 0 or 1 depending on whether current record is a string"
.IX Subsection "isString - return 0 or 1 depending on whether current record is a string"
.SS "isStrans \- return 0 or 1 depending on whether current record is a strans"
.IX Subsection "isStrans - return 0 or 1 depending on whether current record is a strans"
.SS "isMag \- return 0 or 1 depending on whether current record is a mag"
.IX Subsection "isMag - return 0 or 1 depending on whether current record is a mag"
.SS "isAngle \- return 0 or 1 depending on whether current record is a angle"
.IX Subsection "isAngle - return 0 or 1 depending on whether current record is a angle"
.SS "isUinteger \- return 0 or 1 depending on whether current record is a uinteger"
.IX Subsection "isUinteger - return 0 or 1 depending on whether current record is a uinteger"
.SS "isUstring \- return 0 or 1 depending on whether current record is a ustring"
.IX Subsection "isUstring - return 0 or 1 depending on whether current record is a ustring"
.SS "isReflibs \- return 0 or 1 depending on whether current record is a reflibs"
.IX Subsection "isReflibs - return 0 or 1 depending on whether current record is a reflibs"
.SS "isFonts \- return 0 or 1 depending on whether current record is a fonts"
.IX Subsection "isFonts - return 0 or 1 depending on whether current record is a fonts"
.SS "isPathtype \- return 0 or 1 depending on whether current record is a pathtype"
.IX Subsection "isPathtype - return 0 or 1 depending on whether current record is a pathtype"
.SS "isGenerations \- return 0 or 1 depending on whether current record is a generations"
.IX Subsection "isGenerations - return 0 or 1 depending on whether current record is a generations"
.SS "isAttrtable \- return 0 or 1 depending on whether current record is a attrtable"
.IX Subsection "isAttrtable - return 0 or 1 depending on whether current record is a attrtable"
.SS "isStyptable \- return 0 or 1 depending on whether current record is a styptable"
.IX Subsection "isStyptable - return 0 or 1 depending on whether current record is a styptable"
.SS "isStrtype \- return 0 or 1 depending on whether current record is a strtype"
.IX Subsection "isStrtype - return 0 or 1 depending on whether current record is a strtype"
.SS "isEflags \- return 0 or 1 depending on whether current record is a eflags"
.IX Subsection "isEflags - return 0 or 1 depending on whether current record is a eflags"
.SS "isElkey \- return 0 or 1 depending on whether current record is a elkey"
.IX Subsection "isElkey - return 0 or 1 depending on whether current record is a elkey"
.SS "isLinktype \- return 0 or 1 depending on whether current record is a linktype"
.IX Subsection "isLinktype - return 0 or 1 depending on whether current record is a linktype"
.SS "isLinkkeys \- return 0 or 1 depending on whether current record is a linkkeys"
.IX Subsection "isLinkkeys - return 0 or 1 depending on whether current record is a linkkeys"
.SS "isNodetype \- return 0 or 1 depending on whether current record is a nodetype"
.IX Subsection "isNodetype - return 0 or 1 depending on whether current record is a nodetype"
.SS "isPropattr \- return 0 or 1 depending on whether current record is a propattr"
.IX Subsection "isPropattr - return 0 or 1 depending on whether current record is a propattr"
.SS "isPropvalue \- return 0 or 1 depending on whether current record is a propvalue"
.IX Subsection "isPropvalue - return 0 or 1 depending on whether current record is a propvalue"
.SS "isBox \- return 0 or 1 depending on whether current record is a box"
.IX Subsection "isBox - return 0 or 1 depending on whether current record is a box"
.SS "isBoxtype \- return 0 or 1 depending on whether current record is a boxtype"
.IX Subsection "isBoxtype - return 0 or 1 depending on whether current record is a boxtype"
.SS "isPlex \- return 0 or 1 depending on whether current record is a plex"
.IX Subsection "isPlex - return 0 or 1 depending on whether current record is a plex"
.SS "isBgnextn \- return 0 or 1 depending on whether current record is a bgnextn"
.IX Subsection "isBgnextn - return 0 or 1 depending on whether current record is a bgnextn"
.SS "isEndextn \- return 0 or 1 depending on whether current record is a endextn"
.IX Subsection "isEndextn - return 0 or 1 depending on whether current record is a endextn"
.SS "isTapenum \- return 0 or 1 depending on whether current record is a tapenum"
.IX Subsection "isTapenum - return 0 or 1 depending on whether current record is a tapenum"
.SS "isTapecode \- return 0 or 1 depending on whether current record is a tapecode"
.IX Subsection "isTapecode - return 0 or 1 depending on whether current record is a tapecode"
.SS "isStrclass \- return 0 or 1 depending on whether current record is a strclass"
.IX Subsection "isStrclass - return 0 or 1 depending on whether current record is a strclass"
.SS "isReserved \- return 0 or 1 depending on whether current record is a reserved"
.IX Subsection "isReserved - return 0 or 1 depending on whether current record is a reserved"
.SS "isFormat \- return 0 or 1 depending on whether current record is a format"
.IX Subsection "isFormat - return 0 or 1 depending on whether current record is a format"
.SS "isMask \- return 0 or 1 depending on whether current record is a mask"
.IX Subsection "isMask - return 0 or 1 depending on whether current record is a mask"
.SS "isEndmasks \- return 0 or 1 depending on whether current record is a endmasks"
.IX Subsection "isEndmasks - return 0 or 1 depending on whether current record is a endmasks"
.SS "isLibdirsize \- return 0 or 1 depending on whether current record is a libdirsize"
.IX Subsection "isLibdirsize - return 0 or 1 depending on whether current record is a libdirsize"
.SS "isLibsecur \- return 0 or 1 depending on whether current record is a libsecur"
.IX Subsection "isLibsecur - return 0 or 1 depending on whether current record is a libsecur"
.SS "recordSize \- return current record size"
.IX Subsection "recordSize - return current record size"
.Vb 2
\&  usage:
\&    my $len = $gds2File \-> recordSize;
.Ve
.SS "dataSize \- return current record size \- 4 (length of data)"
.IX Subsection "dataSize - return current record size - 4 (length of data)"
.Vb 2
\&  usage:
\&    my $dataLen = $gds2File \-> dataSize;
.Ve
.SS "returnUnitsAsArray \- return user units and database units as a 2 element array"
.IX Subsection "returnUnitsAsArray - return user units and database units as a 2 element array"
.Vb 2
\&  usage:
\&    my ($uu,$dbu) = $gds2File \-> returnUnitsAsArray;
.Ve
.SS "version \- return \s-1GDS2\s0 module version string"
.IX Subsection "version - return GDS2 module version string"
.SS "version \- return \s-1GDS2\s0 module revision string"
.IX Subsection "version - return GDS2 module revision string"
.SH "GDS2 Stream Format"
.IX Header "GDS2 Stream Format"
.Vb 10
\& #########################################################################################
\& #
\& # Gds2 stream format is composed of variable length records. The mininum
\& # length record is 4 bytes. The 1st 2 bytes of a record contain a count (in 8 bit
\& # bytes) of the total record length.  The 3rd byte of the header is the record
\& # type. The 4th byte describes the type of data contained w/in the record. The
\& # 5th through last bytes are data.
\& #
\& # If the output file is a mag tape, then the records of the library are written
\& # out in 2048\-byte physical blocks. Records may overlap block boundaries.
\& # For this reason I think gds2 is often padded with null bytes so that the
\& # file size ends up being a multiple of 2048.
\& #
\& # A null word consists of 2 consecutive zero bytes. Use null words to fill the
\& # space between:
\& #     o the last record of a library and the end of its block
\& #     o the last record of a tape in a mult\-reel stream file.
\& #
\& # DATA TYPE        VALUE  RECORD
\& # \-\-\-\-\-\-\-\-\-        \-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& # no data present     0   4 byte header + 0
\& #
\& # Bit Array           1   4 byte header + 2 bytes data
\& #
\& # 2byte Signed Int    2  SMMMMMMM MMMMMMMM  \-> S \- sign ;  M \- magnitude.
\& #                        Twos complement format, with the most significant byte first.
\& #                        I.E.
\& #                        0x0001 = 1
\& #                        0x0002 = 2
\& #                        0x0089 = 137
\& #                        0xffff = \-1
\& #                        0xfffe = \-2
\& #                        0xff77 = \-137
\& #
\& # 4byte Signed Int    3  SMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM
\& #
\& # 8byte Real          5  SEEEEEEE MMMMMMMM MMMMMMMM MMMMMMMM E\-expon in excess\-64
\& #                        MMMMMMMM MMMMMMMM MMMMMMMM MMMMMMMM representation
\& #
\& #                        Mantissa == pos fraction >=1/16 && <1 bit 8==1/2, 9==1/4 etc...
\& #                        The first bit is the sign (1 = negative), the next 7 bits
\& #                        are the exponent, you have to subtract 64 from this number to
\& #                        get the real value. The next seven bytes are the mantissa in
\& #                        4 word floating point representation.
\& #
\& #
\& # string              6  odd length strings must be padded w/ null character and
\& #                        byte count++
\& #
\& #########################################################################################
.Ve
.SH "Backus-naur representation of GDS2 Stream Syntax"
.IX Header "Backus-naur representation of GDS2 Stream Syntax"
.Vb 10
\& ################################################################################
\& #  <STREAM FORMAT>::= HEADER BGNLIB [LIBDIRSIZE] [SRFNAME] [LIBSECR]           #
\& #                     LIBNAME [REFLIBS] [FONTS] [ATTRTABLE] [GENERATIONS]      #
\& #                     [<FormatType>] UNITS {<structure>}* ENDLIB               #
\& #                                                                              #
\& #  <FormatType>::=    FORMAT | FORMAT {MASK}+ ENDMASKS                         #
\& #                                                                              #
\& #  <structure>::=     BGNSTR STRNAME [STRCLASS] {<element>}* ENDSTR            #
\& #                                                                              #
\& #  <element>::=       {<boundary> | <path> | <SREF> | <AREF> | <text> |        #
\& #                      <node> | <box} {<property>}* ENDEL                      #
\& #                                                                              #
\& #  <boundary>::=      BOUNDARY [ELFLAGS] [PLEX] LAYER DATATYPE XY              #
\& #                                                                              #
\& #  <path>::=          PATH [ELFLAGS] [PLEX] LAYER DATATYPE [PATHTYPE]          #
\& #                     [WIDTH] [BGNEXTN] [ENDEXTN] [XY]                         #
\& #                                                                              #
\& #  <SREF>::=          SREF [ELFLAGS] [PLEX] SNAME [<strans>] XY                #
\& #                                                                              #
\& #  <AREF>::=          AREF [ELFLAGS] [PLEX] SNAME [<strans>] COLROW XY         #
\& #                                                                              #
\& #  <text>::=          TEXT [ELFLAGS] [PLEX] LAYER <textbody>                   #
\& #                                                                              #
\& #  <textbody>::=      TEXTTYPE [PRESENTATION] [PATHTYPE] [WIDTH] [<strans>] XY #
\& #                     STRING                                                   #
\& #                                                                              #
\& #  <strans>::=        STRANS [MAG] [ANGLE]                                     #
\& #                                                                              #
\& #  <node>::=          NODE [ELFLAGS] [PLEX] LAYER NODETYPE XY                  #
\& #                                                                              #
\& #  <box>::=           BOX [ELFLAGS] [PLEX] LAYER BOXTYPE XY                    #
\& #                                                                              #
\& #  <property>::=      PROPATTR PROPVALUE                                       #
\& ################################################################################
.Ve
.SH "GDS2 Stream Record Datatypes"
.IX Header "GDS2 Stream Record Datatypes"
.Vb 9
\& ################################################################################
\& NO_REC_DATA   =  0;
\& BIT_ARRAY     =  1;
\& INTEGER_2     =  2;
\& INTEGER_4     =  3;
\& REAL_4        =  4; ## NOT supported, never really used
\& REAL_8        =  5;
\& ACSII_STRING  =  6;
\& ################################################################################
.Ve
.SH "GDS2 Stream Record Types"
.IX Header "GDS2 Stream Record Types"
.Vb 10
\& ################################################################################
\& HEADER        =  0;   ## 2\-byte Signed Integer
\& BGNLIB        =  1;   ## 2\-byte Signed Integer
\& LIBNAME       =  2;   ## ASCII String
\& UNITS         =  3;   ## 8\-byte Real
\& ENDLIB        =  4;   ## no data present
\& BGNSTR        =  5;   ## 2\-byte Signed Integer
\& STRNAME       =  6;   ## ASCII String
\& ENDSTR        =  7;   ## no data present
\& BOUNDARY      =  8;   ## no data present
\& PATH          =  9;   ## no data present
\& SREF          = 10;   ## no data present
\& AREF          = 11;   ## no data present
\& TEXT          = 12;   ## no data present
\& LAYER         = 13;   ## 2\-byte Signed Integer
\& DATATYPE      = 14;   ## 2\-byte Signed Integer
\& WIDTH         = 15;   ## 4\-byte Signed Integer
\& XY            = 16;   ## 4\-byte Signed Integer
\& ENDEL         = 17;   ## no data present
\& SNAME         = 18;   ## ASCII String
\& COLROW        = 19;   ## 2 2\-byte Signed Integer <= 32767
\& TEXTNODE      = 20;   ## no data present
\& NODE          = 21;   ## no data present
\& TEXTTYPE      = 22;   ## 2\-byte Signed Integer
\& PRESENTATION  = 23;   ## Bit Array. One word (2 bytes) of bit flags. Bits 11 and
\&                       ##   12 together specify the font 00\->font 0 11\->font 3.
\&                       ##   Bits 13 and 14 specify the vertical presentation, 15
\&                       ##   and 16 the horizontal presentation. 00\->\*(Aqtop/left\*(Aq 01\->
\&                       ##   middle/center 10\->bottom/right bits 1\-10 were reserved
\&                       ##   for future use and should be 0.
\& SPACING       = 24;   ## discontinued
\& STRING        = 25;   ## ASCII String <= 512 characters
\& STRANS        = 26;   ## Bit Array: 2 bytes of bit flags for graphic presentation
\&                       ##   The 1st (high order or leftmost) bit specifies
\&                       ##   reflection. If set then reflection across the X\-axis
\&                       ##   is applied before rotation. The 14th bit flags
\&                       ##   absolute mag, the 15th absolute angle, the other bits
\&                       ##   were reserved for future use and should be 0.
\& MAG           = 27;   ## 8\-byte Real
\& ANGLE         = 28;   ## 8\-byte Real
\& UINTEGER      = 29;   ## UNKNOWN User int, used only in Calma V2.0
\& USTRING       = 30;   ## UNKNOWN User string, used only in Calma V2.0
\& REFLIBS       = 31;   ## ASCII String
\& FONTS         = 32;   ## ASCII String
\& PATHTYPE      = 33;   ## 2\-byte Signed Integer
\& GENERATIONS   = 34;   ## 2\-byte Signed Integer
\& ATTRTABLE     = 35;   ## ASCII String
\& STYPTABLE     = 36;   ## ASCII String "Unreleased feature"
\& STRTYPE       = 37;   ## 2\-byte Signed Integer "Unreleased feature"
\& EFLAGS        = 38;   ## BIT_ARRAY  Flags for template and exterior data.
\&                       ## bits 15 to 0, l to r 0=template, 1=external data, others unused
\& ELKEY         = 39;   ## INTEGER_4  "Unreleased feature"
\& LINKTYPE      = 40;   ## UNKNOWN    "Unreleased feature"
\& LINKKEYS      = 41;   ## UNKNOWN    "Unreleased feature"
\& NODETYPE      = 42;   ## INTEGER_2  Nodetype specification. On Calma this could be 0 to 63,
\&                       ##   GDSII allows 0 to 255. Of course a 16 bit integer allows up to 65535...
\& PROPATTR      = 43;   ## INTEGER_2  Property number.
\& PROPVALUE     = 44;   ## STRING     Property value. On GDSII, 128 characters max, unless an
\&                       ##   SREF, AREF, or NODE, which may have 512 characters.
\& BOX           = 45;   ## NO_DATA    The beginning of a BOX element.
\& BOXTYPE       = 46;   ## INTEGER_2  Boxtype specification.
\& PLEX          = 47;   ## INTEGER_4  Plex number and plexhead flag. The least significant bit of
\&                       ##   the most significant byte is the plexhead flag.
\& BGNEXTN       = 48;   ## INTEGER_4  Path extension beginning for pathtype 4 in Calma CustomPlus.
\&                       ##   In database units, may be negative.
\& ENDEXTN       = 49;   ## INTEGER_4  Path extension end for pathtype 4 in Calma CustomPlus. In
\&                       ##   database units, may be negative.
\& TAPENUM       = 50;   ## INTEGER_2  Tape number for multi\-reel stream file.
\& TAPECODE      = 51;   ## INTEGER_2  Tape code to verify that the reel is from the proper set.
\&                       ##   12 bytes that are supposed to form a unique tape code.
\& STRCLASS      = 52;   ## BIT_ARRAY  Calma use only.
\& RESERVED      = 53;   ## INTEGER_4  Used to be NUMTYPES per Calma GDSII Stream Format Manual, v6.0.
\& FORMAT        = 54;   ## INTEGER_2  Archive or Filtered flag.  0: Archive 1: filtered
\& MASK          = 55;   ## STRING     Only in filtered streams. Layers and datatypes used for mask
\&                       ##   in a filtered stream file. A string giving ranges of layers and datatypes
\&                       ##   separated by a semicolon. There may be more than one mask in a stream file.
\& ENDMASKS      = 56;   ## NO_DATA    The end of mask descriptions.
\& LIBDIRSIZE    = 57;   ## INTEGER_2  Number of pages in library director, a GDSII thing, it seems
\&                       ##   to have only been used when Calma INFORM was creating a new library.
\& SRFNAME       = 58;   ## STRING     Calma "Sticks"(c) rule file name.
\& LIBSECUR      = 59;   ## INTEGER_2  Access control list stuff for CalmaDOS, ancient. INFORM used
\&                       ##   this when creating a new library. Had 1 to 32 entries with group
\&                       ##   numbers, user numbers and access rights.
.Ve
