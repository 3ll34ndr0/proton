sub InitColors{
  my($im) = $_[0];
  # Allocate colors
  $white = $im->colorAllocate(255,255,255);
  $black = $im->colorAllocate(0,0,0);
  $red = $im->colorAllocate(255,0,0);
  $blue = $im->colorAllocate(0,0,255);
  $green = $im->colorAllocate(0, 255, 0);

  $brown = $im->colorAllocate(255, 0x99, 0); 
  $violet = $im->colorAllocate(255, 0, 255); 
  $yellow = $im->colorAllocate(255, 255, 0); 

  $darkgray = $im->colorAllocate(169, 169, 169); 
  $OliveDrab1 = $im->colorAllocate(192, 255, 62); 
  $orange = $im->colorAllocate(255, 165, 0); 

}#sub InitColors

###########################################################################################
########################  subroutine to create flatView image #############################
###########################################################################################
#sub create_flat_image_old{
#  use Benchmark;
#  my $t0 = new Benchmark;
#  my $noOfArg = @_;
#  my @bbox = ();
#  my @errBBox = ();
#  my ($outFile, $format) = ("flat_view", "png");
#  
#  if($_[0] eq "-h" || $_[0] eq "-help" || $_[0] eq "-HELP"){
#     print"Usage: create_flat_image -output <output filename>\n";
#     print"                         -width <image width>\n";
#     print"                         -height <image height>\n";
#     print"                         -margin <margin from chip boundary in micron>\n";
#     print"                         -bbox <{x1,y1,x2,y2} in dbu>\n";
#     print"                         --die <boundary display>\n";
#     print"                         --inst <instance display>\n";
#     print"                         --row <rows display>\n";
#     print"                         --port <ports display>\n";
#     print"                         --net <nets display>\n";
#     print"                         --spnet <special nets display>\n";
#     print"                         -format <file format (png/jpeg/gif/gd/gd2>\n";
#     print" default value <output:flat_view.png>\n";
#     print" default value <width:540>\n";
#     print" default value <height:540>\n";
#     print" default value <format:png>\n";
#     return @errBBox;
#  }else{
#     my $dbu = $GLOBAL->dbfGlobalGetDBU;
#     my ($image_width, $image_height) = (500,500);
#     my ($boundary_display,$inst_display,$row_display,$port_display,$net_display,$spnet_display) = (0,0,0,0,0,0);
#     my ($margin, $marginX, $marginY) = (2, 0, 0);
#     for(my $xx=0; $xx<$noOfArg; $xx++){
#         if($_[$xx] eq "-output"){$outFile = $_[$xx+1];}
#         if($_[$xx] eq "-width"){$image_width = $_[$xx+1];}
#         if($_[$xx] eq "-height"){$image_height = $_[$xx+1];}
#         if($_[$xx] eq "-margin"){$margin = $_[$xx+1];}
#         if($_[$xx] eq "-format"){$format = $_[$xx+1];}
#         if($_[$xx] eq "-bbox"){
#            my $bbox_str = $_[$xx+1];
#            $bbox_str =~ s/\{//;         
#            $bbox_str =~ s/\}//;        
#            @bbox = split(/\,/,$bbox_str);
#         }
#         if($_[$xx] eq "--die"){$boundary_display = 1;}
#         if($_[$xx] eq "--inst"){$inst_display = 1;}
#         if($_[$xx] eq "--row"){$row_display = 1;}
#         if($_[$xx] eq "--port"){$port_display = 1;}
#         if($_[$xx] eq "--net"){$net_display = 1;}
#         if($_[$xx] eq "--spnet"){$spnet_display = 1;}
#     }
#     #print "arg @_\n";
#     $outFile = $outFile.".".$format; 
#     # Create a new image
#     my $im = new GD::Image($image_width,$image_height,[0,0,0]);
#     my $po = new Graphics::ColorNames('X');
#     # Allocate some colors
#     &InitColors($im);
#     # Make the background transparent and interlaced
#     #$im->transparent($red);
#     #$im->interlaced('true');
#     
#     &create_gcell_db;
#     if($#GCellArray < 0){
#     print"WARN: first you should run command \"create_gcell\"\n";
#     print"use -h/-help/-HELP option to get help for \"create_gcell\"\n";
#     return @errBBox;
#     }
#     
#     my ($bllx,$blly,$burx,$bury);
#     my ($guiWidth, $guiHeight);
#     my $MICRONFACTOR = 1;
#     my $dieIsCentre = 0;
#     
#     if(exists $DIE_ALREADY{dieArea} ) {
#        my $guiDiellx = $DIE_ALREADY{dieArea}[0];
#        my $guiDielly = $DIE_ALREADY{dieArea}[1];
#        my $guiDieurx = $DIE_ALREADY{dieArea}[2];
#        my $guiDieury = $DIE_ALREADY{dieArea}[3];
#  
#        my $guiMuDiellx = $guiDiellx/$dbu;
#        my $guiMuDielly = $guiDielly/$dbu;
#        my $guiMuDieurx = $guiDieurx/$dbu;
#        my $guiMuDieury = $guiDieury/$dbu;
#        
#        if($guiDiellx == 0 && $guiDielly == 0 ){
#           $dieIsCentre = 0; 
#        }elsif($guiDiellx+$guiDieurx == 0 && $guiDieury+$guiDielly == 0){
#           $dieIsCentre = 1;
#        }else {
#           $dieIsCentre = 2;
#        }
#        
#        ################## if -bbox option is used ##############
#        #-------- we should scale the design with bbox ---------#
#        if((@bbox < 4) || ($bbox[0] == 0 && $bbox[1] == 0 && $bbox[2] == 0 && $bbox[3] == 0)){
#           @bbox = ($guiDiellx,$guiDielly,$guiDieurx,$guiDieury);
#           $guiWidth = abs($guiMuDieurx - $guiMuDiellx) + 2*$margin;
#           $guiHeight = abs($guiMuDieury - $guiMuDielly) + 2*$margin;
#        }else{
#           #@bbox = &getBboxPixel2DB(@bbox,$image_width,$image_height);
#           $guiWidth = abs(($bbox[2] - $bbox[0])/$dbu); #we have added margin with bbox in
#           $guiHeight = abs(($bbox[3] - $bbox[1])/$dbu);#create_gcells_flat_image subroutine
#        }
#  
#        my $shiftX = $bbox[0] + $margin*$dbu;
#        my $shiftY = $bbox[1] + $margin*$dbu;
#        my $dieHMultFact  = $image_height/$guiHeight;
#        my $dieWMultFact  = $image_width/$guiWidth;
#        #-------------------------------------------------------#
#  
#        if($dieHMultFact < $dieWMultFact){
#           $MICRONFACTOR = $dieHMultFact;
#        }else{
#           $MICRONFACTOR =  $dieWMultFact; 
#        }
#        my $MulFactor = $MICRONFACTOR/$dbu;
#
#        ############### Calculating X margin & Y margin to display image in centre ##############
#        #if($bbox[0] < $guiDiellx){
#           $marginX = ( $image_width - ($guiWidth - 2*$margin)*$MICRONFACTOR )/2;
#        #}
#        #if($bbox[1] < $guiDielly){
#           $marginY = ($image_height - ($guiHeight - 2*$margin)*$MICRONFACTOR)/2;
#        #}
#        #$marginX = ( $image_width - ($guiMuDieurx - $guiMuDiellx)*$MICRONFACTOR )/2;
#        #$marginY = ( $image_height - ($guiMuDieury - $guiMuDielly)*$MICRONFACTOR )/2;
#  
#        #####   display the die area boundary  ###
#        if($dieIsCentre == 0 || $dieIsCentre == 2 ) {
#           $blly = ($image_height - $marginY) - ($guiMuDielly - $shiftY/$dbu)*$MICRONFACTOR;
#           $bury = ($image_height - $marginY) - ($guiMuDieury - $shiftY/$dbu)*$MICRONFACTOR;
#           $bllx = ($guiMuDiellx - $shiftX/$dbu)*$MICRONFACTOR + $marginX;
#           $burx = ($guiMuDieurx - $shiftX/$dbu)*$MICRONFACTOR + $marginX;
#        }else {
#           $blly = ($image_height/2) - ($guiMuDielly - $shiftY/$dbu)*$MICRONFACTOR;
#           $bury = ($image_height/2) - ($guiMuDieury - $shiftY/$dbu)*$MICRONFACTOR;
#           $bllx = ($guiMuDiellx - $shiftX/$dbu)*$MICRONFACTOR + ($image_width/2);
#           $burx = ($guiMuDieurx - $shiftX/$dbu)*$MICRONFACTOR + ($image_width/2);
#        }
#        if($boundary_display == 1 && ((($bllx >= 0 && $bllx <= $image_width) || ($burx >= 0 && $burx <= $image_width)) || (($blly >= 0 && $blly <= $image_height) || ($bury >= 0 && $bury <= $image_height)))){
#           $im->rectangle($bllx,$blly,$burx,$bury, $green);
#        }
#
#        ######   display the ROWS   #####
#        if($row_display == 1){
#           if (exists $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}){
#               my @rows = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}->dbFlplanGetRows;
#               foreach my $tag ( @rows ) {
#                       my ($x,$y) = (split(/\s+/, $tag))[2,3];
#                       my $Row_llx = ($x-$shiftX)*$MulFactor;    
#                       my $Row_lly = ($y-$shiftY)*$MulFactor;    
#                       if($dieIsCentre == 1) {
#                          $Row_llx = $Row_llx + ($image_width/2);
#                          $Row_lly = ($image_height/2) - $Row_lly;
#                       }else {
#                          $Row_llx = $Row_llx + $marginX;
#                          $Row_lly = ($image_height - $marginY) - $Row_lly;
#                       }
#                       if($Row_lly >= 0 && $bury <= $image_height){
#                          #$im->line($Row_llx,$Row_lly,$burx,$Row_lly,$darkgray) if($blly != 20 );
#                          $im->line($Row_llx,$Row_lly,$burx,$Row_lly,$darkgray);
#                       }
#               }# foreach
#           }
#        }#if row display is ON
#        #####   display the ports of the top module  ###
#        if($port_display == 1){
#           my $moduleName = $TOP_MODULE;
#           foreach my $port ( keys %{$PORTS_ALREADY{$moduleName}} ) {
#                   my $status = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetStatus;
#                   if($status == 2 || $status == 3 ) {
#                      my @loc = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetLoc;
#                      my ($X,$Y,$orient) = &dbPlaceFindClosestBoundary($loc[0],$loc[1]);
#                      $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortSetSide($orient);
#                      my $dir = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetDir;
#                      my $orient = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetSide;
#                      my $x = ($loc[0]-$shiftX)*$MulFactor;
#                      my $y = ($loc[1]-$shiftY)*$MulFactor;
#                      if($dieIsCentre == 1) {
#                         $x = $x + ($image_width/2);
#                         $y = ($image_height/2) - $y;
#                      }else {
#                         $x = $x + $marginX;
#                         $y = ($image_height - $marginY) - $y;
#                      }
#                      if(($x >= 0 || $x <= $image_width) && ($y >= 0 || $y <= $image_height)){
#                         my @poly = &create_pin_shape($x,$y,$orient,$dir);
#                         my $polygon = new GD::Polygon;
#                         $polygon->addPt($poly[0], $poly[1]);
#                         $polygon->addPt($poly[2], $poly[3]);
#                         $polygon->addPt($poly[4], $poly[5]);
#                         $im->polygon($polygon, $yellow);
#                      }
#                   }#if status is placed or fixed
#           }# foreach
#        }#if port display is ON
#        ########  dispay the Instances  #######
#        if($inst_display == 1){
#           for(my $i=0; $i<=$#GCellArray ; $i++) {
#              for (my $j=0; $j<=$#{@GCellArray[0]} ; $j++) {
#                   my @instList = $GCellArray[$i][$j]->dbgGcellGetInst; 
#                   my @filtered_inst_array = ();
#                   foreach my $InstanceName (@instList){
#                        my @Inst_bbox = $CADB{$InstanceName}->dbCadbGetbBox;
#                        my $cellref =  $CADB{$InstanceName}->dbCadbGetCellref;
#                        my $status =  $CADB{$InstanceName}->dbCadbGetStatus;
#                        my $InstColor = "red";      
#                        if($PLDB{$cellref}->dbMdbGetClass eq "BLOCK") {
#                           $InstColor = "yellow";
#                        }
#                        if($status eq "PLACED" || $status eq "FIXED" ) {
#                           my $llx = ($Inst_bbox[0]-$shiftX)*$MulFactor;
#                           my $lly = ($Inst_bbox[1]-$shiftY)*$MulFactor;
#                           my $urx = ($Inst_bbox[2]-$shiftX)*$MulFactor;
#                           my $ury = ($Inst_bbox[3]-$shiftY)*$MulFactor;
#                           if($dieIsCentre == 1) {
#                              $lly = ($image_height/2) - $lly;
#                              $ury = ($image_height/2) - $ury;
#                              $llx = $llx + ($image_width/2);
#                              $urx = $urx + ($image_width/2);
#                           }else {
#                              $lly = ($image_height - $marginY) - $lly;
#                              $ury = ($image_height - $marginY) - $ury;
#                              $llx = $llx + $marginX;
#                              $urx = $urx + $marginX;
#                           }
#                           if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
#                              #my $instW = abs($urx-$llx);
#                              #my $instH = abs($ury-$lly);
#                              #my $path2proton = $GLOBAL->dbfGlobalGetProtonHome;
#                              #my $tile = newFromPng GD::Image("$path2proton/ETC/dotted_bitmap.png");
#                              #$im->setTile($tile);   
#                              #$im->filledRectangle($llx,$ury,$urx,$lly, gdTiled) if($instW > 3 || $instH > 3);
#                              #$im->filledRectangle($llx,$ury,$urx,$lly, $red) if($instW > 3 || $instH > 3);
#                              #$im->rectangle($llx,$ury,$urx,$lly, $red);
#                              $im->filledRectangle($llx,$ury,$urx,$lly, $red);
#                              $im->rectangle($llx,$ury,$urx,$lly, $black);
#                           }
#                        }# if component status is fixed or placed
#                   }#foreach Instance
#              }#for j
#           }#for i
#        }#if instance display ON
#        #print "image width $image_width height $image_height | shift $shiftX $shiftY\n";
#        #my $x1 = $marginX + ($bbox[0] - $shiftX )*$MulFactor;  
#        #my $y1 = ($image_height - $marginY) - ($bbox[1] - $shiftY )*$MulFactor;  
#        #my $x2 = $marginX + ($bbox[2] - $shiftX )*$MulFactor;  
#        #my $y2 = ($image_height - $marginY) - ($bbox[3] - $shiftY )*$MulFactor;  
#        #$im->string(gdSmallFont, $x1, $y1, "$bbox[0] | $bbox[1]", $white);
#        #$im->string(gdSmallFont, $x2, $y2, "$bbox[2] | $bbox[3]", $white);
#        #print "input bbox @bbox | $x1 $y1 $x2 $y2\n";
#        ################################### creating image of nets #####################################
#        if($net_display == 1){
#           foreach my $net ( keys %NETS_ALREADY ) {
#               if(exists $NETS_ROUTING_ALREADY{$net}) {
#                  my @data = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
#                  foreach my $segment ( @data ) {
#                       my @seg = split(/\s+/,$segment);
#                       my @routeBox = xformNetSegToRouteBox($segment);
#                       my $llx = ($routeBox[0]-$shiftX)*$MulFactor;
#                       my $lly = ($routeBox[1]-$shiftY)*$MulFactor;
#                       my $urx = ($routeBox[2]-$shiftX)*$MulFactor;
#                       my $ury = ($routeBox[3]-$shiftY)*$MulFactor;
#                       if($dieIsCentre == 1) {
#                          $lly = ($image_height/2) - $lly;
#                          $ury = ($image_height/2) - $ury;
#                          $llx = $llx + ($image_width/2);
#                          $urx = $urx + ($image_width/2);
#                       }else {
#                          $lly = ($image_height - $marginY) - $lly;
#                          $ury = ($image_height - $marginY) - $ury;
#                          $llx = $llx + $marginX;
#                          $urx = $urx + $marginX;
#                       }
#                       if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
#                          if(exists $PTDB{$seg[0]} ) {
#                             my $color = $PTDB{$seg[0]}->dbTechGetLayerColor;
#                             my $im_color = $im->colorAllocate($po->rgb($color));
#                             $im->rectangle($llx,$lly,$urx,$ury, $im_color);
#                             #$im->filledRectangle($llx,$lly,$urx,$ury,$im_color);
#                          }#if the metal layer exists in the technology
#                       }#if the metal layer exists in the technology
#                  }#foreach segment of routing
#               }# if routing data is present
#           }#for all nets in the database
#        }#if net display is ON
#        ################################ creating image of special nets ##################################
#        if($spnet_display == 1){
#           foreach my $net ( keys %NETS_ALREADY ) {
#               my $netType = $NADB{$net}->dbNadbGetNetType;
#               if (($netType == 1) || ($netType == 2)) {
#                   if (exists $NETS_ROUTING_ALREADY{$net}) { 
#                       my @data = ();
#                       push(@data, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetSpecialRoute);
#                       push(@data, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute);
#                       foreach my $segment ( @data ) {
#                         my @seg = split(/\s+/,$segment);
#                         my @routeBox = xformNetSegToSpecialRouteBox($segment);
#                         my $llx = ($routeBox[0]-$shiftX)*$MulFactor;
#                         my $lly = ($routeBox[1]-$shiftY)*$MulFactor;
#                         my $urx = ($routeBox[2]-$shiftX)*$MulFactor;
#                         my $ury = ($routeBox[3]-$shiftY)*$MulFactor;
#                         if($dieIsCentre == 1) {
#                            $lly = ($image_height/2) - $lly;
#                            $ury = ($image_height/2) - $ury;
#                            $llx = $llx + ($image_width/2);
#                            $urx = $urx + ($image_width/2);
#                         }else {
#                            $lly = ($image_height - $marginY) - $lly;
#                            $ury = ($image_height - $marginY) - $ury;
#                            $llx = $llx + $marginX;
#                            $urx = $urx + $marginX;
#                         }
#                         if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
#                            if (exists $PTDB{$seg[0]} ) {
#                               my $color = $PTDB{$seg[0]}->dbTechGetLayerColor;
#                               my $im_color = $im->colorAllocate($po->rgb($color));
#                               $im->rectangle($llx,$lly,$urx,$ury,$im_color);
#                               #$im->filledRectangle($llx,$lly,$urx,$ury,$im_color);
#                            }
#                         }
#                       }
#                   }#if exists
#               }#if type is 1 or 2
#           }#foreach special net
#        }#if special net display is ON
#        #------------------------------------------------------------------------------------#
#        ##################### context bbox #########################
#        $bbox[0] = $bbox[0] - $marginX/$MulFactor;
#        $bbox[1] = $bbox[1] - $marginY/$MulFactor;
#        $bbox[2] = $bbox[0] + $image_width/$MulFactor;
#        $bbox[3] = $bbox[1] + $image_height/$MulFactor;
#        ############################################################
#     }#if dieArea exists
#     # Open a file for writing 
#     open(PICTURE, ">$outFile") or $! and print"permission denied to write $outFile\n" and return @errBBox;
#     
#     # Make sure we are writing to a binary stream
#     binmode PICTURE;
#     
#     # Convert the image to PNG and print it to the file PICTURE
#     print PICTURE $im->png if($format eq "png");
#     print PICTURE $im->jpeg if($format eq "jpeg");
#     print PICTURE $im->gif() if($format eq "gif");
#     print PICTURE $im->gd if($format eq "gd");
#     print PICTURE $im->gd2 if($format eq "gd2");
#     close PICTURE;
#  }
#  
#  #$GLOBAL->dbGlobalSetFlatImageBBox(@bbox);
#  
#  $t1 = new Benchmark;
#  my $td = timediff($t1, $t0);
#  print "flat image ($outFile) creation took:",timestr($td),"\n";
#  return(@bbox);
#}#sub create_flat_image_old

sub create_flat_image{
  use Benchmark;
  my $t0 = new Benchmark;
  my $noOfArg = @_;
  my @bbox = ();
  my @errBBox = ();
  my ($outFile, $format) = ("flat_view", "png");
  
  if($_[0] eq "-h" || $_[0] eq "-help" || $_[0] eq "-HELP"){
     print"Usage: create_flat_image -output <output filename>\n";
     print"                         -width <image width>\n";
     print"                         -height <image height>\n";
     print"                         -margin <margin from chip boundary in micron>\n";
     print"                         -bbox <{x1,y1,x2,y2} in dbu>\n";
     print"                         --die <boundary display>\n";
     print"                         --inst <instance display>\n";
     print"                         --row <rows display>\n";
     print"                         --port <ports display>\n";
     print"                         --net <nets display>\n";
     print"                         --spnet <special nets display>\n";
     print"                         -format <file format (png/jpeg/gif/gd/gd2>\n";
     print" default value <output:flat_view.png>\n";
     print" default value <width:540>\n";
     print" default value <height:540>\n";
     print" default value <format:png>\n";
     return @errBBox;
  }else{
     my $dbu = $GLOBAL->dbfGlobalGetDBU;
     my ($image_width, $image_height) = (500,500);
     my ($boundary_display,$inst_display,$row_display,$port_display,$net_display,$spnet_display) = (0,0,0,0,0,0);
     my ($marginX, $marginY) = (0, 0);
     for(my $xx=0; $xx<$noOfArg; $xx++){
         if($_[$xx] eq "-output"){$outFile = $_[$xx+1];}
         if($_[$xx] eq "-width"){$image_width = $_[$xx+1];}
         if($_[$xx] eq "-height"){$image_height = $_[$xx+1];}
         if($_[$xx] eq "-format"){$format = $_[$xx+1];}
         if($_[$xx] eq "-bbox"){
            my $bbox_str = $_[$xx+1];
            $bbox_str =~ s/\{//;         
            $bbox_str =~ s/\}//;        
            @bbox = split(/\,/,$bbox_str);
         }
         if($_[$xx] eq "--die"){$boundary_display = 1;}
         if($_[$xx] eq "--inst"){$inst_display = 1;}
         if($_[$xx] eq "--row"){$row_display = 1;}
         if($_[$xx] eq "--port"){$port_display = 1;}
         if($_[$xx] eq "--net"){$net_display = 1;}
         if($_[$xx] eq "--spnet"){$spnet_display = 1;}
     }
     #print "arg @_\n";
     $outFile = $outFile.".".$format; 
     # Create a new image
     my $im = new GD::Image($image_width,$image_height,[0,0,0]);
     my $po = new Graphics::ColorNames('X');
     # Allocate some colors
     &InitColors($im);
     # Make the background transparent and interlaced
     #$im->transparent($red);
     #$im->interlaced('true');
     
     &create_gcell_db;
     if($#GCellArray < 0){
     print"WARN: first you should run command \"create_gcell\"\n";
     print"use -h/-help/-HELP option to get help for \"create_gcell\"\n";
     return @errBBox;
     }
     
     my ($bllx,$blly,$burx,$bury);
     my ($guiWidth, $guiHeight);
     my $MICRONFACTOR = 1;
     my $dieIsCentre = 0;
     
     if(exists $DIE_ALREADY{dieArea} ) {
        my $guiDiellx = $DIE_ALREADY{dieArea}[0];
        my $guiDielly = $DIE_ALREADY{dieArea}[1];
        my $guiDieurx = $DIE_ALREADY{dieArea}[2];
        my $guiDieury = $DIE_ALREADY{dieArea}[3];
  
        my $guiMuDiellx = $guiDiellx/$dbu;
        my $guiMuDielly = $guiDielly/$dbu;
        my $guiMuDieurx = $guiDieurx/$dbu;
        my $guiMuDieury = $guiDieury/$dbu;
        
        if($guiDiellx == 0 && $guiDielly == 0 ){
           $dieIsCentre = 0; 
        }elsif($guiDiellx+$guiDieurx == 0 && $guiDieury+$guiDielly == 0){
           $dieIsCentre = 1;
        }else {
           $dieIsCentre = 2;
        }
        
        ################## if -bbox option is used ##############
        #-------- we should scale the design with bbox ---------#
        if((@bbox < 4) || ($bbox[0] == 0 && $bbox[1] == 0 && $bbox[2] == 0 && $bbox[3] == 0)){
           @bbox = ($guiDiellx,$guiDielly,$guiDieurx,$guiDieury);
        }
        $guiWidth = abs(($bbox[2] - $bbox[0])/$dbu) ; 
        $guiHeight = abs(($bbox[3] - $bbox[1])/$dbu); 
        #print "bbox:@bbox\n";
        #print "dieWidth:$guiWidth dieHeight:$guiHeight\n";
  
        my $shiftX = $bbox[0];
        my $shiftY = $bbox[1];
        #print "shiftX:$shiftX shiftY:$shiftY\n";

        my $dieHMultFact  = $image_height/$guiHeight;
        my $dieWMultFact  = $image_width/$guiWidth;
        #-------------------------------------------------------#
        if($dieHMultFact < $dieWMultFact){
           $MICRONFACTOR = $dieHMultFact;
        }else{
           $MICRONFACTOR =  $dieWMultFact; 
        }
        my $MulFactor = $MICRONFACTOR/$dbu;
        #print "mulFact:$MulFactor\n";

        ############### Calculating X margin & Y margin to display image in centre ##############
        $marginX = ( $image_width - $guiWidth*$MICRONFACTOR )/2;
        $marginY = ( $image_height - $guiHeight*$MICRONFACTOR )/2;
        #print "marginX:$marginX marginY:$marginY\n";
  
        #####   display the die area boundary  ###
        if($dieIsCentre == 0 || $dieIsCentre == 2 ) {
           $blly = ($image_height - $marginY) - ($guiMuDielly - $shiftY/$dbu)*$MICRONFACTOR;
           $bury = ($image_height - $marginY) - ($guiMuDieury - $shiftY/$dbu)*$MICRONFACTOR;
           $bllx = ($guiMuDiellx - $shiftX/$dbu)*$MICRONFACTOR + $marginX;
           $burx = ($guiMuDieurx - $shiftX/$dbu)*$MICRONFACTOR + $marginX;
        }else {
           $blly = ($image_height/2) - ($guiMuDielly - $shiftY/$dbu)*$MICRONFACTOR;
           $bury = ($image_height/2) - ($guiMuDieury - $shiftY/$dbu)*$MICRONFACTOR;
           $bllx = ($guiMuDiellx - $shiftX/$dbu)*$MICRONFACTOR + ($image_width/2);
           $burx = ($guiMuDieurx - $shiftX/$dbu)*$MICRONFACTOR + ($image_width/2);
        }
        if($boundary_display == 1 && ((($bllx >= 0 && $bllx <= $image_width) || ($burx >= 0 && $burx <= $image_width)) || (($blly >= 0 && $blly <= $image_height) || ($bury >= 0 && $bury <= $image_height)))){
           $im->rectangle($bllx,$blly,$burx,$bury, $green);
        }

        ######   display the ROWS   #####
        if($row_display == 1){
           if (exists $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}){
               my @rows = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}->dbFlplanGetRows;
               foreach my $tag ( @rows ) {
                       my ($x,$y) = (split(/\s+/, $tag))[2,3];
                       my $Row_llx = ($x-$shiftX)*$MulFactor;    
                       my $Row_lly = ($y-$shiftY)*$MulFactor;    
                       if($dieIsCentre == 1) {
                          $Row_llx = $Row_llx + ($image_width/2);
                          $Row_lly = ($image_height/2) - $Row_lly;
                       }else {
                          $Row_llx = $Row_llx + $marginX;
                          $Row_lly = ($image_height - $marginY) - $Row_lly;
                       }
                       if($Row_lly >= 0 && $bury <= $image_height){
                          #$im->line($Row_llx,$Row_lly,$burx,$Row_lly,$darkgray) if($blly != 20 );
                          $im->line($Row_llx,$Row_lly,$burx,$Row_lly,$darkgray);
                       }
               }# foreach
           }
        }#if row display is ON
        #####   display the ports of the top module  ###
        if($port_display == 1){
           my $moduleName = $TOP_MODULE;
           foreach my $port ( keys %{$PORTS_ALREADY{$moduleName}} ) {
                   my $status = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetStatus;
                   if($status == 2 || $status == 3 ) {
                      my @loc = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetLoc;
                      my ($X,$Y,$orient) = &dbPlaceFindClosestBoundary($loc[0],$loc[1]);
                      $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortSetSide($orient);
                      my $dir = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetDir;
                      my $orient = $PORTS_ALREADY{$moduleName}{$port}->dbPortGetSide;
                      my $x = ($loc[0]-$shiftX)*$MulFactor;
                      my $y = ($loc[1]-$shiftY)*$MulFactor;
                      if($dieIsCentre == 1) {
                         $x = $x + ($image_width/2);
                         $y = ($image_height/2) - $y;
                      }else {
                         $x = $x + $marginX;
                         $y = ($image_height - $marginY) - $y;
                      }
                      if(($x >= 0 || $x <= $image_width) && ($y >= 0 || $y <= $image_height)){
                         my @poly = &create_pin_shape($x,$y,$orient,$dir);
                         my $polygon = new GD::Polygon;
                         $polygon->addPt($poly[0], $poly[1]);
                         $polygon->addPt($poly[2], $poly[3]);
                         $polygon->addPt($poly[4], $poly[5]);
                         $im->polygon($polygon, $yellow);
                      }
                   }#if status is placed or fixed
           }# foreach
        }#if port display is ON
        ########  dispay the Instances  #######
        if($inst_display == 1){
           for(my $i=0; $i<=$#GCellArray ; $i++) {
              for (my $j=0; $j<=$#{@GCellArray[0]} ; $j++) {
                   my @instList = $GCellArray[$i][$j]->dbgGcellGetInst; 
                   my @filtered_inst_array = ();
                   foreach my $InstanceName (@instList){
                        my @Inst_bbox = $CADB{$InstanceName}->dbCadbGetbBox;
                        my $cellref =  $CADB{$InstanceName}->dbCadbGetCellref;
                        my $status =  $CADB{$InstanceName}->dbCadbGetStatus;
                        my $InstColor = "red";      
                        if($PLDB{$cellref}->dbMdbGetClass eq "BLOCK") {
                           $InstColor = "yellow";
                        }
                        if($status eq "PLACED" || $status eq "FIXED" ) {
                           my $llx = ($Inst_bbox[0]-$shiftX)*$MulFactor;
                           my $lly = ($Inst_bbox[1]-$shiftY)*$MulFactor;
                           my $urx = ($Inst_bbox[2]-$shiftX)*$MulFactor;
                           my $ury = ($Inst_bbox[3]-$shiftY)*$MulFactor;
                           if($dieIsCentre == 1) {
                              $lly = ($image_height/2) - $lly;
                              $ury = ($image_height/2) - $ury;
                              $llx = $llx + ($image_width/2);
                              $urx = $urx + ($image_width/2);
                           }else {
                              $lly = ($image_height - $marginY) - $lly;
                              $ury = ($image_height - $marginY) - $ury;
                              $llx = $llx + $marginX;
                              $urx = $urx + $marginX;
                           }
                           if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
                              #my $instW = abs($urx-$llx);
                              #my $instH = abs($ury-$lly);
                              #my $path2proton = $GLOBAL->dbfGlobalGetProtonHome;
                              #my $tile = newFromPng GD::Image("$path2proton/ETC/dotted_bitmap.png");
                              #$im->setTile($tile);   
                              #$im->filledRectangle($llx,$ury,$urx,$lly, gdTiled) if($instW > 3 || $instH > 3);
                              #$im->filledRectangle($llx,$ury,$urx,$lly, $red) if($instW > 3 || $instH > 3);
                              #$im->rectangle($llx,$ury,$urx,$lly, $red);
                              $im->filledRectangle($llx,$ury,$urx,$lly, $red);
                              $im->rectangle($llx,$ury,$urx,$lly, $black);
                           }
                        }# if component status is fixed or placed
                   }#foreach Instance
              }#for j
           }#for i
        }#if instance display ON
        #print "image width $image_width height $image_height | shift $shiftX $shiftY\n";
        #my $x1 = $marginX + ($bbox[0] - $shiftX )*$MulFactor;  
        #my $y1 = ($image_height - $marginY) - ($bbox[1] - $shiftY )*$MulFactor;  
        #my $x2 = $marginX + ($bbox[2] - $shiftX )*$MulFactor;  
        #my $y2 = ($image_height - $marginY) - ($bbox[3] - $shiftY )*$MulFactor;  
        #$im->string(gdSmallFont, $x1, $y1, "$bbox[0] | $bbox[1]", $white);
        #$im->string(gdSmallFont, $x2, $y2, "$bbox[2] | $bbox[3]", $white);
        #print "input bbox @bbox | $x1 $y1 $x2 $y2\n";
        ################################### creating image of nets #####################################
        if($net_display == 1){
           foreach my $net ( keys %NETS_ALREADY ) {
               if(exists $NETS_ROUTING_ALREADY{$net}) {
                  my @data = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
                  foreach my $segment ( @data ) {
                       my @seg = split(/\s+/,$segment);
                       my @routeBox = xformNetSegToRouteBox($segment);
                       my $llx = ($routeBox[0]-$shiftX)*$MulFactor;
                       my $lly = ($routeBox[1]-$shiftY)*$MulFactor;
                       my $urx = ($routeBox[2]-$shiftX)*$MulFactor;
                       my $ury = ($routeBox[3]-$shiftY)*$MulFactor;
                       if($dieIsCentre == 1) {
                          $lly = ($image_height/2) - $lly;
                          $ury = ($image_height/2) - $ury;
                          $llx = $llx + ($image_width/2);
                          $urx = $urx + ($image_width/2);
                       }else {
                          $lly = ($image_height - $marginY) - $lly;
                          $ury = ($image_height - $marginY) - $ury;
                          $llx = $llx + $marginX;
                          $urx = $urx + $marginX;
                       }
                       if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
                          if(exists $PTDB{$seg[0]} ) {
                             my $color = $PTDB{$seg[0]}->dbTechGetLayerColor;
                             my $im_color = $im->colorAllocate($po->rgb($color));
                             $im->rectangle($llx,$lly,$urx,$ury, $im_color);
                             #$im->filledRectangle($llx,$lly,$urx,$ury,$im_color);
                          }#if the metal layer exists in the technology
                       }#if the metal layer exists in the technology
                  }#foreach segment of routing
               }# if routing data is present
           }#for all nets in the database
        }#if net display is ON
        ################################ creating image of special nets ##################################
        if($spnet_display == 1){
           foreach my $net ( keys %NETS_ALREADY ) {
               my $netType = $NADB{$net}->dbNadbGetNetType;
               if (($netType == 1) || ($netType == 2)) {
                   if (exists $NETS_ROUTING_ALREADY{$net}) { 
                       my @data = ();
                       push(@data, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetSpecialRoute);
                       push(@data, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute);
                       foreach my $segment ( @data ) {
                         my @seg = split(/\s+/,$segment);
                         my @routeBox = xformNetSegToSpecialRouteBox($segment);
                         my $llx = ($routeBox[0]-$shiftX)*$MulFactor;
                         my $lly = ($routeBox[1]-$shiftY)*$MulFactor;
                         my $urx = ($routeBox[2]-$shiftX)*$MulFactor;
                         my $ury = ($routeBox[3]-$shiftY)*$MulFactor;
                         if($dieIsCentre == 1) {
                            $lly = ($image_height/2) - $lly;
                            $ury = ($image_height/2) - $ury;
                            $llx = $llx + ($image_width/2);
                            $urx = $urx + ($image_width/2);
                         }else {
                            $lly = ($image_height - $marginY) - $lly;
                            $ury = ($image_height - $marginY) - $ury;
                            $llx = $llx + $marginX;
                            $urx = $urx + $marginX;
                         }
                         if((($llx >= 0 && $llx <= $image_width) || ($urx >= 0 && $urx <= $image_width)) || (($lly >= 0 && $lly <= $image_height) || ($ury >= 0 && $ury <= $image_height))){
                            if (exists $PTDB{$seg[0]} ) {
                               my $color = $PTDB{$seg[0]}->dbTechGetLayerColor;
                               my $im_color = $im->colorAllocate($po->rgb($color));
                               $im->rectangle($llx,$lly,$urx,$ury,$im_color);
                               #$im->filledRectangle($llx,$lly,$urx,$ury,$im_color);
                            }
                         }
                       }
                   }#if exists
               }#if type is 1 or 2
           }#foreach special net
        }#if special net display is ON
        #------------------------------------------------------------------------------------#
        ##################### context bbox #########################
        $bbox[0] = $bbox[0] - $marginX/$MulFactor;
        $bbox[1] = $bbox[1] - $marginY/$MulFactor;
        $bbox[2] = $bbox[0] + $image_width/$MulFactor;
        $bbox[3] = $bbox[1] + $image_height/$MulFactor;
        ############################################################
     }#if dieArea exists
     # Open a file for writing 
     open(PICTURE, ">$outFile") or $! and print"permission denied to write $outFile\n" and return @errBBox;
     
     # Make sure we are writing to a binary stream
     binmode PICTURE;
     
     # Convert the image to PNG and print it to the file PICTURE
     print PICTURE $im->png if($format eq "png");
     print PICTURE $im->jpeg if($format eq "jpeg");
     print PICTURE $im->gif() if($format eq "gif");
     print PICTURE $im->gd if($format eq "gd");
     print PICTURE $im->gd2 if($format eq "gd2");
     close PICTURE;
  }
  
  #$GLOBAL->dbGlobalSetFlatImageBBox(@bbox);
  
  $t1 = new Benchmark;
  my $td = timediff($t1, $t0);
  print "flat image ($outFile) creation took:",timestr($td),"\n";
  return(@bbox);
}#sub create_flat_image

############################################################################################
######################## Subroutine to convert pixels in db ################################
############################################################################################
#sub getBboxPixel2DB {
# my ($llx, $lly, $urx, $ury, $image_width, $image_height) = @_;
# my $displayFactor;
#
# my ($context_llx, $context_lly, $context_urx, $context_ury) = $GLOBAL->dbGlobalGetFlatImageBBox;
#
# my $context_width = $context_urx - $context_llx; 
# my $context_height = $context_ury - $context_lly;
#
# my $xDisFactor = ($image_width -40)/$context_width;
# my $yDisFactor = ($image_height-40)/$context_height;
#
# if ($xDisFactor < $yDisFactor){
#    $displayFactor = $xDisFactor;
# } else {
#    $displayFactor = $yDisFactor;
# }
#
# my $new_llx = $context_llx + ($llx - 20)/$displayFactor;
# my $new_lly = $context_lly + (($image_height-20) - $lly)/$displayFactor;
# my $new_urx = $context_llx + ($urx - 20)/$displayFactor;
# my $new_ury = $context_lly + (($image_height - 20) - $ury)/$displayFactor;
#  
# return($new_llx,$new_lly,$new_urx,$new_ury);
#}#sub getBboxPixel2DB

############################################################################################
######################## Subroutine to create pin shape ####################################
############################################################################################
sub create_pin_shape {
my $originX = $_[0];
my $originY = $_[1];
my $orient = $_[2];
my $dir = $_[3];
my ($x1,$x2,$x3,$y1,$y2,$y3);

if ( $dir eq "OUTPUT" || $dir eq "output" ) {
     if ( $orient eq "E" ) {
          $x1 = $originX ;
          $x2 = $originX + 2 ;   
          $x3 = $originX ;   
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "W" ) {
          $x1 = $originX;
          $x2 = $originX - 2;   
          $x3 = $originX;   
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "S" ) {
          $x1 = $originX + 1;
          $x2 = $originX;   
          $x3 = $originX - 1;   
          $y1 = $originY;
          $y2 = $originY - 2;
          $y3 = $originY;
                           }
     elsif ( $orient eq "N" ) {
          $x1 = $originX + 1;
          $x2 = $originX;     
          $x3 = $originX - 1;
          $y1 = $originY;
          $y2 = $originY + 2;
          $y3 = $originY;
                           }
                        }
elsif ( $dir eq "INPUT" || $dir eq "input" ) {
     if ( $orient eq "W" ) {
          $x1 = $originX - 2;
          $x2 = $originX;
          $x3 = $originX - 2;
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "E" ) {
          $x1 = $originX + 2;
          $x2 = $originX;
          $x3 = $originX + 2;
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "N" ) {
          $x1 = $originX + 1;
          $x2 = $originX;
          $x3 = $originX - 1;
          $y1 = $originY + 2;
          $y2 = $originY;
          $y3 = $originY + 2;
                           }
     elsif ( $orient eq "S" ) {
          $x1 = $originX + 1;
          $x2 = $originX;
          $x3 = $originX - 1;
          $y1 = $originY - 2;
          $y2 = $originY;
          $y3 = $originY - 2;
                           }

                          }
elsif ( $dir eq "INOUT" || $dir eq "inout" ) {
     if ( $orient eq "W" ) {
          $x1 = $originX - 2;
          $x2 = $originX;
          $x3 = $originX - 2;
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "E" ) {
          $x1 = $originX + 2;
          $x2 = $originX;
          $x3 = $originX + 2;
          $y1 = $originY + 1;
          $y2 = $originY;
          $y3 = $originY - 1;
                           }
     elsif ( $orient eq "N" ) {
          $x1 = $originX + 1;
          $x2 = $originX;
          $x3 = $originX - 1;
          $y1 = $originY + 2;
          $y2 = $originY;
          $y3 = $originY + 2;
                           }
     elsif ( $orient eq "S" ) {
          $x1 = $originX + 1;
          $x2 = $originX;
          $x3 = $originX - 1;
          $y1 = $originY - 2;
          $y2 = $originY;
          $y3 = $originY - 2;
                           }

                          }
else {print "WARN : GUI-001 : unknown direction of the pin\n"; }

return($x1,$y1,$x2,$y2,$x3,$y3);
}# sub create_pin_shape

#####################################################################################
sub create_gcells_flat_image{
 use Benchmark;
 my $t0 = new Benchmark;
 
 my $noOfArg = @_;
 
 if($_[0] eq "-h" || $_[0] eq "-help" || $_[0] eq "-HELP"){
    print"Usage: create_gcells_flat_image \n";
    print"                         -width <image width>\n";
    print"                         -height <image height>\n";
    print"                         -margin <margin from chip boundary in micron>\n";
    print"                         -zoom_level <num of zoom levels>\n";
    print"                         --die <boundary display>\n";
    print"                         --inst <instance display>\n";
    print"                         --row <rows display>\n";
    print"                         --port <ports display>\n";
    print"                         --net <nets display>\n";
    print"                         --spnet <special nets display>\n";
    print" default value <width:800>\n";
    print" default value <height:800>\n";
    return;
 }else{
    my $dbu = $GLOBAL->dbfGlobalGetDBU;
    my ($image_width, $image_height) = (800, 800); 
    my $margin = 0; 
    my $max_zoom_levels = 0; 
    my @switchArg = ();
    for(my $xx=0; $xx<$noOfArg; $xx++){
       if($_[$xx] eq "-width"){$image_width = $_[$xx+1];}
       if($_[$xx] eq "-height"){$image_height = $_[$xx+1];}
       if($_[$xx] eq "-margin"){$margin = $_[$xx+1];}
       if($_[$xx] eq "-zoom_level"){$max_zoom_levels = $_[$xx+1];}
       if($_[$xx] eq "--die"){push(@switchArg, $_[$xx]);}
       if($_[$xx] eq "--inst"){push(@switchArg, $_[$xx]);}
       if($_[$xx] eq "--row"){push(@switchArg, $_[$xx]);}
       if($_[$xx] eq "--port"){push(@switchArg, $_[$xx]);}
       if($_[$xx] eq "--net"){push(@switchArg, $_[$xx]);}
       if($_[$xx] eq "--spnet"){push(@switchArg, $_[$xx]);}
    }

    my $min_value = 0;
    my $cnt = 0;
    foreach my $macro (keys %PLDB){
       my @size = sort{$a<=>$b}($PLDB{$macro}->dbMdbGetSize);
       #print "@size\n";
       if($cnt == 0){
          $min_value = $size[0];
       }
       if($size[0] < $min_value){
          $min_value = $size[0];
       }
       $cnt++;
    }
    #print "min $min_value\n";
    $min_value *= $dbu;
    my $marginX_in_dbu = $margin*$dbu;
    my $marginY_in_dbu = $margin*$dbu;
    if(exists $DIE_ALREADY{dieArea} ) {
       my $chip_llx = $DIE_ALREADY{dieArea}[0];
       my $chip_lly = $DIE_ALREADY{dieArea}[1];
       my $chip_urx = $DIE_ALREADY{dieArea}[2];
       my $chip_ury = $DIE_ALREADY{dieArea}[3];

       if(($chip_urx - $chip_llx) > ($chip_ury - $chip_lly)){
          $marginX_in_dbu = ($chip_urx - $chip_llx)/30 if($margin == 0);
          $marginY_in_dbu = $marginX_in_dbu + (($chip_urx - $chip_llx) - ($chip_ury - $chip_lly))/2;
       }else{
          $marginY_in_dbu = ($chip_ury - $chip_lly)/30 if($margin == 0);
          $marginX_in_dbu = $marginY_in_dbu + (($chip_ury - $chip_lly) - ($chip_urx - $chip_llx))/2;
       }
       
       my $chip_width = $chip_urx - $chip_llx + 2*$marginX_in_dbu;
       my $chip_height = $chip_ury - $chip_lly + 2*$marginY_in_dbu;
       
       if($max_zoom_levels == 0){ 
          if($chip_width <= $chip_height){
             $max_zoom_levels = int($chip_width/$min_value);
          }else{
             $max_zoom_levels = int($chip_height/$min_value);
          }
       }
       #print "zoom_levels $max_zoom_levels\n";

       #&create_flat_image( -width, $image_width, -height, $image_height, -output, 'base_view');
       for(my $i=0; $i<=$max_zoom_levels; $i++){
           my $num_rows = 2**$i;
           my $num_cols = $num_rows;
           #print "level $i ($num_rows $num_cols)\n";
           my $x_step_size = $chip_width/$num_rows;
           my $y_step_size = $chip_height/$num_cols;
           my $step_size = $x_step_size;
           if($y_step_size > $x_step_size){
              $step_size = $y_step_size;
           } 
           if($image_width*$num_rows > 50000 || $image_height*$num_cols > 50000){last;}
           #&create_flat_image( -width, $image_width*$num_rows, -height, $image_height*$num_cols, -output, 'base_view_'.$i);
           for($j=0; $j<$num_rows; $j++){
               my $bbox_lly = $j*$step_size - $marginY_in_dbu;
               my $bbox_ury = $bbox_lly + $step_size;
               for($k=0; $k<$num_cols; $k++){
                   #print "$i $j $k\n";
                   my $bbox_llx = $k*$step_size - $marginX_in_dbu;  
                   my $bbox_urx = $bbox_llx + $step_size;  
                   #print "bbox $bbox_llx $bbox_lly $bbox_urx $bbox_ury\n";
                   &create_flat_image(@switchArg, -width, $image_width, -height, $image_height, -margin, $margin, -output, $i.'_'.$j.'_'.$k, -bbox, "{$bbox_llx, $bbox_lly, $bbox_urx, $bbox_ury}");
               }
           }
       }
    }
 }
 $t1 = new Benchmark;
 my $td = timediff($t1, $t0);
 print "cmd:create_gcells_flat_image took:",timestr($td),"\n";
}#sub create_gcells_flat_image


1;
