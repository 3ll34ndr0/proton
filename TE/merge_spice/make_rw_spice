sub dbgSpiceCompileSpice3Deck {


open(WRITE,">TA.spice");
print "INFO-TE : 001 : writing header\n";
&dbgSpiceDeckHeader;
print "INFO-TE : 002 : adding the spice thingi...\n";
&dbgSpice1PathFromReg ;
close(WRITE);
system("/usr/local/spice/bin/spice3 -n -b TA.spice");
#&dbgSpiceReadSimOutputData;
$ret_value = &dbgSpiceReadSimOutputData_New;
if ( $env_stop_commands_on_problems eq "true" ) {
if ( $ret_value eq "STOP" ) {
        print "INFO-TE : 003 : returning from calling subroutine\n";
        return(STOP);
                            }
                                               }
&dbgSpiceReport1PathTiming;

}#sub dbgSpiceCompileSpice3Deck

sub fracture_netlist {
my $noOfArguments = @_;

if( $noOfArguments < 2 || $_[0] eq '-h') { print "Usage : fracture_netlist -rep_path_cmmd <fileName> \n";
                           print "                         -outfile     <fileName> \n";
                         }
else {
for(my $i = 0; $i < $noOfArguments; $i++){
if($_[$i] eq "-rep_path_cmmd"){$PKS_CMD_FILE = $_[$i+1]; $PKS_STA = 1;}
if($_[$i] eq "-outfile"){$REPORT_FILE = $_[$i+1];}
                                         } # for

print "INFO-TE-FRCTRE : 001 : Writing timing report to file \"timingReport.rpt\"\n";
open (WRITE_REPORT,">$REPORT_FILE");
open (WRITE_PKS_STA,">$PKS_CMD_FILE");
print WRITE_REPORT "Report of Dynamic Timing Analysis from eQAtor tool\n";
print WRITE_REPORT "----------------------------------------\n";
print WRITE_REPORT "\n";
print WRITE_REPORT "\n";
#&dbgBuildNetNameMap;
print "INFO-TE-FRCTRE : 002 : Timing the design ... facturing the netlist\n";
$ret_value = &dbgSpiceReg2RegTrace;
if( $ret_value eq "STOP" ) { print "INFO-TE-FRCTRE : 003 : Stoping the command :  fracture_netlist : \n"; }
close(WRITE_REPORT);
close(WRITE_PKS_STA);
      }# if correct arguments
}#fracture_netlist

sub dbgSpiceDeckHeader {

print WRITE "\.lib $SPICE_MODELS_COND_POINTERS\n";
foreach my $pointer ( @SPICE_MODELS_POINTERS ) {
print WRITE "\.include $pointer\n";
                                             }# all the spice model files read 

########## print the .include statements  ##########

foreach my $pointer ( @SPICE_FILE_POINTERS ) {
print WRITE "\.include $pointer\n";
                                             }# all the spice files read 

}# sub dbgSpiceDeckHeader 

sub dbgSpiceReg2RegTrace {
                                                                                                                                                      
$count2 = 0;
$pathNum = 1;
                                                                                                                                                      
foreach $instance ( keys %COMP_ALREADY ) {
        $cellref = $COMP_ATTRIBUTE_ALREADY{$instance}{cellref};
        if ( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg" ) {
        @TEMP_PATH=();
        push(@TEMP_PATH,$instance);
     $ret_value = &dbgSpiceTraceReg2Reg($instance,$count2);
 if( $ret_value eq "STOP" ) {
            # print "Exiting subroutine 1\n";
             return(STOP);
                            }
                 print "INFO-TE : 001 : ended trace from starting flop\n";
                                                                  }#if instance is a register
                                                                                                                                                      
                                         }# foreach component
                                                                                                                                                      
                                                                                                                                                      
}#sub dbgSpiceReg2RegTrace
                                                                                                                                                      
sub dbgSpiceTraceReg2Reg  {
                                                                                                                                                      
local $instanceName = $_[0];
local $noOfComponentsBeforeBranch = $_[1];
local $cellref = $COMP_ATTRIBUTE_ALREADY{$instanceName}{cellref};
local $fwdNetName;

foreach $pinName ( keys %{$MACROS_ALREADY{$cellref}} ) {
               if ( $MACROS_ALREADY{$cellref}{$pinName}{direction} eq "output" ) {
                   if( exists $COMP_ALREADY{$instanceName}{$pinName} ) {
                   print "INFO-TE : 001 : $instanceName\n";
                   $fwdNetName = $COMP_ALREADY{$instanceName}{$pinName};
                   $noOfComponentsOnNet = keys %{$NETS_ALREADY{$fwdNetName}};
                   if($noOfComponentsOnNet > 2) {
                   $noOfComponentsBeforeBranch = @TEMP_PATH;
                                                } else { $noOfComponentsBeforeBranch  = $noOfComponentsBeforeBranch; }
                   foreach $newInstanceName ( keys %{$NETS_ALREADY{$fwdNetName}} ) {
                        $newCellref = $COMP_ATTRIBUTE_ALREADY{$newInstanceName}{cellref};

                   if ( $newInstanceName eq $instanceName ) {
                                                            }
                   elsif($MACROS_ATTRIBUTE_ALREADY{$newCellref}{func} eq "reg" ) {
                          push(@TEMP_PATH,"$newInstanceName $fwdNetName");
###########################################################################################################################################
# since end flop is reached ; path is complete  
# call spice to time the path ###
                                       $pathNum++;
                                       $presentNoOfComponents = @TEMP_PATH;
# since end flop is reached check if the begin and end points are the one which we want
         $instStart = (split(/\s+/, $TEMP_PATH[0]))[0];
         $instEnd = (split(/\s+/, $TEMP_PATH[$presentNoOfComponents-1]))[0];
         if ( $instStart eq $instEnd ) {
         print "INFO-TE : 002 : Found the self loop path ... ignoring\n";
                                       }
         else {
              if ( $PKS_STA == 1 ) { 
                      print WRITE_PKS_STA "report_timing ";
                      print WRITE_PKS_STA "-from $instStart ";
                      print WRITE_PKS_STA "-to $instEnd ";
                      for ( my $xx = 1 ; $xx < $presentNoOfComponents - 1; $xx++ ) { 
                                         $throughInst = (split(/\s+/, $TEMP_PATH[$xx]))[0];  
                                         print WRITE_PKS_STA "-through $throughInst ";
                                                                                   }#for
                      print WRITE_PKS_STA "\n";
                                   }
print "INFO-TE : 003 : spice deck ready to simulate ...\n";
$ret_value = &dbgSpiceCompileSpice3Deck;
if( $ret_value eq "STOP" ) {
             print "INFO-TE : 004 : Existing from foreach\n";
             return(STOP);
                            }
              }# path found
###########################################################################################################################################
                                       $removeNoOfComponents = $presentNoOfComponents - $noOfComponentsBeforeBranch;
                                        for(my $xx = 0; $xx <= $removeNoOfComponents;$xx++) {
                                                     my $yy = $presentNoOfComponents - $xx;
                                                     delete $TEMP_PATH[$yy];
                                                                                                 }#for
                                                                              }
                   else {
                          push(@TEMP_PATH,"$newInstanceName $fwdNetName");
                          $ret_value = &dbgSpiceTraceReg2Reg($newInstanceName,$noOfComponentsBeforeBranch);
                          if( $ret_value eq "STOP" ) {
#                              print "Existing from nested loop\n";
                              return(STOP);
                                                     }

                                       $presentNoOfComponents = @TEMP_PATH;
                                       $removeNoOfComponents = $presentNoOfComponents - $noOfComponentsBeforeBranch;
                                        for(my $xx = 0; $xx <= $removeNoOfComponents;$xx++) {
                                                     my $yy = $presentNoOfComponents - $xx;
                                                     delete $TEMP_PATH[$yy];
                                                                                                 }#for
                        }
                                                                                                                                                      
                                                                                                                                                      
                                                                                   }#foreach
                                                                       }# if pin has some connectivity
                                                                                }#if pin is an output pin
                                                                                                                                                      
                                                    }# foreach pin of instance
}# sub dbgSpiceTraceReg2Reg



sub dbgSpice1PathFromReg {

#############################################################################################################################
#  writing the spice deck 
#############################################################################################################################
                                 print WRITE "\*\.subckt subckt$pathNum \n";
my @TEMP_PATH2 = ();
my $temp_count = 0;
                                 foreach $tag ( @TEMP_PATH ) {
                                 my $listOfPinsUsed = "";
                                        my ($inst,$drivingNet) = (split(/\s+/,$tag))[0,1];
                                        $temp_count++;
                                      print WRITE "X$temp_count.$inst ";
#####################################################
# insert nets
#####################################################
   my $cellref = $COMP_ATTRIBUTE_ALREADY{$inst}{cellref};

   if( exists $MACRO_SPICE{$cellref} ){
   my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     if( $pin eq "VDD" || $pin eq "VSS" || $pin eq "GND" ) { }
     elsif ( $MACROS_ALREADY{$cellref}{$pin}{direction} eq "OUTPUT" || $MACROS_ALREADY{$cellref}{$pin}{direction} eq "output" ){ 
                                                        $netName = $COMP_ALREADY{$inst}{$pin};
                                                        $temp = "n".$NETS_NAME_MAP{$netName}.__.$pin;
                                                        print WRITE "$temp ";
                                                             } else {
         #print "$pin $COMP_ALREADY{$inst}{$pin}\n";
         if ( exists $COMP_ALREADY{$inst}{$pin} ) { $netName = $COMP_ALREADY{$inst}{$pin}; 
                                                    if( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg") { $temp = "n".$NETS_NAME_MAP{$netName}.__.$pin; } else {
                                                    if( $netName eq $drivingNet) { $listOfPinsUsed = "$pin $listOfPinsUsed";
                                                          $temp = "n".$NETS_NAME_MAP{$netName}.__.$pin;
                                                                                 }
                                                        else { $temp = "i".$COMP_NAME_MAP{$inst}.__.$pin; }
                                                                                                                     }
                                                          #$temp = "i".$COMP_NAME_MAP{$inst}.__.$pin;
                                                    print WRITE "$temp ";
                                                  }
         else { }# if Pin has a connectivity        
                                                                    }# if pin is a signal pin
                                               }#while
                                   
                                  push( @TEMP_PATH2, "$inst $listOfPinsUsed");
                                   }# if cell exists in the spice subckt
    else { print "WARN-TE : 001 : the spice subckt for $inst : $cellref does not exist \n"; }
                                   print WRITE " VDD GND";
                                   print WRITE " $cellref ";
                                   print WRITE "\n";
                                                           }#foreach

my $previousInst = (split(/\s+/,$TEMP_PATH[0]))[0];
my $drNet = "";
my $noOfInstinPath = @TEMP_PATH;
my $yy = 1;

%GATE_CAP = (
DFFX1 => 2,
INVX1 => 3,
NAND2X1 => 4,
NAND3X1 => 4.6,
NAND4X1 => 4.7,
AND2X1 => 2,
AND3X1 => 2.2,
AND4X1 => 2.3,
OR2X1 => 4.1,
OR3X1 => 4.5,
OR4X1 => 5,
NOR2X1 => 4.1,
NOR3X1 => 4.5,
NOR4X1 => 5 );


for(my $xx=1; $xx < $noOfInstinPath ; $xx++) {
           my( $inst, $drNet ) = (split(/\s+/,$TEMP_PATH[$xx]))[0,1];
           $nodeName1 = "n".$NETS_NAME_MAP{$drNet}.__.$NETS_ALREADY{$drNet}{$previousInst};
           $nodeName2 = "n".$NETS_NAME_MAP{$drNet}.__.$NETS_ALREADY{$drNet}{$inst};

           ##### checking for multiple fanout of the driven net ####
           my $noOfCompAttachedtoNet = keys %{$NETS_ALREADY{$drNet}};
           if ( $noOfCompAttachedtoNet > 2 ) {
              foreach my $tempInst ( keys %{$NETS_ALREADY{$drNet}} ) {
                 if( $tempInst eq $inst || $tempInst eq $previousInst ) { }
                 else {
                 my $tempNode = "n".$COMP_NAME_MAP{$tempInst}."\.".$NETS_ALREADY{$drNet}{$tempInst};
                 ###  right now i am just approximating it with single RC number ##
#                 print WRITE "R$yy $nodeName1 $tempNode 0.0001\n";
                 $cellref = $COMP_ATTRIBUTE_ALREADY{$tempInst}{cellref};
#                 print WRITE "C$yy $tempNode GND $GATE_CAP{$COMP_ATTRIBUTE_ALREADY{$tempInst}{cellref}}ff\n";
                 $yy++;
                 
                      }
                                                                    }#foreach
                                             }# if the fanout is more than 2

           print WRITE "R$yy $nodeName1 $nodeName2 0.0001\n";
           $yy++;
                  $previousInst = $inst;
                                 }#for


                                   print WRITE "\*\.ends\n";
#########################################################
#  insert testdecks
#########################################################

print WRITE "Vsupply VDD 0 DC $SPICE_SUPPLY_VOLTAGE\n";
print WRITE "Vgnd GND 0 DC $SPICE_GND_VOLTAGE\n";

################################## 1st Flop ################################################
my $tag = $TEMP_PATH2[0];
        my($inst) = (split(/\s+/,$tag))[0];
        my $cellref = $COMP_ATTRIBUTE_ALREADY{$inst}{cellref};
            if( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg" ) {
   if( exists $MACRO_SPICE{$cellref} ){
   my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     if( $pin eq "VDD" || $pin eq "VSS" || $pin eq "GND" ) { } else {
         if ( $MACROS_ALREADY{$cellref}{$pin}{direction} eq "output" ) { }
         else {
              if( $pin eq "CLK" || $pin eq "CK" ) {
                  $startFlopClkNet = $COMP_ALREADY{$inst}{$pin};
         print WRITE "V$inst.$pin n$NETS_NAME_MAP{$startFlopClkNet}__$pin 0 pulse $SPICE_VIL $SPICE_VIH $SPICE_CLOCK_INPUT_DELAY $SPICE_RISETIME $SPICE_FALLTIME $SPICE_CLOCK_UPTIME $SPICE_CLOCK_PERIOD\n";
                                  }
              if( $pin eq "D" ) {
         print WRITE "V$inst.$pin n$NETS_NAME_MAP{$COMP_ALREADY{$inst}{$pin}}__$pin 0 pulse $SPICE_VIH $SPICE_VIL $SPICE_INPUT_DELAY $SPICE_RISETIME $SPICE_FALLTIME $SPICE_CLOCK_PERIOD $SPICE_MAX_DELAY\n";
                                  }
               }
                                                                    }#if signal pin
                                               }# while pin
                                      }#if cell exists in MACROS_SPICE database
                                                                     }# if the cell is a reg

################################## 2nd Flop ################################################
$tag = pop(@TEMP_PATH2);
        ($inst) = (split(/\s+/,$tag))[0];
        $cellref = $COMP_ATTRIBUTE_ALREADY{$inst}{cellref};
            if( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg" ) {
   if( exists $MACRO_SPICE{$cellref} ){
   my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     if( $pin eq "VDD" || $pin eq "VSS" || $pin eq "GND" ) { } else {
         if ( $MACROS_ALREADY{$cellref}{$pin}{direction} eq "output" ) { }
         else {
              if( $pin eq "CLK"  || $pin eq "CK") {
                  $endFlopClkNet = $COMP_ALREADY{$inst}{$pin};
                      if ( $endFlopClkNet eq $startFlopClkNet ) { } else {
                  #$SPICE_CLOCK_INPUT_DELAY = $SPICE_CLOCK_INPUT_DELAY + $SPICE_CLOCK_PERIOD;
         print WRITE "V$inst.$pin n$NETS_NAME_MAP{$COMP_ALREADY{$inst}{$pin}}__$pin 0 pulse $SPICE_VIL $SPICE_VIH $SPICE_CLOCK_INPUT_DELAY $SPICE_RISETIME $SPICE_FALLTIME $SPICE_CLOCK_UPTIME $SPICE_CLOCK_PERIOD\n";
                                                                         }
                                  }
               }
                                                                    }#if signal pin
                                               }# while pin
                                      }#if cell exists in MACROS_SPICE database
                                                                     }# if the cell is a reg





################################  combinantional cells #####################################
foreach $tag ( @TEMP_PATH2 ) {
        my ($inst, $pinName) = (split(/\s+/,$tag))[0,1];
        $cellref = $COMP_ATTRIBUTE_ALREADY{$inst}{cellref};
            if( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg" ) {
                                                                     }
            else {
            #print "inst $inst pin $pinName\n";
        foreach $pin (keys %{$MACROS_ALREADY{$cellref}} ) { 
            if ( $pin eq VDD || $pin eq VSS || $pin eq GND || $pin eq "vdd!" || $pin eq "gnd!" ) { }
            elsif ( $MACROS_ALREADY{$cellref}{$pin}{direction} eq "input" ) {
                    if ( $pinName eq $pin ) { }
                    else { 
 if ( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "nand" ) { print WRITE "V$inst.$pin i$COMP_NAME_MAP{$inst}__$pin 0 DC $SPICE_VIH\n"; }
 if ( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "and" ) { print WRITE "V$inst.$pin i$COMP_NAME_MAP{$inst}__$pin 0 DC $SPICE_VIH\n"; }
 if ( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "nor" ) { print WRITE "V$inst.$pin i$COMP_NAME_MAP{$inst}__$pin 0 DC $SPICE_VIL\n"; }
 if ( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "or" ) { print WRITE "V$inst.$pin i$COMP_NAME_MAP{$inst}__$pin 0 DC $SPICE_VIL\n"; }
                         }
                                                                                 }
            else { }
                                                           }#foreach
                 }
                                }#foreach

##############################  set the initial conditions on the flops ####################

$tag = $TEMP_PATH2[0];
        ($inst) = (split(/\s+/,$tag))[0];
        $cellref = $COMP_ATTRIBUTE_ALREADY{$inst}{cellref};
            if( $MACROS_ATTRIBUTE_ALREADY{$cellref}{func} eq "reg" ) {
   if( exists $MACRO_SPICE{$cellref} ){
   my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     if( $pin eq "VDD" || $pin eq "VSS" || $pin eq "GND" ) { } else {
         if ( $MACROS_ALREADY{$cellref}{$pin}{direction} eq "output" ) {
                                                                       }
         else {
               }
                                                                    }#if signal pin
                                               }# while pin
                                      }#if cell exists in MACROS_SPICE database
                                                                     }# if the cell is a reg


print WRITE "\.control\n";
print WRITE "set nobreak\n";
print WRITE "tran 0.1ps $SPICE_SIM_TIME\n";
###########################
# write results to a file #
###########################

$previousInst = (split(/\s+/,$TEMP_PATH[0]))[0];
$drNet = "";
$noOfInstinPath = @TEMP_PATH;
print WRITE "print v(n$NETS_NAME_MAP{$COMP_ALREADY{$previousInst}{CK}}__CK) >dataFile\n";
for(my $xx=1; $xx < $noOfInstinPath ; $xx++) {
           my( $inst, $drNet ) = (split(/\s+/,$TEMP_PATH[$xx]))[0,1];
           $nodeName1 = "n".$NETS_NAME_MAP{$drNet}.__.$NETS_ALREADY{$drNet}{$previousInst};
           $nodeName2 = "n".$NETS_NAME_MAP{$drNet}.__.$NETS_ALREADY{$drNet}{$inst};
           print WRITE "print v($nodeName1) >>dataFile\n";
           print WRITE "print v($nodeName2) >>dataFile\n";
                  $previousInst = $inst;
                                 }#for
#print WRITE " >dataFile\n";

print WRITE "\.endc\n";
print WRITE "\.end\n";

#############################  finish ######################################################

                                 print WRITE "\n\n";



}#sub dbgSpice1PathFromReg






sub write_spice {


my $noOfArguments = @_;
my $hformat =  "false";
my $FORMAT = spice3 ;
my $PROCEED = 1 ;

if ( $noOfArguments < 2 || $_[0] eq '-h') { print "Usage : write_spice  -output < file Name >\n";
                            print "                     -format < spice3 / hspice >\n";
                            print "                     -hier < false / true >\n";
                          } else {

  for ( my $x = 0 ; $x < $noOfArguments ; $x++) {
        if ( $_[$x] =~ /-output/ ) { $OUTPUT_SPICE_FILE = $_[$x+1]; }
        elsif ( $_[$x] =~ /-hier/ ) { $hformat = $_[$x+1]; }
        elsif ( $_[$x] =~ /-format/ ) { $FORMAT = $_[$x+1]; }
                                                   }# for no of arguments
if ( $PROCEED == 1 ) { # if it is ok to proceed because all the user provided options are understood
if ( $FORMAT eq "hspice" ) {

print "INFO-TE-WRTE_SPCE : 001 : Begin writing the netlist in hspice file format : $OUTPUT_SPICE_FILE : \n";
open ( WRITE, ">$OUTPUT_SPICE_FILE");
print WRITE "#HSPICE FILE written from eQAtor verion-$TOOL_VERSION\n";
&hspiceOut;
close(WRITE);
print "INFO-TE-WRTE-SPCE : 002 : End writing hspice file\n";
                           }
else {

print "INFO-TE-WRTE-SPCE : 003 : Begin writing the netlist in spice3 file format : $OUTPUT_SPICE_FILE : \n";
open ( WRITE, ">$OUTPUT_SPICE_FILE");
print WRITE "#SPICE3 FILE written from eQAtor verion-$TOOL_VERSION\n";
&spice3Out;
close(WRITE);
print "INFO-TE-WRTE-SPCE : 004 : End writing spice3 file\n";


     }

                      }# if correct user inputs

                          }# if correct no of arguments
}# sub write_spice



sub read_spice {


use Storable;
my $noOfArguments = @_;

if ( $noOfArguments < 2 || $_[0] eq '-h') { print "Usage : read_spice   -spc < file Name >\n";
                          } else {

for ( my $x = 0 ; $x < $noOfArguments ; $x++ ) {
      if( $_[$x] =~ /-spc/){ $SPICE_FILE_POINTER = $_[$x+1]; }
                                               }# for all agruments

open ( READ, "$SPICE_FILE_POINTER");
       
print "INFO-TE-READ_SPCE : 001 : Begin reading the spice file\n";
push(@SPICE_FILE_POINTERS,$SPICE_FILE_POINTER);
my $macroName = "";
while(<READ>) {

chomp();

$_ =~ s/^\s+//;
if ( $_ =~ /^\s*$/ ) { next; }
elsif ( $_ =~ /^\*/ ) { next; }
elsif( $_ =~ /^\.SUBCKT/ || $_ =~ /^\.subckt/) {
    my @line = split(/\s+/, $_);
       shift @line; # flush out .SUBCKT token
       $macroName = shift @line;
         if ( exists $PLDB{$macroName} ) { $PLDB{$macroName}->dbMdbSetIsSpiceNetlist(1);
                                           $SLDB{$macroName} = SpiceDB::new();
                                           $SLDB{$macroName}->dbSpiceAddNetList($_);
                                         }
       $hashTable = MACRO_SPICE.$macroName;
       $MACRO_SPICE{$macroName} = \%{$hashTable};
       $pinListbyOrder = "";
       while ( defined ( $token = shift @line )) {
             $pinListbyOrder = "$pinListbyOrder $token";
                                                 }# while
       $pinListbyOrder =~ s/^\s+//;
       ${$hashTable}{pinList} = $pinListbyOrder;
                                               }# if a subckt starts
else {
     $SLDB{$macroName}->dbSpiceAddNetList($_);
     }

}#while

print "INFO-TE-READ_SPCE : 002 : End reading the spice file\n";



                                 }# if correct no of arguments

}#sub read_spice


sub read_spice_models {

my $noOfArguments = @_;

if ( $noOfArguments < 2 || $_[0] eq '-h') { print "Usage : read_spice_models -spice < model file > \n";
                            print "                          -cond  < condition > \n";
                          } else {
for ( my $x = 0; $x < $noOfArguments; $x++ ) { 
    if ( $_[$x] =~ /-spice/ ){ $SPICE_MODELS_POINTERS = $_[$x+1]; }
    if ( $_[$x] =~ /-cond/ ){ $SPICE_MODELS_COND_POINTERS = $_[$x+1]; }
                                       }# for
      push(@SPICE_MODELS_POINTERS, $SPICE_MODELS_POINTERS);
                                 }# if correct no of arguments


}#sub read_spice_models


sub spice3Out {

%ReturnNetNames = ();
print WRITE "* spice subckt\n";

########## print the .include statements  ##########


print WRITE "\*\.subckt $CURRENT_MODULE ";

####### print the top level ports   ########

foreach my $portname ( keys %{$PORTS_ALREADY{$CURRENT_MODULE}}){
           print WRITE "$portname ";
                                                                }# for port of module
print WRITE "\n";


####### print the flat component connectivity ######
foreach $instance ( keys %COMP_ALREADY ) {

$master  = $COMP_ALREADY{$instance}{master};
$spiceInstance = $instance;
$spiceInstance =~ s/$master\//X/;
print WRITE "$spiceInstance ";

my $cellref = $COMP_ATTRIBUTE_ALREADY{$instance}{cellref};

if( exists $MACRO_SPICE{$cellref} ){
my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     if( $pin eq "VDD" || $pin eq "VSS" || $pin eq "GND" ) { } else {
     $netName = $COMP_ALREADY{$instance}{$pin};
     $netName =~ s/$master\///;
     print WRITE "$netName ";
     $ReturnNetNames{$netName}=1; 
                                                   }
                                               }#while
                                   }# if cell exists in the spice subckt
else {  
     print "WARN-TE : 001 : spice subckt for $cellref not found\n";
        foreach $pin ( keys %{$COMP_ALREADY{$instance}} ) {
        if( $pin eq "master" || $pin eq "cellref" ) {} else {
        print WRITE "$pin $COMP_ALREADY{$instance}{$pin} ";
                                                           }# if only pin
                                                          }
     }# if spice does not exist

print WRITE " VDD GND ";
print WRITE " $COMP_ATTRIBUTE_ALREADY{$instance}{cellref}\n";

                                    }# foreach components
print WRITE "\*\.ends\n";
}# sub spice3Out

sub hspiceOut {

print WRITE "* spice subckt\n";

########## print the .include statements  ##########


print WRITE "\.subckt $CURRENT_MODULE ";

####### print the top level ports   ########

foreach my $portname ( keys %{$PORTS_ALREADY{$CURRENT_MODULE}}){
           print WRITE "$portname ";
                                                                }# for port of module
print WRITE "\n";


####### print the flat component connectivity ######
foreach $instance ( keys %COMP_ALREADY ) {

$master  = $COMP_ALREADY{$instance}{master};
$spiceInstance = $instance;
$spiceInstance =~ s/$master\//X/;
print WRITE "$spiceInstance ";

my $cellref = $COMP_ATTRIBUTE_ALREADY{$instance}{cellref};

if( exists $MACRO_SPICE{$cellref} ){
my @pinList = split(/\s+/, $MACRO_SPICE{$cellref}{pinList});
     while ( defined ( $pin = shift @pinList)) {
     $netName = $COMP_ALREADY{$instance}{$pin};
     $netName =~ s/$master\///;
     print WRITE "$netName ";
                                               }#while
                                   }# if cell exists in the spice subckt
else {  
     print "WARN-TE : 001 : spice subckt for $cellref not found\n";
        foreach $pin ( keys %{$COMP_ALREADY{$instance}} ) {
        if( $pin eq "master" || $pin eq "cellref" ) {} else {
        print WRITE "$pin $COMP_ALREADY{$instance}{$pin} ";
                                                           }# if only pin
                                                          }
     }# if spice does not exist

print WRITE " $COMP_ATTRIBUTE_ALREADY{$instance}{cellref}\n";

                                    }# foreach components
print WRITE "\.ends\n";

}#sub hspiceOut






sub dbgBuildNetNameMap {
my $count = 1;
foreach my $netName ( keys %NETS_ALREADY) { $NETS_NAME_MAP{$netName} = $count; $count++; }
}#sub dbgBuildNetNameMap
sub dbgBuildInstNameMap {
my $count = 1;
foreach my $instName ( keys %COMP_ALREADY) { $COMP_NAME_MAP{$instName} = $count; $count++; }
}#sub dbgBuildInstNameMap





sub dbgSpiceReport1PathTiming {

my $tempnodeName = "";
my $noOfInstinPath = @TEMP_PATH;
print WRITE_REPORT "Path : $pathNum\n";
$previousInst = (split(/\s+/,$TEMP_PATH[0]))[0];
my $startInst = $previousInst;

$tempnodeName = "n".$NETS_NAME_MAP{$COMP_ALREADY{$startInst}{CK}}.__."CK";
my $clockArrivalTime = $SPICE_RESULT_DATA{$tempnodeName}{dlyAt};

my $stopInst = (split(/\s+/,$TEMP_PATH[$noOfInstinPath - 1]))[0];

print WRITE_REPORT "StartPoint : $startInst\n";
print WRITE_REPORT "EndPoint : $stopInst\n";

$tempnodeName = "n".$NETS_NAME_MAP{$COMP_ALREADY{$stopInst}{D}}.__."D";
my $dataArrivalAtTargetFlop = $SPICE_RESULT_DATA{$tempnodeName}{dlyAt};

print WRITE_REPORT "Start at $clockArrivalTime\n";
print WRITE_REPORT "Arrival at $dataArrivalAtTargetFlop \n";
my $pathDelay = $dataArrivalAtTargetFlop - $clockArrivalTime;
print WRITE_REPORT "path delay = $pathDelay\n";
print WRITE_REPORT "\n";

$drNet = "";
for(my $xx=1; $xx < $noOfInstinPath ; $xx++) {
           my( $inst, $drNet ) = (split(/\s+/,$TEMP_PATH[$xx]))[0,1];
                  my $cellref = $COMP_ATTRIBUTE_ALREADY{$previousInst}{cellref};
                  print WRITE_REPORT "$previousInst  ($cellref) ";

                  $driverPin = $NETS_ALREADY{$drNet}{$previousInst};
                  $recieverPin = $NETS_ALREADY{$drNet}{$inst};
                      $tempnodeName = "n".$NETS_NAME_MAP{$drNet}.__.$driverPin;
                      print WRITE_REPORT "$tempnodeName ";
                  $arrivalTime = $SPICE_RESULT_DATA{$tempnodeName}{dlyAt};
                   print WRITE_REPORT "$arrivalTime \n";

                  print WRITE_REPORT "$drNet \n";
                  $previousInst = $inst;
                                 }#for
                  $cellref = $COMP_ATTRIBUTE_ALREADY{$previousInst}{cellref};
                  print WRITE_REPORT "$previousInst  ($cellref) \n";


print WRITE_REPORT "\n\n";
}#sub dbgSpiceReport1PathTiming
#------------------------------------------------------verilog2spice-------------------------#
sub verilog_to_spice {
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : verilog_to_spice\n";
                                        print "      : -output<outputfileName>\n";
                                        print "      : --spiceLib <path of the dir>\n";
                                        print "      : --spiceOrder\n";
                                        print "      : --complete_spice\n";
                                       }
else {
#my $moduleName = $TOP_MODULE;
my $start_module = $TOP_MODULE;
my $no_of_level = -1;
my $OUTPUT_FILE = "";
my $path_of_the_dir = "";
my $dir_given = 0;
my $spiceOrder = 0;
my $complete_spice = 0;
my $write_fh;
  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] eq "-output"){$OUTPUT_FILE = $_[$i+1];}
    if($_[$i] eq "--spiceLib"){$path_of_the_dir = $_[$i+1];$dir_given = 1;}
    if($_[$i] eq "--spiceOrder"){$spiceOrder = 1;}
    if($_[$i] eq "--complete_spice"){$complete_spice = 1;}
  }#for
#------------------------------------------------ hier : begin : writing from the VERILOG database  ---------------------------------------------------------------------#
%TEMP_MODULE_ALREADY = ();
&populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($start_module,$no_of_level);
@temp_module_list = sort { $TEMP_MODULE_ALREADY{$a} <=> $TEMP_MODULE_ALREADY{$b} } keys %TEMP_MODULE_ALREADY;
open($write_fh,">$OUTPUT_FILE");
foreach my $moduleName (@temp_module_list) {
  my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
  my @inPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetInput;
  my @outPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutput;
  my @bidiPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidi;
  my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
  my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
  my $portcnt = 0;
  my @allPorts_for_top = ();
  foreach my $i ( @inPorts ) { 
    my $busWidth = "";
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputType($i);
    if ( $type == 1 ) {
      $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputBits($i); 
      $busWidth =~ s/\[/$get_opening_bracket/;
      $busWidth =~ s/\]/$get_closing_bracket/;
    }
    if ( $i =~ /\\/ ){$i = $i." "}; 
    if($portcnt == 8){
      push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
      $portcnt = 0;
    }else {
      push ( @allPorts_for_top, $i."".$busWidth); 
    }
    $portcnt++;
  }#foreach inport
  foreach my $i ( @outPorts ) { 
    my $busWidth = "";
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputType($i);
    if ( $type == 1 ) {
      $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputBits($i);
      $busWidth =~ s/\[/$get_opening_bracket/;
      $busWidth =~ s/\]/$get_closing_bracket/;
    }
    if ( $i =~ /\\/ ){$i = $i." "}; 
    if($portcnt == 8){
      push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
      $portcnt = 0;
    }else {
      push ( @allPorts_for_top, $i."".$busWidth); 
    }
    $portcnt++;
  }#foreach outport
  foreach my $i ( @bidiPorts ) { 
    my $busWidth = "";
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($i);
    if ( $type == 1 ) {
      $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($i);
      $busWidth =~ s/\[/$get_opening_bracket/;
      $busWidth =~ s/\]/$get_closing_bracket/;
    }
    if ( $i =~ /\\/ ){$i = $i." "}; 
    if($portcnt == 8){
      push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
      $portcnt = 0;
    }else {
      push ( @allPorts_for_top, $i."".$busWidth); 
    }
    $portcnt++;
  }#foreach bidiport
  print $write_fh ".subckt $moduleName "if(@allPorts_for_top != ""); 
  print $write_fh "@allPorts_for_top\n"if(@allPorts_for_top != "");
#  my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
  my %SUBCKT_PORT_DATA = (); 
  my %INST_NAME_HASH = ();
  my %NET_LIST_HASH = ();
  my $inst_cnt = 1;
  foreach my $connLine (@conns){
    $connLine =~ s/\(/\)\,/;
    $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
    my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
    #my $instName = "XX"."_".$inst_cnt."_".$inst;
    my $instName = $inst;
    push(@{$INST_NAME_HASH{$cell}},$instName);
    if ($MODULE_ALREADY{$moduleName}->dbVNOMHasLeafInst($inst) ){
    }elsif ($MODULE_ALREADY{$moduleName}->dbVNOMHasHierInst($inst)){ 
      my @allPorts = ();
      if(($spiceOrder == 0) && ($dir_given == 0)){
        my @nets = split(/\s*\)\s*\,\s*/, $connLine);
        my $noOfPins = @nets;
        my $port_cnt = 0;
        my $cnt = 0;
        for(my $i = 1 ; $i < $noOfPins ; $i++){
        $nets[$i] =~ s/\s*\(\s*/\|/;
        $nets[$i] =~ s/\s*\)\s*//;
        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
        $pin =~ s/\.//;
        if ( exists $MODULE_ALREADY{$cell}->{ins}{$pin} ) {
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetInputType($pin);
          if ( $type == 1 ) {
            $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetInputBits($pin); 
            $busWidth =~ s/\[/$get_opening_bracket/;
            $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
            $port_cnt++;
        }elsif(exists $MODULE_ALREADY{$cell}->{outs}{$pin}){
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetOutputType($pin);
          if ( $type == 1 ) {
            $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetOutputBits($pin); 
            $busWidth =~ s/\[/$get_opening_bracket/;
            $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
          $port_cnt++;
        }elsif(exists $MODULE_ALREADY{$cell}->{bidis}{$pin}){
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetBidiType($pin);
          if ( $type == 1 ) {
            $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetBidiBits($pin); 
            $busWidth =~ s/\[/$get_opening_bracket/;
            $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
            $port_cnt++;
        }#elsif
        @{$SUBCKT_PORT_DATA{$cell}} = @allPorts;
          $netNameExpr = $net;
          $netNameExpr =~ s/^\s+//;
          $netNameExpr =~ s/\s+$//;
          if ($netNameExpr =~ /\{.*\}/) {
            $netNameExpr =~ s/\{/ /g;
            $netNameExpr =~ s/\}/ /g;
            $netNameExpr =~ s/\,/ /g;
            $netNameExpr =~ s/^\s+//;
            $netNameExpr =~ s/\s+$//;
            my @netNameExprList = (split(/\s+/,$netNameExpr));
            if(@netNameExprList == 0){
              print "ERR : netName is empty for this pin $pin and instance is $inst\n"; 
            }
            foreach my $netName (@netNameExprList){
              if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netName =~ s/\s+//g;
                $netName =~ s/\s+$//g;
                $netName =~ s/\[/$get_opening_bracket/;
                $netName =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                }
                $cnt++;
              }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                $netName =~ s/\s+//g;
                $netName =~ s/\s+$//g;
                $netName =~ s/\[/$get_opening_bracket/;
                $netName =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                }
                $cnt++;
              }elsif($netName =~ /\s*1'b0\s*/){
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                }
                $cnt++;
              }elsif($netName =~ /\s*1'b1\s*/){
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                }
                $cnt++;
              }else { 
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                }
                $cnt++;
              }
            }#foreach
          }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/ ) {
            $netNameExpr =~ s/\s+//g;
            $netNameExpr =~ s/\s+$//g;
            $netNameExpr =~ s/\[/$get_opening_bracket/;
            $netNameExpr =~ s/\]/$get_closing_bracket/;
            if($netNameExpr eq ""){
              print "ERR : netName is empty for this pin $pin and instance is $inst\n"; 
            }
            if($cnt == 8){
              push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
              $cnt = 0;
            }else {
              push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
            }
            $cnt++;
          }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\]/ ) {
            $netNameExpr =~ s/\s+//g;
            $netNameExpr =~ s/\s+$//g;
            $netNameExpr =~ s/\[/$get_opening_bracket/;
            $netNameExpr =~ s/\]/$get_closing_bracket/;
            if($netNameExpr eq ""){
              print "ERR : netName is empty for this pin $pin and instance is $inst\n"; 
            }
            if($cnt == 8){
              push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
              $cnt = 0;
            }else {
              push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
            }
             $cnt++;
          }else {
            if($netNameExpr eq ""){
              print "ERR : netName is empty for this pin $pin and instance is $inst\n"; 
            }
            if($netNameExpr =~ /\s*1'b0\s*/){
              if($cnt == 8){
                push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                $cnt = 0;
              }else {
                push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
              }
              $cnt++;
            }elsif($netNameExpr =~ /\s*1'b1\s*/){
              if($cnt == 8){
                push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                $cnt = 0;
              }else {
                push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
              }
              $cnt++;
            }else{
              if($cnt == 8){
                push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                $cnt = 0;
              }else {
                push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
              }
              $cnt++;
            }
          }                  
      }#for 
    }if(($spiceOrder == 0) && ($dir_given == 1)){
      my $class = $MODULE_ALREADY{$cell}->dbVNOMGetClass;
      if($class == 0){
        my @nets = split(/\s*\)\s*\,\s*/, $connLine);
        my $noOfPins = @nets;
        my $port_cnt = 0;
        my $cnt = 0;
        for(my $i = 1 ; $i < $noOfPins ; $i++){
        $nets[$i] =~ s/\s*\(\s*/\|/;
        $nets[$i] =~ s/\s*\)\s*//;
        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
        $pin =~ s/\.//;
        if ( exists $MODULE_ALREADY{$cell}->{ins}{$pin} ) {
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetInputType($pin);
          if ( $type == 1 ) {
             $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetInputBits($pin); 
             $busWidth =~ s/\[/$get_opening_bracket/;
             $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
          $port_cnt++;
        }elsif(exists $MODULE_ALREADY{$cell}->{outs}{$pin}){
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetOutputType($pin);
          if ( $type == 1 ) {
             $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetOutputBits($pin); 
             $busWidth =~ s/\[/$get_opening_bracket/;
             $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
          $port_cnt++;
        }elsif(exists $MODULE_ALREADY{$cell}->{bidis}{$pin}){
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetBidiType($pin);
          if ( $type == 1 ) {
             $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetBidiBits($pin); 
             $busWidth =~ s/\[/$get_opening_bracket/;
             $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
          $port_cnt++;
        }#elsif
        @{$SUBCKT_PORT_DATA{$cell}} = @allPorts;
        if(@allPorts != 0){
           $netNameExpr = $net;
           $netNameExpr =~ s/^\s+//;
           $netNameExpr =~ s/\s+$//;
           if ( $netNameExpr =~ /\{.*\}/ ) {
             $netNameExpr =~ s/\{/ /g;
             $netNameExpr =~ s/\}/ /g;
             $netNameExpr =~ s/\,/ /g;
             $netNameExpr =~ s/^\s+//;
             $netNameExpr =~ s/\s+$//;
             my @netNameExprList = (split(/\s+/,$netNameExpr));
             foreach my $netName (@netNameExprList){
               if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                 $netName =~ s/\s+//g;
                 $netName =~ s/\s+$//g;
                 $netName =~ s/\[/$get_opening_bracket/;
                 $netName =~ s/\]/$get_closing_bracket/;
                 if($cnt == 8){
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                   $cnt = 0;
                 }else {
                   push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                 }
                 $cnt++;
               }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                 $netName =~ s/\s+//g;
                 $netName =~ s/\s+$//g;
                 $netName =~ s/\[/$get_opening_bracket/;
                 $netName =~ s/\]/$get_closing_bracket/;
                 if($cnt == 8){
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                   $cnt = 0;
                 }else {
                   push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                 }
                 $cnt++;
               }elsif($netName =~ /\s*1'b0\s*/){
                 if($cnt == 8){
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                   $cnt = 0;
                 }else {
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                 }
                 $cnt++;
               }elsif($netName =~ /\s*1'b1\s*/){
                 if($cnt == 8){
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                   $cnt = 0;
                 }else {
                   push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                 }
                 $cnt++;
               }else { 
                 if($cnt == 8){
                   push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                   $cnt = 0;
                 }else {
                   push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                 }
                 $cnt++;
               }
             }#foreach
           }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/ ) {
             $netNameExpr =~ s/\s+//g;
             $netNameExpr =~ s/\s+$//g;
             $netNameExpr =~ s/\[/$get_opening_bracket/;
             $netNameExpr =~ s/\]/$get_closing_bracket/;
             if($cnt == 8){
               push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
               $cnt = 0;
             }else {
               push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
             }
               $cnt++;
           }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\]/ ) {
             $netNameExpr =~ s/\s+//g;
             $netNameExpr =~ s/\s+$//g;
             $netNameExpr =~ s/\[/$get_opening_bracket/;
             $netNameExpr =~ s/\]/$get_closing_bracket/;
             if($cnt == 8){
               push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
               $cnt = 0;
             }else {
               push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
             }
               $cnt++;
           }else {
             if($netNameExpr =~ /\s*1'b0\s*/){
               if($cnt == 8){
                 push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                 $cnt = 0;
               }else {
                 push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
               }
               $cnt++;
             }elsif($netNameExpr =~ /\s*1'b1\s*/){
               if($cnt == 8){
                 push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                 $cnt = 0;
               }else {
                 push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
               }
               $cnt++;
             }else{
               if($cnt == 8){
                 push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $net"); 
                 $cnt = 0;
               }else {
                 push(@{$NET_LIST_HASH{$cell}{$instName}},$net); 
               }
               $cnt++;
             }
           }                  
         }
      }#for 
      }elsif($class == 11){
         my %TEMP_SUBCKT_PORT_DATA_HASH = ();
         my @all_Ports_of_subckt_new = ();
         if( -d $path_of_the_dir){
           my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
           foreach my $fileName (@spifiles){
             if($fileName eq "."|| $fileName eq ".."){next;}
             chomp($fileName);
             my $temp_file = $fileName;
             $temp_file =~ s/.*\///;
             $temp_file =~ s/\..*//;
             if($temp_file =~ /\b$cell\b/){
               my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
               @{$TEMP_SUBCKT_PORT_DATA_HASH{$cell}} = @all_Ports_of_subckt_from_file;
             }
           }#foreach
         }#if dir path exists
        if(exists $TEMP_SUBCKT_PORT_DATA_HASH{$cell}){
          my @port_list = @{$TEMP_SUBCKT_PORT_DATA_HASH{$cell}}; 
          my @nets = split(/\s*\)\s*\,\s*/, $connLine);
          my $noOfPins = @nets;
          my $cnt = 0;
          if(@port_list != 0){
            foreach my $pinName (@port_list){
              for(my $i = 1 ; $i < $noOfPins ; $i++){
              $nets[$i] =~ s/\s*\(\s*/\|/;
              $nets[$i] =~ s/\s*\)\s*//;
              my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
              $pin =~ s/\.//;
              if ($pin eq $pinName){
                $netNameExpr = $net;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                if ($netNameExpr =~ /\{.*\}/) {
                    $netNameExpr =~ s/\{/ /g;
                    $netNameExpr =~ s/\}/ /g;
                    $netNameExpr =~ s/\,/ /g;
                    $netNameExpr =~ s/^\s+//;
                    $netNameExpr =~ s/\s+$//;
                    my @netNameExprList = (split(/\s+/,$netNameExpr));
                    foreach my $netName (@netNameExprList){
                      if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                        $netName =~ s/\s+//g;
                        $netName =~ s/\s+$//g;
                        $netName =~ s/\[/$get_opening_bracket/;
                        $netName =~ s/\]/$get_closing_bracket/;
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                        }
                        $cnt++;
                      }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                        $netName =~ s/\s+//g;
                        $netName =~ s/\s+$//g;
                        $netName =~ s/\[/$get_opening_bracket/;
                        $netName =~ s/\]/$get_closing_bracket/;
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                        }
                        $cnt++;
                      }elsif($netName =~ /\s*1'b0\s*/){
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                        }
                        $cnt++;
                      }elsif($netName =~ /\s*1'b1\s*/){
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                        }
                        $cnt++;
                      }else { 
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                        }
                        $cnt++;
                     }
                   }#foreach
                 }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/ ) {
                   $netNameExpr =~ s/\s+//g;
                   $netNameExpr =~ s/\s+$//g;
                   $netNameExpr =~ s/\[/$get_opening_bracket/;
                   $netNameExpr =~ s/\]/$get_closing_bracket/;
                   if($cnt == 8){
                     push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                     $cnt = 0;
                   }else {
                     push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                   }
                   $cnt++;
                }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\]/ ) {
                  $netNameExpr =~ s/\s+//g;
                  $netNameExpr =~ s/\s+$//g;
                  $netNameExpr =~ s/\[/$get_opening_bracket/;
                  $netNameExpr =~ s/\]/$get_closing_bracket/;
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                  }
                  $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else{
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $net"); 
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},$net); 
                  }
                  $cnt++;
                }
              }
              push(@all_Ports_of_subckt_new,$pinName);
             }
            }#for
          }#foreach
         }
          @{$SUBCKT_PORT_DATA{$cell}} = @all_Ports_of_subckt_new;
        }else{print "ERR : $cell does not exists in anywhere\n";}
       }#elsif class == 11
     }if (($spiceOrder == 1) && ($dir_given == 1)){
        my %TEMP_SUBCKT_PORT_DATA_HASH = ();
        my @all_Ports_of_subckt_new = ();
        if( -d $path_of_the_dir){
          my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
          foreach my $fileName (@spifiles){
            if($fileName eq "."|| $fileName eq ".."){next;}
            chomp($fileName);
            my $temp_file = $fileName;
            $temp_file =~ s/.*\///;
            $temp_file =~ s/\..*//;
            if($temp_file =~ /\b$cell\b/){
              my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
              @{$TEMP_SUBCKT_PORT_DATA_HASH{$cell}} = @all_Ports_of_subckt_from_file;
            }
          }#foreach
        }#if dir path exists
        if(exists $TEMP_SUBCKT_PORT_DATA_HASH{$cell}){
          my @port_list = @{$TEMP_SUBCKT_PORT_DATA_HASH{$cell}}; 
          my ($UNMATCHED_PORT_OF_VERILOG,$UNMATCHED_PORT_OF_SUBCKT) = &check_port_from_spice_file($inst,$cell,$connLine,\@port_list);
          my %NEW_UNMATCHED_PORT_OF_VERILOG = %$UNMATCHED_PORT_OF_VERILOG;
          my %NEW_UNMATCHED_PORT_OF_SUBCKT = %$UNMATCHED_PORT_OF_SUBCKT;
          foreach my $inst (keys %NEW_UNMATCHED_PORT_OF_VERILOG){
            my @unmatched_portList =  @{$NEW_UNMATCHED_PORT_OF_VERILOG{$inst}};
            print "ERR : @unmatched_portList this port does not exists in spice file of this cell $cell\n"if($#unmatched_portList == 0); 
            print "ERR : @unmatched_portList these ports do not exists in spice file of this cell $cell\n"if($#unmatched_portList > 0); 
          }#foreach
          foreach my $inst (keys %NEW_UNMATCHED_PORT_OF_SUBCKT){
            my @unmatched_portList = @{$NEW_UNMATCHED_PORT_OF_SUBCKT{$inst}};
            print "ERR : @unmatched_portList port is unconnected of this cell $cell and inst is $inst\n"if($#unmatched_portList == 0); 
            print "ERR : @unmatched_portList ports are unconnected of this cell $cell and inst is $inst\n"if($#unmatched_portList > 0); 
          }#foreach
          if(@port_list != 0){
            my @nets = split(/\s*\)\s*\,\s*/, $connLine);
            my $noOfPins = @nets;
            my $cnt = 0;
            foreach my $pinName (@port_list){
              for(my $i = 1 ; $i < $noOfPins ; $i++){
                $nets[$i] =~ s/\s*\(\s*/\|/;
                $nets[$i] =~ s/\s*\)\s*//;
                my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
                $pin =~ s/\.//;
                if ($pin eq $pinName){
                  $netNameExpr = $net;
                  $netNameExpr =~ s/^\s+//;
                  $netNameExpr =~ s/\s+$//;
                  if ( $netNameExpr =~ /\{.*\}/ ) {
                    $netNameExpr =~ s/\{/ /g;
                    $netNameExpr =~ s/\}/ /g;
                    $netNameExpr =~ s/\,/ /g;
                    $netNameExpr =~ s/^\s+//;
                    $netNameExpr =~ s/\s+$//;
                    my @netNameExprList = (split(/\s+/,$netNameExpr));
                    foreach my $netName (@netNameExprList){
                      if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                        $netName =~ s/\s+//g;
                        $netName =~ s/\s+$//g;
                        $netName =~ s/\[/$get_opening_bracket/;
                        $netName =~ s/\]/$get_closing_bracket/;
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                        }
                        $cnt++;
                      }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                        $netName =~ s/\s+//g;
                        $netName =~ s/\s+$//g;
                        $netName =~ s/\[/$get_opening_bracket/;
                        $netName =~ s/\]/$get_closing_bracket/;
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                        }
                        $cnt++;
                      }elsif($netName =~ /\s*1'b0\s*/){
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                        }
                        $cnt++;
                      }elsif($netName =~ /\s*1'b1\s*/){
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                        }
                        $cnt++;
                      }else { 
                        if($cnt == 8){
                          push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                          $cnt = 0;
                        }else {
                          push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                        }
                        $cnt++;
                     }
                   }#foreach
                 }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/ ) {
                   $netNameExpr =~ s/\s+//g;
                   $netNameExpr =~ s/\s+$//g;
                   $netNameExpr =~ s/\[/$get_opening_bracket/;
                   $netNameExpr =~ s/\]/$get_closing_bracket/;
                   if($cnt == 8){
                     push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                     $cnt = 0;
                   }else {
                     push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                   }
                   $cnt++;
                }elsif ($netNameExpr =~ /\[\s*[0-9]+\s*\]/ ) {
                  $netNameExpr =~ s/\s+//g;
                  $netNameExpr =~ s/\s+$//g;
                  $netNameExpr =~ s/\[/$get_opening_bracket/;
                  $netNameExpr =~ s/\]/$get_closing_bracket/;
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                  }
                  $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else{
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $net"); 
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},$net); 
                  }
                  $cnt++;
                }
              }
              push(@all_Ports_of_subckt_new,$pinName);
              }
            }#for
          }#foreach
        } 
        @{$SUBCKT_PORT_DATA{$cell}} = @all_Ports_of_subckt_new;
      }else {print "WARN : $cell does not exists in anywhere\n";}
    }#if spiceOrder
   }#elsif
   $inst_cnt++;
  }#foreach connLine
#---------------------------------------------------------------------------------------------------------#
  foreach my $subckt (keys %INST_NAME_HASH){
    if(exists $SUBCKT_PORT_DATA{$subckt}){
      my @inst_list = @{$INST_NAME_HASH{$subckt}}; 
      foreach my $inst_Name (@inst_list){
        print $write_fh "x_$inst_Name "; 
        if(exists $NET_LIST_HASH{$subckt}{$inst_Name}){
          my @net_list = @{$NET_LIST_HASH{$subckt}{$inst_Name}};
          print $write_fh "@net_list $subckt\n";
        }#if exists  
      }#foreach
    }#if exists 
  }#foreach
  print $write_fh ".ends $moduleName\n"if(@allPorts_for_top != "");
  print $write_fh "\n"if(@allPorts_for_top != "");
  if(($spiceOrder == 1 ) && ($complete_spice == 1 )){
    foreach my $subckt (keys %SUBCKT_PORT_DATA){
      #print $write_fh ".subckt $subckt ";
      my @all_Ports_of_subckt = @{$SUBCKT_PORT_DATA{$subckt}};
      #print $write_fh "@all_Ports_of_subckt\n";
      my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
      foreach my $fileName (@spifiles){
        if($fileName eq "." || $fileName eq ".."){next;}
        chomp($fileName);
        my $temp_file = $fileName;
        $temp_file =~ s/.*\///;
        $temp_file =~ s/\..*//;
        if($temp_file =~ /\b$subckt\b/){
          my $include_found = &check_include_found_from_sp($fileName); 
          if($include_found == 1){
            my $temp_output_file = &include_spi($fileName);
            &write_sp_data($temp_output_file,$write_fh);
          }else{
            &write_sp_data($fileName,$write_fh);
          }
        }
      }#foreach
#      print $write_fh ".ends $subckt\n";
      print $write_fh "\n";
    }#foreach subckt
  }#if complete_spice
}#foreach moduleName
  #if(($spiceOrder == 1 ) && ($complete_spice == 1 )){
  #  foreach my $subckt (keys %SUBCKT_PORT_DATA){
  #    #print $write_fh ".subckt $subckt ";
  #    my @all_Ports_of_subckt = @{$SUBCKT_PORT_DATA{$subckt}};
  #    #print $write_fh "@all_Ports_of_subckt\n";
  #    my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
  #    foreach my $fileName (@spifiles){
  #      if($fileName eq "." || $fileName eq ".."){next;}
  #      chomp($fileName);
  #      my $temp_file = $fileName;
  #      $temp_file =~ s/.*\///;
  #      $temp_file =~ s/\..*//;
  #      if($temp_file =~ /\b$subckt\b/){
  #        my $include_found = &check_include_found_from_sp($fileName); 
  #        if($include_found == 1){
  #          my $temp_output_file = &include_spi($fileName);
  #          &write_sp_data($temp_output_file,$write_fh);
  #        }else{
  #          &write_sp_data($fileName,$write_fh);
  #        }
  #      }
  #    }#foreach
# #     print $write_fh ".ends $subckt\n";
  #    print $write_fh "\n";
  #  }#foreach subckt
  #}#if complete_spice
  close($write_fh);
}#else
}#sub verilog_to_spice
#--------------------------------------------------------------------------------------------#
sub read_spice_new {
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : read_spice_new\n";
                                        print "      : -sp <inputspicefile>\n";
                                       }
else {
my $INPUT_SPICE_FILE = "";
#%MODULE_ALREADY = ();
my $moduleName = "";
my %MODULE_PORT_DATA = ();
my %MODULE_INST_DATA = ();
my %MODULE_NET_DATA = ();
my %MODULE_SPICE_PARAMETER_DATA = ();
my %MODULE_SPICE_TRANS_DATA = ();
  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] eq "-sp"){$INPUT_SPICE_FILE = $_[$i+1];}
  }#for
if(( -e $INPUT_SPICE_FILE) && (-r $INPUT_SPICE_FILE)){
  print "INFO : 001 : $INPUT_SPICE_FILE FILE EXISTS AND IS READABLE!\n";
  open(READ_SP,"$INPUT_SPICE_FILE");
  my $previous_line = "";
  my $next_line = "";
  while(<READ_SP>){
  chomp ($_);
  if($_ =~ /\*/){next;}
  if($_ =~ /^$/){next;}
  if($_ =~ /^\+/){
    s/\s+$//;
    s/^\+\s*//;
    $previous_line = $previous_line." ".$_;
    next;
  }
  $next_line = $_;
  if($previous_line =~ /^\s*\.\bsubckt\b/i){
    $previous_line =~ s/^\s*\.(subckt|SUBCKT)\s*//;
    my @module_port_data = (split(/\s+/,$previous_line));
    $moduleName = shift (@module_port_data);
    if(exists $MODULE_PORT_DATA{$moduleName}){
       my @temp_val = @{$MODULE_PORT_DATA{$moduleName}};
      delete $MODULE_PORT_DATA{$moduleName};
       push(@{$MODULE_PORT_DATA{$moduleName}},@module_port_data,@temp_val);
    }else {
      push(@{$MODULE_PORT_DATA{$moduleName}},@module_port_data);
    }
    if ( exists $MODULE_ALREADY{$moduleName} ) {
      my $class = $MODULE_ALREADY{$moduleName}->dbVNOMGetClass; 
      if($class == 11){
        $MODULE_ALREADY{$moduleName}->dbVNOMSetClass(0);
      }
    } else {
      $MODULE_ALREADY{$moduleName} = VNOM::new();
    }
    my %port_data_hash = &check_port_width($moduleName,\@module_port_data);
    foreach my $portName (keys %port_data_hash){
      my ($pinToFrom,$pinType) = (split (/\s+/,$port_data_hash{$portName}));
      $MODULE_ALREADY{$moduleName}->dbVNOMAddBidi($portName);
      $MODULE_ALREADY{$moduleName}->dbVNOMSetBidiType($portName,$pinType);
      $MODULE_ALREADY{$moduleName}->dbVNOMSetBidiBits($portName,$pinToFrom);
    }
  }else {
    if($previous_line =~ /^\s*\.(end|END)\s*/i){
    }else {
      if($previous_line=~ /^\s*m\s*/i){
        $previous_line =~ s/\s+=\s+/=/; 
        my $cellref;
        my @data_list = (split(/\s+/,$previous_line)); 
        my $inst_Name = (split(/\s+/,$previous_line))[0];
        push(@{$MODULE_INST_DATA{$moduleName}},$inst_Name);
        my $trans_data;
        my $cellref;
        $trans_data = $previous_line;
        $trans_data =~ s/$inst_Name\s+//;
        $MODULE_SPICE_TRANS_DATA{$inst_Name} = $trans_data;
        #$previous_line =~ s/$instName\s*//;
        my $cellref_set = 0; 
        for(my $i=0; $i<=$#data_list;$i++){
          if($data_list[$i] =~ m/=/){
            $cellref = $data_list[$i-1];
            $cellref_set = 1;
            last;
          }else{
            #push(@{$MODULE_NET_DATA{$moduleName}{$inst_Name}},$data_list[$i]);
          }
        }#for
        $cellref = $data_list[-1] if($cellref_set == 0);
        my $temp_previous_line;
        $temp_previous_line = $previous_line;
        $temp_previous_line =~ s/\b$inst_Name\b\s+//; 
        $temp_previous_line =~ s/\b$cellref\b.*//; 
        $temp_previous_line =~ s/\s+$//; 
        my @temp_data = (split(/\s+/,$temp_previous_line));
        push(@{$MODULE_NET_DATA{$moduleName}{$inst_Name}},@temp_data);
        #------------------------------------------------------------------------------------------#
        if(exists $MODULE_ALREADY{$cellref}){
          $MODULE_ALREADY{$cellref}->dbVNOMAddParent($moduleName);
          $MODULE_ALREADY{$moduleName}->dbVNOMAddHierInst($inst_Name);
          $MODULE_ALREADY{$moduleName}->dbVNOMSetHierInstCell($inst_Name,$cellref);
        }else {
          $MODULE_ALREADY{$moduleName}->dbVNOMAddHierInst($inst_Name);
          $MODULE_ALREADY{$moduleName}->dbVNOMSetHierInstCell($inst_Name,$cellref);
          $MODULE_ALREADY{$cellref}= VNOM::new();
          $MODULE_ALREADY{$cellref}->dbVNOMAddParent($moduleName);
          $MODULE_ALREADY{$cellref}->dbVNOMSetClass(11);
       }
       #--------------------------------------------------temp port---------------------------------#
         my @temp_port_list = ();
         for(my $i=0;$i<=$#data_list;$i++){
           if($data_list[$i] =~ m/=/){
             my ($port,$value) = (split(/=/,$data_list[$i]))[0,1];
             my $new_portName = "_"."temp"."_"."slvr"."_".$port; 
             push(@temp_port_list,$new_portName);
             my $new_value; 
             if($value =~ /^(\d+)(\.\d+)/){
               $new_value = $value; 
             }elsif($value =~ /^(\d+u)|^(\d+$)/){
               $new_value = $value; 
             }elsif($value =~ /(\d+.\d+)e/i){
               $new_value = $value; 
             }elsif($value =~ /(\d+)e/i){
               $new_value = $value; 
             }else {
               $new_value = "_"."temp"."_"."slvr"."_".$value; 
             }
             $MODULE_ALREADY{$cellref}->dbVNOMAddBidi($new_portName); 
             $MODULE_ALREADY{$cellref}->dbVNOMSetBidiType($new_portName,0); 
             $MODULE_ALREADY{$cellref}->dbVNOMSetBidiBits($new_portName,1); 
             push(@{$MODULE_NET_DATA{$moduleName}{$inst_Name}},$new_value);
           }
         }#for
         push(@{$MODULE_PORT_DATA{$cellref}},@temp_port_list);
         push(@{$MODULE_NET_DATA{$moduleName}{$inst_Name}},$cellref);
        #--------------------------------------------------------------------------------------------#
      }else {
        if($previous_line =~ /^\s*x\s*/i){
         $previous_line =~ s/\s+=\s+/=/;
         $previous_line =~ s/=\s+/=/ if($previous_line =~ /=\s+/);
         my $cellref;
         my $instName;
         my @data_list = (split(/\s+/,$previous_line));
         $instName = (split(/\s+/,$previous_line))[0];
         #$instName =~ s/(X|x)//;
         push(@{$MODULE_INST_DATA{$moduleName}},$instName);
         my $cellref_set = 0;
         for(my $i=0; $i<=$#data_list; $i++){
           if($data_list[$i] =~ m/=/){
              $cellref = $data_list[$i-1];
              $cellref_set = 1;
              last;
           }else {
               #push(@{$MODULE_NET_DATA{$moduleName}{$instName}},$data_list[$i]);
           }
         }#for
         $cellref = $data_list[-1] if($cellref_set == 0);
         my $temp_previous_line_parameter = $previous_line;
         $temp_previous_line_parameter =~ s/.*\b$cellref\b\s+//;
         $temp_previous_line_parameter =~ s/\s+$//;
         push(@{$MODULE_SPICE_PARAMETER_DATA{$moduleName}{$instName}},$temp_previous_line_parameter);
         #-----------------------------------------------------------------------------------------#
         my $temp_previous_line = $previous_line; 
         $temp_previous_line =~ s/\b$instName\b\s+//;
         $temp_previous_line =~ s/\b$cellref\b.*//;
         $temp_previous_line =~ s/\s+$//;
         my @temp_data = (split(/\s+/,$temp_previous_line));
         push(@{$MODULE_NET_DATA{$moduleName}{$instName}},@temp_data);
         #-----------------------------------------------------------------------------------------#
         if(exists $MODULE_ALREADY{$cellref}){
           $MODULE_ALREADY{$cellref}->dbVNOMAddParent($moduleName);
           $MODULE_ALREADY{$moduleName}->dbVNOMAddHierInst($instName);
           $MODULE_ALREADY{$moduleName}->dbVNOMSetHierInstCell($instName,$cellref);
         }else {
           $MODULE_ALREADY{$moduleName}->dbVNOMAddHierInst($instName);
           $MODULE_ALREADY{$moduleName}->dbVNOMSetHierInstCell($instName,$cellref);
           $MODULE_ALREADY{$cellref}= VNOM::new();
           $MODULE_ALREADY{$cellref}->dbVNOMAddParent($moduleName);
           $MODULE_ALREADY{$cellref}->dbVNOMSetClass(11);
         }
         #--------------------------------------temp port------------------------------------------#
         my @temp_port_list = ();
         for(my $i=0;$i<=$#data_list;$i++){
           if($data_list[$i] =~ m/=/){
             my ($port,$value) = (split(/=/,$data_list[$i]))[0,1];
             my $new_portName = "_"."temp"."_"."slvr"."_".$port; 
             push (@temp_port_list,$new_portName);
             my $new_value;
             if($value =~ /^(\d+)(\.\d+)/){
               $new_value = $value;
             }elsif($value =~ /^(\d+u)|^(\d+$)/){
               $new_value = $value; 
             }elsif($value =~ /(\d+.\d+)e/i){
               $new_value = $value; 
             }elsif($value =~ /(\d+)e/i){
               $new_value = $value; 
             }else {
               $new_value = "_"."temp"."_"."slvr"."_".$value; 
             }
               $MODULE_ALREADY{$cellref}->dbVNOMAddBidi($new_portName); 
               $MODULE_ALREADY{$cellref}->dbVNOMSetBidiType($new_portName,0); 
               $MODULE_ALREADY{$cellref}->dbVNOMSetBidiBits($new_portName,1); 
             push(@{$MODULE_NET_DATA{$moduleName}{$instName}},$new_value);
           }
         }#for
         push(@{$MODULE_NET_DATA{$moduleName}{$instName}},$cellref);
         push(@{$MODULE_PORT_DATA{$cellref}},@temp_port_list);
         #------------------------------------------------------------------------------------------------------------------------#
        }#if previous line
      }
    }
  }#else
  $previous_line = $next_line;
  }#while
#-------------------------------------------------------creating conns line-------------------------------------------------------#
foreach my $mod (keys %MODULE_INST_DATA){
  my @inst_list = @{$MODULE_INST_DATA{$mod}};
  foreach my $inst (@inst_list){
    if(exists $MODULE_NET_DATA{$mod}{$inst}){
      my @net_list = @{$MODULE_NET_DATA{$mod}{$inst}};
      my $cellref = pop(@net_list);
      my $cnt = 0;
      my @port_list = @{$MODULE_PORT_DATA{$cellref}};
      if($port_list[0] =~ /_temp_slvr_/){
        #foreach my $netName(@net_list){
        for(my $i=0;$i<=3;$i++){
          my $netName = $net_list[$i]; 
          #if($netName !~ /(_temp_slvr_|^\d+)/){
            my $create_port = "p".$cnt ;
            unshift(@port_list,$create_port);
            $cnt++;
            $MODULE_ALREADY{$cellref}->dbVNOMAddBidi($create_port); 
            $MODULE_ALREADY{$cellref}->dbVNOMSetBidiType($create_port,0); 
            $MODULE_ALREADY{$cellref}->dbVNOMSetBidiBits($create_port,1); 
          #}
        }
      }
      my $connLine = &create_conns_line_from_given_input($cellref,$inst,\@port_list,\@net_list);
      $MODULE_ALREADY{$mod}->dbVNOMAddConn($connLine);
      $MODULE_ALREADY{$mod}->dbVNOMAddSpiceParameter($inst);
      $MODULE_ALREADY{$mod}->dbVNOMSetSpiceParameterType($inst,3);
      my @spice_parameter_data = @{$MODULE_SPICE_PARAMETER_DATA{$mod}{$inst}};
      foreach my $sp_param_data (@spice_parameter_data){
        $MODULE_ALREADY{$mod}->dbVNOMSetSpiceParameterValue($inst,$sp_param_data);
      }#foreach
    }#if exists inst
  }#foreach inst
}#foreach mod
#------------------------------------------------------------------------------------------------------------------------------------#
##################################################################################################
####    finding the top module                                                                ####
##################################################################################################
my @TOP = ();
foreach my $mod (keys %MODULE_ALREADY) { 
  my @parents =  $MODULE_ALREADY{$mod}->dbVNOMGetParent;
  my $np = @parents;
  if ( $np == 0 ) { push(@TOP,$mod); }
  elsif ( $np > 1 ) { print "INFO : $mod has $np parents \n"; }
}#foreach my $mod
my $nT = @TOP;
if ( $nT == 1 ) { print "INFO : Setting top module as $TOP[0]\n"; 
                  $CURRENT_MODULE = $TOP[0];
                  $TOP_MODULE = $TOP[0];
		  $GLOBAL->dbfGlobalSetTOP($TOP_MODULE);
                }
elsif ( $nT > 1 ) { print "WARN : there are more than 1 possible top modules, please pick the correct one from the list below\n";
                    print join ",", @TOP; #print "\n";
                  }
else { print "ERROR : something is wrong with the spice file\n"; }

#-----------------------------------------------------------------------------------------------------------------------#
}else {
  print "WARN : $INPUT_SPICE_FILE FILE DOES NOT EXISTS OR IS NOT READABLE.\n";
}
}#else
}#sub read_spice_new
#-----------------------------------------------------------------------------------------------------------------------#
sub create_conns_line_from_given_input {
  my $cellName = $_[0];
  my $instName = $_[1];
  my @port_list = @{$_[2]};
  my @net_list = @{$_[3]};
  my %INST_CONN = ();
  my $connLine = "";
  my $number_of_port_list = @port_list;
  my $number_of_net_list = @net_list;
  #if($number_of_port_list == $number_of_net_list){
    if($#port_list <= -1){
      for (my $i=0;$i<=$#net_list;$i++){
        my $portName = "p"."".$i;    
        my $netName = $net_list[$i];
        my $tempconn = ".".$portName."(".$netName.")";
        push(@{$INST_CONN{$instName}},$tempconn);
      }#for    
    }else {
      for (my $i=0;$i<=$#net_list;$i++){
        if($port_list[0] !~ /_temp_slvr_/){ 
          my $portName = $port_list[$i];    
          my $netName = $net_list[$i];
          my $tempconn = ".".$portName."(".$netName.")";
          push(@{$INST_CONN{$instName}},$tempconn);
        }else {
          if($net_list[$i] !~ /(_temp_slvr_|^\d+)/){
            my $portName = "p"."".$i; 
            #my $portName = $port_list[$i]; 
            my $netName = $net_list[$i];
            my $tempconn = ".".$portName."(".$netName.")";
            push(@{$INST_CONN{$instName}},$tempconn);
          }
        }
      }#for    
    }#else
  #}#if
  foreach my $inst(keys %INST_CONN){
    my @conn = @{$INST_CONN{$inst}};
    my $temp_conn_str = join ", ",@conn;
    if($inst eq $instName){
      $connLine = $cellName." ".$instName." (".$temp_conn_str .");";  
      return ($connLine);
    }
  }
}#sub create_conns_line_from_given_input
#-----------------------------------------------------------------------------------------------------------------------#
sub find_port_list {
my $fileName = $_[0];
open (READ_FILE,"$fileName");
my $previous_line = "";
my $next_line = "";
my @module_port_data = ();
while(<READ_FILE>){
  chomp($_);
  if($_ =~ /\*/){next;}
  if($_ =~ /^$/){next;}
  if($_ =~ /^\+/){
    s/\s+$//;
    s/^\+//;
    $previous_line = $previous_line." ".$_;
    next;
  }
  $next_line = $_;
  if($previous_line =~ /^\s*\.subckt/i){
    $previous_line =~ s/^\s*\.(subckt|SUBCKT)\s*//;
    @module_port_data = (split(/\s+/,$previous_line));
    shift (@module_port_data);
  }else {
    if($previous_line =~ /^\s*\.(end|END)\s*/i){
    }else{
      if($previous_line =~ /^\s*m\s*/i){
      }else {
        if($previous_line =~ /^\s*x\s*/i){
        }
      }#else
    }#else 
  }#else
  $previous_line = $next_line;
}#while
close(READ_FILE);
return (@module_port_data);
}#sub find_port_list
#-----------------------------------------------------------------------------------------------------------------------#
sub check_port_from_spice_file {
  my $inst = $_[0]; 
  my $cell = $_[1];
  my $connLine = $_[2];
  my @port_list_from_subckt = @{$_[3]};
  my %UNMATCHED_PORT_OF_VERILOG = ();
  my %UNMATCHED_PORT_OF_SUBCKT = ();
  my @nets = split(/\s*\)\s*\,\s*/, $connLine);
  my $noOfPins = @nets;
  my %PORT_FROM_SUBCKT = ();
  my %PORT_FROM_CONN = ();
  for(my $i = 1 ; $i < $noOfPins ; $i++){
    $nets[$i] =~ s/\s*\(\s*/\|/;
    $nets[$i] =~ s/\s*\)\s*//;
    my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
    $pin =~ s/\.//;
    push(@{$PORT_FROM_CONN{$inst}{$cell}},$pin);
  }#for
  foreach my $inst (keys %PORT_FROM_CONN){
    my %matched_port_frm_conn = ();
    my %unmatched_port_frm_conn = ();
    my %matched_port_frm_subckt = ();
    my %unmatched_port_frm_subckt = ();
    foreach my $cellName (keys %{$PORT_FROM_CONN{$inst}}){
      my @port_list_from_conn = @{$PORT_FROM_CONN{$inst}{$cellName}};
      foreach my $portName_frm_conn (@port_list_from_conn){
        foreach my $portName_frm_subckt (@port_list_from_subckt){
          $portName_frm_subckt =~ s/.*_temp_slvr_//;
          if($portName_frm_conn eq $portName_frm_subckt){
            $matched_port_frm_conn{$portName_frm_conn} = 1;
            $matched_port_frm_subckt{$portName_frm_subckt} = 1;
          }else{
            $unmatched_port_frm_conn{$portName_frm_conn} = 1;
            $unmatched_port_frm_subckt{$portName_frm_subckt} = 1;
          }
        }#foreach
      }#foreach
    }#foreach
    foreach my $port (keys %unmatched_port_frm_conn){
      if(!exists $matched_port_frm_conn{$port}){
        push (@{$UNMATCHED_PORT_OF_VERILOG{$inst}},$port);
      }#if exists
    }#foreach
    foreach my $port (keys %unmatched_port_frm_subckt){
      if(!exists $matched_port_frm_subckt{$port}){
          push (@{$UNMATCHED_PORT_OF_SUBCKT{$inst}},$port);
      }#if exists
    }#foreach
  }#foreach
return (\%UNMATCHED_PORT_OF_VERILOG ,\%UNMATCHED_PORT_OF_SUBCKT);
}#sub check_port_from_spice_file
#-----------------------------------------------------------------------------------------------------------------------#
sub include_spi {
  my $spFile = $_[0];
  my @dir_path = split(/\//,$spFile);
  my $sp_file_name = pop @dir_path;
  my $in_file_dir = join "/", @dir_path if(@dir_path > 0); 
  my $out_file = &write_complete_sp_data($spFile, $in_file_dir, $sp_file_name, 0);
  return($out_file); 
}#sub include_spi
#-----------------------------------------------------------------------------------------------------------------------#
sub write_complete_sp_data {
my $in_file = $_[0];
my $dir_path = $_[1];
my $out_file = $_[2];
my $count = $_[3];
my $hier = 0;
my $read_fh;
my $write_fh;
open($read_fh,"$in_file");
open($write_fh,">$out_file$count");
while(<$read_fh>){
  chomp();
  if($_ =~ /^\s*\.include\s+/){
     my $include_file = (split(/\s+/,$_))[1];
     $include_file =~ s/\"//g;
     $include_file = $dir_path."/".$include_file if($dir_path ne "");
     if(-e $include_file){
           my $next_has_include = &write_sp_data_of_include($write_fh, $include_file);
           if($next_has_include == 1){
              $hier = 1;
           }
     }else{
        print "WARN : file  $include_file does not exists\n";
     }
  }else{
     print $write_fh "$_\n";
  }
}#while
close $write_fh;
close $read_fh;
if($hier > 0){
   &write_complete_sp_data($out_file.$count, $dir_path, $out_file, $count+1);
}else{
   system("cp $out_file$count $out_file-include.sp");
   return( $out_file."-include.sp");
}
}#sub write_complete_sp_data
#-----------------------------------------------------------------------------------------------------------------------#
sub write_sp_data_of_include {
 my $file_handle = $_[0];
 my $data_file = $_[1];
 my $has_include = 0;
 my $read_fh;
 open($read_fh, $data_file);
 while(<$read_fh>){
   chomp();
   if($_ =~ /^\s*\.include\s+/){
      $has_include = 1;
   }
   print $file_handle "$_\n";
 }#while
 close $read_fh;
 return $has_include;
}#sub write_sp_data_of_include
#-----------------------------------------------------------------------------------------------------------------------#
sub check_include_found_from_sp {
  my $file = $_[0];
  my $read_fh;
  my $include_found = 0;
  open($read_fh,$file);
  while(<$read_fh>){
    chomp();
    if($_ =~ /^\s*\.include\s+/){
      $include_found = 1;
    }
  }#while
  close ($read_fh);
  return($include_found);
}#sub check_include_found_from_sp
#-----------------------------------------------------------------------------------------------------------------------#
sub write_sp_data {
  my $file_handle = $_[0];
  my $in_unit = $_[1];
  my $out_unit = $_[2];
  my $global_change_pin_vss_to_gnd = $_[3];
  my $module = $_[4];
  my $vector_bit_blast = $_[5];
  my @bidiport = $MODULE_ALREADY{$module}->dbVNOMGetBidi;
  my $new_port_list = &get_port_order_for_write_sp_data(\@bidiport,$module,$global_change_pin_vss_to_gnd,$vector_bit_blast);
  my @mod_port_list = @$new_port_list;
  print $file_handle ".subckt $module @mod_port_list\n"; 
  my @conns = $MODULE_ALREADY{$module}->dbVNOMGetConn;
  foreach my $connLine (@conns){
    $connLine =~ s/\(/\)\,/;
    $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
    my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
    print $file_handle "$inst ";
    my @nets = split(/\s*\)\s*\,\s*/, $connLine);
    my $noOfPins = @nets;
    my @net_list = ();
    my @net_list_with_pin = ();
    for(my $i = 1 ; $i < $noOfPins ; $i++){
      $nets[$i] =~ s/\s*\(\s*/\|/;
      $nets[$i] =~ s/\s*\)\s*//;
      my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
      $pin =~ s/\.//;
      if($pin =~ /_temp_slvr_/){
         $pin =~ s/_temp_slvr_//; 
         if($net =~ /(\d+.\d+)u$/i){
           if($in_unit eq "micron"){
             if($out_unit eq "micron"){
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }else {
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }
           }elsif($in_unit eq "meter"){
             if($out_unit eq "meter"){
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }else{
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }
           }
         }elsif($net =~ /(\d+)u$/i){
           if($in_unit eq "micron"){
             if($out_unit eq "micron"){
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }else {
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }
           }elsif($in_unit eq "meter"){
             if($out_unit eq "meter"){
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }else{
               $net =~ s/u|U//;
               my $new_var = $net;
               push(@net_list_with_pin,"$pin=$new_var") ;
             }
           }
         }elsif($net =~ /(\d+.\d+)e-/i){
          my ($digit,$exp) = (split(/e-/,$net))[0,1];
          if($in_unit eq "micron"){
            if($out_unit eq "micron"){
              my $new_var = $net;
              push(@net_list_with_pin,"$pin=$new_var") ;
            }else {
              my $new_exp = $exp+06;
              my $new_var = $digit."e-".$new_exp;
              push(@net_list_with_pin,"$pin=$new_var") ;
            }
          }elsif($in_unit eq "meter"){
            if($out_unit eq "micron"){
              my $new_exp = "-$exp"+06;
              my $new_var = $digit."e".$new_exp;
              push(@net_list_with_pin,"$pin=$new_var") ;
            }else {
              my $new_var = $net;
              push(@net_list_with_pin,"$pin=$new_var") ;
            }
          }
          }elsif($net =~ /(\d+)e-/i){
            my ($digit,$exp) = (split(/e-/,$net))[0,1];
            if($in_unit eq "micron"){
              if($out_unit eq "micron"){
                my $new_var = $net;
                push(@net_list_with_pin,"$pin=$new_var") ;
              }else {
                my $new_exp = $exp+06;
                my $new_var = $digit."e-".$new_exp;
                push(@net_list_with_pin,"$pin=$new_var") ;
              }
            }elsif($in_unit eq "meter"){
              if($out_unit eq "micron"){
                my $new_exp = "-$exp"+06;
                my $new_var = $digit."e".$new_exp;
                push(@net_list_with_pin,"$pin=$new_var") ;
              }else {
                my $new_var = $net;
                push(@net_list_with_pin,"$pin=$new_var") ;
              }
            }
          }else{
            push(@net_list_with_pin,"$pin=$net") ;
          } 
        }else{
          if($net =~ /vss/i){
            push(@net_list,"GND");
          }else {
            push(@net_list,$net);
          }
        }
    }#for
    print $file_handle "@net_list $cell @net_list_with_pin\n";
  }#foreach
  print $file_handle ".ends\n";
}#sub write_sp_data
#-----------------------------------------------------------------------------------------------------------------------#
sub get_port_order_for_write_sp_data {
my @bidiPorts = @{$_[0]};
my $moduleName = $_[1];
my $global_change_pin_vss_to_gnd = $_[2];
my $vector_bit_blast = $_[3];
my @allPorts_for_top = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
foreach my $i (@bidiPorts ) { 
  my $busWidth = "";
  my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($i);
  if ( $type == 1 ) {
    $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($i); 
    $busWidth =~ s/\[/[/;
    $busWidth =~ s/\]/]/;
  }
    if ( $i =~ /\\/ ){$i = $i." "}; 
    if($i =~ /_temp_slvr_/){
      push(@allPorts_for_top,$i."".$busWidth) if ($i !~ /^_temp_slvr_/);
    }else {
      if($portcnt == 8){
        push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
        $portcnt = 0;
      }else {
        push ( @allPorts_for_top,$i."".$busWidth); 
      }
    }
    $portcnt++;
}#foreach bidi
my @sort_port = sort {$a cmp $b} @allPorts_for_top;
my @new_port_list = ();
my $sp_portcnt = 0;
foreach my $port (@sort_port){
  my $new_port = "";
  #$port =~ s/\[.*//;
  if($global_change_pin_vss_to_gnd == 1){
    if($port =~ /vss/i){$new_port = "GND";}
      else {$new_port = $port;}
    }else {
      $new_port = $port;
    } 
    if($vector_bit_blast == 1){
      $new_port =~ s/\[.*//;
      my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($new_port);
      my $busWidth = "";
      $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($new_port) if ($type == 1);
      my %PORT_BIT_BLAST = &get_vector_bit_blast($new_port,$busWidth);
      my @port_with_bit_blast = @{$PORT_BIT_BLAST{$new_port}}; 
      foreach my $bit (@port_with_bit_blast){
        $new_port =~ s/.*_temp_slvr_//;
        if($sp_portcnt == 8){
          push (@new_port_list,"\n+",$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@new_port_list,"\n+",$new_port)if($bit eq ""); 
          $sp_portcnt = 0;
        }else {
          push (@new_port_list,$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@new_port_list,$new_port)if($bit eq ""); 
        }
        $sp_portcnt++;
      }#foreach
    }else {
      $new_port =~ s/^\d+_temp_slvr_\s*//;
      $new_port =~ s/\[/</;
      $new_port =~ s/\]/>/;
      if($sp_portcnt == 8){
        push(@new_port_list,"\n+",$new_port);
      }else {
        push(@new_port_list,$new_port);
      }
      $sp_portcnt++;
    }
   }#foreach port
return(\@new_port_list);
}#sub get_port_order_for_write_sp_data
#-----------------------------------------------------------------------------------------------------------------------#
sub check_port_width {
  my $moduleName = $_[0];
  my @module_port_data = @{$_[1]};
  my %port_data_hash = ();
  if(exists $MODULE_ALREADY{$moduleName}){
    my %bit_list_hash_of_port = ();
    my $pcnt = 0;
    foreach my $portName (@module_port_data){
      if($portName =~ /(\[|<)\s*[0-9]+\s*\:\s*[0-9]+\s*(\]|>)/){
        $portName =~ s/\[|</ /;
        $portName =~ s/\]|>/ /;
        $portName =~ s/\:/ /;
        my($port,$from,$to) = (split(/\s+/,$portName))[0,1,2];
        my $pinToFrom = "[".$from.":".$to."]";
        my $new_port =  $pcnt."_"."temp_slvr"."_".$port;
        #$port_data_hash{$port} = $pinToFrom." ".1;
        $port_data_hash{$new_port} = $pinToFrom." ".1;
      }elsif($portName =~ /(\[|<)\s*[0-9]+\s*(\]|>)/){
        $portName =~ s/\[|</ /;
        $portName =~ s/\]|>/ /;
        my ($port,$bit) = (split(/\s+/,$portName))[0,1]; 
        my $new_port =  $pcnt."_"."temp_slvr"."_".$port;
        #push (@{$bit_list_hash_of_port{$port}}, $bit); 
        push (@{$bit_list_hash_of_port{$new_port}}, $bit); 
      }else {
        #$port_data_hash{$portName} = "1 0";
        my $new_port =  $pcnt."_"."temp_slvr"."_".$portName;
        #my $new_port = $pcnt."_".$portName;
        $port_data_hash{$new_port} = "1 0";
      }
       $pcnt++;
    }#foreach
    foreach my $port (keys %bit_list_hash_of_port){
       my @value = @{$bit_list_hash_of_port{$port}};
       @value = sort{$a<=>$b} @value;
       $port_data_hash{$port} = "[$value[0]:$value[-1]] 1";
    }
  }#if exists
  return(%port_data_hash);
}#sub check_port_width
#-----------------------------------------------------------------------------------------------------------------------#
sub bit_list_of_port {
  my $moduleName = $_[0];
  my @module_port_data = @{$_[1]};
  my %bit_list_hash = ();
  if(exists $MODULE_ALREADY{$moduleName}){
    foreach my $portName (@module_port_data){
      if($portName =~ /\[\s*[0-9]+\s*\]/){ 
        $portName =~ s/\[/ /;
        $portName =~ s/\]//;
        my ($port,$bit) = (split(/\s+/,$portName))[0,1]; 
        push(@{$bit_list_hash{$port}},$bit);
      }
    }#foreach
  }#if exists
  return(%bit_list_hash);
}#sub bit_list_of_port
#-----------------------------------------------------------------------------------------------------------------------#
sub write_spice_file_old {
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : write_spice_file_old\n";
                                        print "      : -output<fileName>\n";
                                       }
else {
my $moduleName = $TOP_MODULE;
my $OUTPUT_FILE = "";
my $write_fh;
  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] eq "-output"){$OUTPUT_FILE = $_[$i+1];}
  }#for
  open ($write_fh,">$OUTPUT_FILE");
  my @inPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidi;
  my $portcnt = 0;
  my @allPorts_for_top = ();
  foreach my $i ( @inPorts ) { 
    my $busWidth = "";
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($i);
    if ( $type == 1 ) {
      $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($i); 
      $busWidth =~ s/\[/[/;
      $busWidth =~ s/\]/]/;
    }
    if ( $i =~ /\\/ ){$i = $i." "}; 
    if($portcnt == 8){
      push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
      $portcnt = 0;
    }else {
      push ( @allPorts_for_top, $i."".$busWidth); 
    }
    $portcnt++;
  }#foreach inport
  print $write_fh ".subckt $moduleName ";
  print $write_fh "@allPorts_for_top\n";
  my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
  my %SUBCKT_PORT_DATA = (); 
  my %INST_NAME_HASH = ();
  my %NET_LIST_HASH = ();
  my $inst_cnt = 1;
  foreach my $connLine (@conns){
    $connLine =~ s/\(/\)\,/;
    $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
    my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
    #my $instName = "XX"."_".$inst_cnt."_".$inst;
    my $instName = "X"."".$inst;
    push(@{$INST_NAME_HASH{$cell}},$instName);
    if ($MODULE_ALREADY{$moduleName}->dbVNOMHasHierInst($inst)){ 
      my @allPorts = ();
      my @nets = split(/\s*\)\s*\,\s*/, $connLine);
      my $noOfPins = @nets;
      my $port_cnt = 0;
      my $cnt = 0;
      for(my $i = 1 ; $i < $noOfPins ; $i++){
        $nets[$i] =~ s/\s*\(\s*/\|/;
        $nets[$i] =~ s/\s*\)\s*//;
        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
        $pin =~ s/\.//;
        if ( exists $MODULE_ALREADY{$cell}->{bidis}{$pin} ) {
          my $busWidth = "";
          my $type = $MODULE_ALREADY{$cell}->dbVNOMGetBidiType($pin);
          if ( $type == 1 ) {
            $busWidth = $MODULE_ALREADY{$cell}->dbVNOMGetBidiBits($pin); 
            $busWidth =~ s/\[/$get_opening_bracket/;
            $busWidth =~ s/\]/$get_closing_bracket/;
          }
          if ( $pin =~ /\\/ ){$pin = $pin." "}; 
          if($port_cnt == 8){
            push ( @allPorts, "\n+",$pin."".$busWidth); 
            $port_cnt = 0;
          }else {
            push ( @allPorts, $pin."".$busWidth); 
          }
            $port_cnt++;
        }
        @{$SUBCKT_PORT_DATA{$cell}} = @allPorts;
        $netNameExpr = $net;
        $netNameExpr =~ s/^\s+//;
        $netNameExpr =~ s/\s+$//;
        if($cnt == 8){
          push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
          $cnt = 0;
        }else {
          push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
        }
        $cnt++;
      }#for      
    }#if hier inst or trans
   $inst_cnt++;
  }#foreach connLine
#--------------------------------write .sp for top module------------------------------#
  #my @spice_conn = $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceElementConnection;
  my @trans_list = $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceElementInst;
  foreach my $trans (@trans_list){
    if($trans =~ /vdd|vss/i){next;}
    my $trans_value = $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceElementValue($trans);
    print $write_fh "$trans $trans_value\n";
  }#foreach
  #foreach my $sp_conn (@spice_conn){
  #  print $write_fh "$sp_conn\n";
  #}#foreach
  foreach my $subckt (keys %INST_NAME_HASH){
    #my @spice_conn = $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceElementConnection;
    if(exists $SUBCKT_PORT_DATA{$subckt}){
      my @inst_list = @{$INST_NAME_HASH{$subckt}}; 
      foreach my $inst_Name (@inst_list){
        print $write_fh "$inst_Name "; 
        if(exists $NET_LIST_HASH{$subckt}{$inst_Name}){
          my @net_list = @{$NET_LIST_HASH{$subckt}{$inst_Name}};
          print $write_fh "@net_list $subckt ";
          $inst_Name =~ s/X//;
          my $spice_parameter_type =  $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceParameterType($inst_Name);
          if($spice_parameter_type == 3){
            my @spice_parameter_value = $MODULE_ALREADY{$moduleName}->dbVNOMGetSpiceParameterValue($inst_Name);
            print $write_fh "@spice_parameter_value\n";
          }#if spice parameter type 
        }#if exists  
      }#foreach
    }#if exists 
  }#foreach
  print $write_fh ".ends $moduleName\n";
  print $write_fh "\n";
#----------------------------write .sp for inst cell---------------------------------#
  foreach my $subckt (keys %SUBCKT_PORT_DATA){
    #my @spice_conn = $MODULE_ALREADY{$subckt}->dbVNOMGetSpiceElementConnection;
    my @trans_list = $MODULE_ALREADY{$subckt}->dbVNOMGetSpiceElementInst;
    my @all_Ports_of_subckt = @{$SUBCKT_PORT_DATA{$subckt}};
    print $write_fh ".subckt $subckt ";
    print $write_fh "@all_Ports_of_subckt\n";
    #foreach my $sp_conn (@spice_conn){
    #  print $write_fh "$sp_conn\n";
    #}#foreach
    foreach my $trans (@trans_list){
      if($trans =~ /vdd|vss/i){next;}
      my $trans_value = $MODULE_ALREADY{$subckt}->dbVNOMGetSpiceElementValue($trans);
      print $write_fh "$trans $trans_value\n";
    }#foreach
    print $write_fh ".ends $subckt\n";
    print $write_fh "\n";
  }#foreach subckt
  close($write_fh); 
}#else
}#sub write_spice_file_old
#-----------------------------------------------------------------------------------------------------------------------#
sub creating_spice_hash_for_net_from_spice {
  my $moduleName = $_[0];
  my %SPICE_DATA = ();
  my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
  foreach my $connLine (@conns){
    $connLine =~ s/\(/\)\,/;
    $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
    my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
    my @nets = split(/\s*\)\s*\,\s*/, $connLine);
    my $newdata = "";
    for(my $i=1; $i<=$#nets;$i++){
      $nets[$i] =~ s/\s*\(\s*/\|/;
      $nets[$i] =~ s/\s*\)\s*//;
      my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
      $pin =~ s/\.//;
      if($pin =~ /\s*_temp_slvr_/){next;}
      $newdata = $newdata." ".$net; 
    }#for
      $newdata =~s/^\s*//;
      $SPICE_DATA{$inst} = $newdata;
  }#foreach
 return(%SPICE_DATA);
}#sub creating_spice_hash_for_net_from_spice
  ########################## Making Drain, Source & Gate hashes ############################
sub creating_hash_for_net_from_spice {
  my $moduleName = $_[0];
  my %DRAIN_HASH = ();
  my %GATE_HASH = ();
  my %SOURCE_HASH = ();
  my %NET_HASH = ();
  my %SPICE_DATA = &creating_spice_hash_for_net_from_spice($moduleName);
  foreach my $mdata (keys %SPICE_DATA){
    my $value = $SPICE_DATA{$mdata}; 
    my ($drain,$gate,$source) = (split(/\s+/,$value));
    my @drain_val = ();
    my @gate_val = ();
    my @src_val = ();
    if(exists $DRAIN_HASH{$drain}){
      @drain_val = @{$DRAIN_HASH{$drain}};
      push (@drain_val,$mdata);
    }elsif (exists $DRAIN_HASH{$drain."_"."net"}){
      @drain_val = @{$DRAIN_HASH{$drain."_"."net"}};
      push (@drain_val,$mdata);
    }else{
      if($drain =~ /(vdd|vss)/){
        push(@drain_val,$mdata,$drain);
      }else {
        push(@drain_val,$mdata);
      }
    }
    if($drain =~ /(vdd|vss)/){
      @{$DRAIN_HASH{$drain."_"."net"}} = @drain_val;
    }else{
      @{$DRAIN_HASH{$drain}} = @drain_val;
    }
 #--------------------------------------------------------------------------# 
    if(exists $GATE_HASH{$gate}){
      @gate_val = @{$GATE_HASH{$gate}};
      push (@gate_val,$mdata);
    }else{
      push(@gate_val,$mdata);
    }
    @{$GATE_HASH{$gate}} = @gate_val;
 #--------------------------------------------------------------------------# 
    if(exists $SOURCE_HASH{$source}){
      @src_val = @{$SOURCE_HASH{$source}};
      push (@src_val,$mdata);
    }elsif(exists $SOURCE_HASH{$source."_"."net"}){
      @src_val = @{$SOURCE_HASH{$source."_"."net"}};
      push (@src_val,$mdata);
    }else{
      if($source =~ /(vdd|vss)/){
        push(@src_val,$mdata,$source);
      }else{
        push(@src_val,$mdata);
      }
    }
    if($source =~ /(vdd|vss)/){
      @{$SOURCE_HASH{$source."_"."net"}} = @src_val;
    }else{
      @{$SOURCE_HASH{$source}} = @src_val;
    }
  }#foreach mdata
  #-------------------------------------------------------------------------#
  foreach my $g (keys %GATE_HASH){
    push(@{$NET_HASH{$g}},@{$GATE_HASH{$g}});
  }
  foreach my $d (keys %DRAIN_HASH){
    push(@{$NET_HASH{$d}},@{$DRAIN_HASH{$d}});
  }
  foreach my $s (keys %SOURCE_HASH){
    push(@{$NET_HASH{$s}},@{$SOURCE_HASH{$s}});
  }
  #foreach my $net (keys %NET_HASH){
  #  print "$net => @{$NET_HASH{$net}}\n";
  #}#foreach
  return(%NET_HASH);
}#sub creating_hash_for_net_from_spice
#-----------------------------------------------------------------------------------------------------------------------#

sub get_net_hash{
  my $moduleName = $_[0];
  my %NET_HASH = ();
  my %SPICE_DATA = &creating_spice_hash_for_net_from_spice($moduleName); 
  foreach my $inst (keys %SPICE_DATA){
    my $value = $SPICE_DATA{$inst}; 
    my ($drain,$gate,$source) = (split(/\s+/,$value))[0,1,2];
#-------------------------------------------------------------------------------------------#
      if($drain =~ /(vdd|vss)/i){
        if(exists $NET_HASH{$drain."_"."net"}){
          push(@{$NET_HASH{$drain."_"."net"}},[$inst,"drain"]);
        }else {
          push(@{$NET_HASH{$drain."_"."net"}},[$inst,"drain"],[$drain,"drain"]);
        }
      }else {
        push(@{$NET_HASH{$drain}},[$inst,"drain"]);
      }
#-------------------------------------------------------------------------------------------#      
      push(@{$NET_HASH{$gate}},[$inst,"gate"]);
#-------------------------------------------------------------------------------------------#      
      if($source =~ /(vdd|vss)/i){
        if(exists $NET_HASH{$source."_"."net"}){
          push(@{$NET_HASH{$source."_"."net"}},[$inst,"source"]);
        }else {
          push(@{$NET_HASH{$source."_"."net"}},[$inst,"source"],[$source,"source"]);
        }
      }else{
        push(@{$NET_HASH{$source}},[$inst,"source"]);
      }
#-------------------------------------------------------------------------------------------#
  }#foreach inst
  foreach my $net (keys %NET_HASH){
    #print "$net => @{$NET_HASH{$net}}\n";
    my @net_data =  @{$NET_HASH{$net}};
    foreach my $v (@net_data){
      #print "$net => @$v\n";
    }  
  }#foreach
  return(%NET_HASH);
}#sub get_net_hash
#-----------------------------------------------------------------------------------------------------------------------#
sub write_spice_file {
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : write_spice_file\n";
                                        print "      : -output<fileName>\n";
                                        print "      : -spiceLib<path of the dir|file>\n";
                                        print "      : --complete_spice\n";
                                        print "      : --notWriteEmptyModule\n";
                                        print "      : --vector_bit_blast\n";
                                        print "      : --add_top_instance\n";
                                        print "      : --add_spice_missing_port\n";
                                        print "      : --global_change_pin_vss_to_gnd\n";
                                        print "      : --add_first_blank_line\n";
                                        print "      : --add_global_vdd_and_gnd\n"; 
                                        print "      : --overwrite\n";
                                        print "      : -in_unit<meter/micron>\n";
                                        print "      : -out_unit<meter/micron>\n";
                                       }
else {
my $moduleName = $TOP_MODULE;
my $start_module = $TOP_MODULE;
my $no_of_level = -1;
my $OUTPUT_FILE = "";
my $write_fh;
my $hier = 0;
my $flat = 0;
my $path_of_the_dir = "";
my $complete_spice = 0;
my $no_write_empty_module = 0;
my $vector_bit_blast = 0;
my $add_top_instance = 0;
my $add_spice_missing_port = 0;
my $global_change_pin_vss_to_gnd = 0;
my $add_first_blank_line = 0;
my $add_global_vdd_and_gnd = 0;
my $OVERWRITE = 0;
my $in_unit = "";
my $out_unit = "";

  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] eq "-output"){$OUTPUT_FILE = $_[$i+1];}
    if($_[$i] eq "--hier"){$hier = 1;$flat = 0;}
    if($_[$i] eq "--flat"){$flat = 1;$hier = 0;}
    if($_[$i] eq "-spiceLib"){$path_of_the_dir = $_[$i+1];}
    if($_[$i] eq "--complete_spice"){$complete_spice = 1;}
    if($_[$i] eq "--notWriteEmptyModule"){$no_write_empty_module = 1;} 
    if($_[$i] eq "--vector_bit_blast"){$vector_bit_blast = 1;}
    if($_[$i] eq "--add_top_instance"){$add_top_instance = 1;}
    if($_[$i] eq "--add_spice_missing_port"){$add_spice_missing_port = 1;}
    if($_[$i] eq "--global_change_pin_vss_to_gnd"){$global_change_pin_vss_to_gnd = 1;}
    if($_[$i] eq "--add_first_blank_line"){$add_first_blank_line = 1;}
    if($_[$i] eq "--add_global_vdd_and_gnd"){$add_global_vdd_and_gnd = 1;} 
    if($_[$i] eq "--overwrite"){$OVERWRITE = 1;}
    if($_[$i] eq "-in_unit"){$in_unit = $_[$i+1];}
    if($_[$i] eq "-out_unit"){$out_unit = $_[$i+1];}
  }#for
  if (-e $OUTPUT_FILE) {
    if ($OVERWRITE == 1 ) { 
      print "WARN-TE-WRITE_SPICE_FILE : 001 : $OUTPUT_FILE exists, overwriting existing file as instructed\n";
    }else {
      print "ERR-TE-WRITE_SPICE_FILE : 002 : $OUTPUT_FILE exists, Please change the output name or remove the existing file\n";
      return;
    }
  }# if output file exists
  open ($write_fh,">$OUTPUT_FILE");
  if($flat == 1){
    my @port_temp = ();
    #foreach my $portName (sort {$a cmp $b} keys %{$PORTS_ALREADY{$moduleName}} ) { $portName =~ s/^\d+_//; push(@port_temp,$portName); }
    foreach my $portName (sort {$a cmp $b} keys %{$PORTS_ALREADY{$moduleName}} ) { $portName =~ s/^\d+_temp_slvr_\s*//; push(@port_temp,$portName); }
    print $write_fh ".subckt $moduleName @port_temp\n";
    foreach my $instanceName (keys %COMP_ALREADY){
      my $cellref = $CADB{$instanceName}->dbCadbGetCellref;
      my @net_list = ();
      my @net_list_for_temp_slvr = ();
      my $class;
      if(exists $MODULE_ALREADY{$cellref}){
        $class = $MODULE_ALREADY{$cellref}->dbVNOMGetClass;
      }
      if($class == 11){
        my $new_inst;
        foreach my $pinName (sort {$b cmp $a } keys %{$COMP_ALREADY{$instanceName}}){
          my $netName = $COMP_ALREADY{$instanceName}{$pinName};
          if($pinName =~ /_temp_slvr_/){
            $pinName =~ s/_temp_slvr_//;
            my @arr = (split(/\//,$netName));
            my $net = pop(@arr);
            if($net =~ /\d+/){
              my $new_netName = $pinName.""."="."".$net;
              push(@net_list_for_temp_slvr,$new_netName); 
            }else {
              $net =~ s/_temp_slvr_//;
              my $net_str;
              $net_str = join"/",@arr;
              $net_str = $net_str."/".$net;
              my $new_netName = $pinName.""."="."".$net_str;
              push(@net_list_for_temp_slvr,$new_netName);
            }
          }else{
            push(@net_list,$netName); 
          } 
        }#foreach pinName
        if($instanceName =~ /\//){
           my @arr = (split(/\//,$instanceName));
           my @rev_arr = reverse (@arr);
           $new_inst  = join "/",@rev_arr;
        }else {
           $new_inst  = $instanceName;
        }
        print $write_fh "$new_inst @net_list $cellref @net_list_for_temp_slvr\n";
      }
    }#foreach instanceName
    print $write_fh ".ends $moduleName\n";
  }#if flat
  elsif($hier == 1){
    if($add_global_vdd_and_gnd == 1){
      print $write_fh ".GLOBAL VDD\n";
      print $write_fh ".GLOBAL GND\n";
    }
    if($add_first_blank_line == 1){
      print $write_fh "\n";
    }
    if($add_spice_missing_port == 1){
      if(-d $path_of_the_dir ){
        &check_spice_with_instance_port($TOP_MODULE,$path_of_the_dir);
      }else {print "ERR : spiceLib does not exist\n";} 
    }
    %TEMP_MODULE_ALREADY = ();
    &populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($start_module,$no_of_level);
    @temp_module_list = sort { $TEMP_MODULE_ALREADY{$a} <=> $TEMP_MODULE_ALREADY{$b} } keys %TEMP_MODULE_ALREADY;
    my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
    my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
    my %SUBCKT_PORT_DATA = (); 
    my %TEMP_CHECK_FILE = ();
    if($add_top_instance == 1){
      &write_instance_for_top_module($write_fh,$global_change_pin_vss_to_gnd,$vector_bit_blast);
    }#if add_top_instance
    foreach my $moduleName (@temp_module_list) {
      my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
      my @inPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetInput;
      my @outPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutput;
      my @bidiPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidi;
      my @allPorts_for_top = ();
      my $portcnt = 0;
      my $port_bit_cnt = 0;
      foreach my $i (@inPorts ) { 
        my $busWidth = "";
        my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputType($i);
        if ( $type == 1 ) {
          $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputBits($i); 
          $busWidth =~ s/\[/$get_opening_bracket/;
          $busWidth =~ s/\]/$get_closing_bracket/;
        }
        if ( $i =~ /\\/ ){$i = $i." "}; 
          if($vector_bit_blast == 1){
           my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
           my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
           foreach my $bit(@port_with_bit_blast){
             if($port_bit_cnt == 8){
               push ( @allPorts_for_top,"\n+",$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
               push ( @allPorts_for_top,"\n+",$i)if($bit eq ""); 
               $port_bit_cnt = 0;
             }else {
               push ( @allPorts_for_top,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
               push ( @allPorts_for_top,$i)if($bit eq ""); 
             }
            $port_bit_cnt++;
           }#foreach bit
          }else {
            if($i =~ /_temp_slvr_/){
              push (@allPorts_for_top,$i.$busWidth) if ($i !~ /^_temp_slvr_/); 
            }else {
              if($portcnt == 8){
                push ( @allPorts_for_top,"\n+",$i."".$busWidth); 
                $portcnt = 0;
              }else {
                push ( @allPorts_for_top,$i."".$busWidth); 
              }
            }
          }  
          $portcnt++;
      }#foreach bidiport
      foreach my $i (@outPorts ) { 
        my $busWidth = "";
        my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputType($i);
        if ( $type == 1 ) {
          $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputBits($i); 
          $busWidth =~ s/\[/$get_opening_bracket/;
          $busWidth =~ s/\]/$get_closing_bracket/;
        }
        if ( $i =~ /\\/ ){$i = $i." "}; 
          if($vector_bit_blast == 1){
           my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
           my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
           foreach my $bit(@port_with_bit_blast){
             if($port_bit_cnt == 8){
               push ( @allPorts_for_top,"\n+",$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
               push ( @allPorts_for_top,"\n+",$i)if($bit eq ""); 
               $port_bit_cnt = 0;
             }else {
               push ( @allPorts_for_top,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
               push ( @allPorts_for_top,$i)if($bit eq ""); 
             }
            $port_bit_cnt++;
           }#foreach bit
          }else {
            if($i =~ /_temp_slvr_/){
              push(@allPorts_for_top,"\n+",$i."".$busWidth) if($i !~ /^_temp_slvr_/);
            }else {
              if($portcnt == 8){
                push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
                $portcnt = 0;
              }else {
                push ( @allPorts_for_top,$i."".$busWidth); 
              }
            }
         }
        $portcnt++;
      }#foreach inport
      foreach my $i (@bidiPorts ) { 
        my $busWidth = "";
        my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($i);
        if ( $type == 1 ) {
          $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($i); 
          $busWidth =~ s/\[/[/;
          $busWidth =~ s/\]/]/;
        }
        if ( $i =~ /\\/ ){$i = $i." "}; 
          if($i =~ /_temp_slvr_/){
            push(@allPorts_for_top,$i."".$busWidth) if ($i !~ /^_temp_slvr_/);
          }else {
            if($portcnt == 8){
              push ( @allPorts_for_top, "\n+",$i."".$busWidth); 
              $portcnt = 0;
            }else {
              push ( @allPorts_for_top,$i."".$busWidth); 
            }
          }
        $portcnt++;
      }#foreach outport
      my %INST_NAME_HASH = ();
      my %NET_LIST_HASH = ();
      my %HIER_PORT_DATA = ();
      my $net_empty_cnt = 0;
      foreach my $connLine (@conns){
        $connLine =~ s/\(/\)\,/;
        $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
        my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
        my $instName = "";
        if($inst =~ /^\s*m\s*/i){
          $instName = "$inst";
        }else {
          $instName = "X_$inst";
        }
        push(@{$INST_NAME_HASH{$cell}},$instName);
        if($MODULE_ALREADY{$moduleName}->dbVNOMHasLeafInst($inst)){
          my @nets = split(/\s*\)\s*\,\s*/, $connLine);
          my $noOfPins = @nets;
          my $cnt = 0;
          my @leaf_pin_list = &return_temp_port_list_for_leaf_inst($cell); 
          @{$SUBCKT_PORT_DATA{$cell}} = @leaf_pin_list;
          if( -d $path_of_the_dir){
            my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
            foreach my $fileName (@spifiles){
              if($fileName eq "."|| $fileName eq ".."){next;}
              chomp($fileName);
              my $temp_file = $fileName;
              $temp_file =~ s/.*\///;
              $temp_file =~ s/\..*//;
              if($temp_file =~ /\b$cell\b/){
                my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
                @{$SUBCKT_PORT_DATA{$cell}} = @all_Ports_of_subckt_from_file;
                $TEMP_CHECK_FILE{$cell} = 1;
              }#if
            }#foreach
          }#if dir path
          my @portlist = @{$SUBCKT_PORT_DATA{$cell}};
          foreach my $pinName (@portlist){
            for(my $i = 1 ; $i < $noOfPins ; $i++){
            $nets[$i] =~ s/\s*\(\s*/\|/;
            $nets[$i] =~ s/\s*\)\s*//;
            my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
            $pin =~ s/\.//;
              if($pinName eq $pin){
              $netNameExpr = $net;
              $netNameExpr =~ s/^\s+//;
              $netNameExpr =~ s/\s+$//;
              if($netNameExpr =~ /\{.*\}/){
                $netNameExpr =~ s/\{/ /g;
                $netNameExpr =~ s/\}/ /g;
                $netNameExpr =~ s/\,/ /g;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                my @netNameExprList = (split(/\s+/,$netNameExpr));
                foreach my $netName (@netNameExprList){
                  if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g;
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g; 
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b0\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vss");
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b1\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd");
                    }
                    $cnt++;
                  }else {
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                    }
                    $cnt++;
                  }
                }#foreach 
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;  
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else {
                  if($cnt == 8){
                    if($pin =~ /_temp_slvr_/){
                      $pin =~ s/_temp_slvr_//;
                      $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                      my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $new_net"); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                    }
                    $cnt = 0;
                  }else {
                    if($pin =~ /_temp_slvr_/){
                       $pin =~ s/_temp_slvr_//;
                       $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                       my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, $new_net); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                    }
                  }
                  $cnt++;
                }#else
              }#else
              }#if
            }#for
          }#foreach
        }if ($MODULE_ALREADY{$moduleName}->dbVNOMHasHierInst($inst)){
          my @portlist_for_module = &return_temp_port_list_for_module($cell); 
          #@{$HIER_PORT_DATA{$cell}} = @portlist_for_module; 
          @{$SUBCKT_PORT_DATA{$cell}} = @portlist_for_module;
          if( -d $path_of_the_dir){
            my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
            foreach my $fileName (@spifiles){
              if($fileName eq "."|| $fileName eq ".."){next;}
              chomp($fileName);
              my $temp_file = $fileName;
              $temp_file =~ s/.*\///;
              $temp_file =~ s/\..*//;
              $cell =~ s/\)//;
              if($temp_file =~ /\b$cell\b/){
                my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
#               print "ERR : $cell exists in spice file also and subckt of this $cell is not written in .sp file\n";
               #@{$HIER_PORT_DATA{$cell}} = @all_Ports_of_subckt_from_file;
                @{$SUBCKT_PORT_DATA{$cell}} = @all_Ports_of_subckt_from_file;
                $TEMP_CHECK_FILE{$cell} = 1;
              }
            }#foreach
          }#if dir path
          my @portlist = @{$SUBCKT_PORT_DATA{$cell}};
          my $class = $MODULE_ALREADY{$cell}->dbVNOMGetClass;
          if($class == 11 && @portlist <= 0){
            my @nets = split(/\s*\)\s*\,\s*/, $connLine);
            my $noOfPins = @nets;
            my $cnt = 0;
            for(my $i = 1 ; $i < $noOfPins ; $i++){
              $nets[$i] =~ s/\s*\(\s*/\|/;
              $nets[$i] =~ s/\s*\)\s*//;
              my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
              $pin =~ s/\.//;
              $netNameExpr = $net;
              $netNameExpr =~ s/^\s+//;
              $netNameExpr =~ s/\s+$//;
              if($netNameExpr =~ /\{.*\}/){
                $netNameExpr =~ s/\{/ /g;
                $netNameExpr =~ s/\}/ /g;
                $netNameExpr =~ s/\,/ /g;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                my @netNameExprList = (split(/\s+/,$netNameExpr));
                foreach my $netName (@netNameExprList){
                  if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g;
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g; 
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b0\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vss");
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b1\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd");
                    }
                    $cnt++;
                  }else {
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                    }
                    $cnt++;
                  }
                }#foreach
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;  
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else {
                  if($netNameExpr eq ""){
                    $netNameExpr = "_temp_slvr_$net_empty_cnt";
                    $net_empty_cnt++;
                  }
                  if($cnt == 8){
                    if($pin =~ /_temp_slvr_/){
                      $pin =~ s/_temp_slvr_//;
                      $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                      my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $new_net"); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                    }
                    $cnt = 0;
                  }else {
                    if($pin =~ /_temp_slvr_/){
                       $pin =~ s/_temp_slvr_//;
                       $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                       my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, $new_net); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                    }
                  }
                  $cnt++;
                }
              }
            }#for
          }if($class == 11 && @portlist >= 0){
            my @nets = split(/\s*\)\s*\,\s*/, $connLine);
            my $noOfPins = @nets;
            my $cnt = 0;
            my @new_port_list = ();
            foreach my $pinName (@portlist){
              if($pinName =~ /_temp_slvr_/){
                @new_port_list = sort {$a cmp $b} @portlist;
              }else {@new_port_list = @portlist;}
            }#foreach
            foreach my $pinName (@new_port_list){
              $pinName =~s/.*_temp_slvr_//;
            for(my $i = 1 ; $i < $noOfPins ; $i++){
              $nets[$i] =~ s/\s*\(\s*/\|/;
              $nets[$i] =~ s/\s*\)\s*//;
              my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
              $pin =~ s/\.//;
              if($pinName eq $pin){ 
              $netNameExpr = $net;
              $netNameExpr =~ s/^\s+//;
              $netNameExpr =~ s/\s+$//;
              if($netNameExpr =~ /\{.*\}/){
                $netNameExpr =~ s/\{/ /g;
                $netNameExpr =~ s/\}/ /g;
                $netNameExpr =~ s/\,/ /g;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                my @netNameExprList = (split(/\s+/,$netNameExpr));
                foreach my $netName (@netNameExprList){
                  if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g;
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g; 
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b0\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vss");
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b1\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd");
                    }
                    $cnt++;
                  }else {
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                    }
                    $cnt++;
                  }
                }#foreach 
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;  
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else {
                  if($netNameExpr eq ""){
                    $netNameExpr = "_temp_slvr_$net_empty_cnt";
                    $net_empty_cnt++;
                  }
                  if($cnt == 8){
                    if($pin =~ /_temp_slvr_/){
                      $pin =~ s/_temp_slvr_//;
                      $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                      my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $new_net"); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                    }
                    $cnt = 0;
                  }else {
                    if($pin =~ /_temp_slvr_/){
                       $pin =~ s/_temp_slvr_//;
                       $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                       my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, $new_net); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                    }
                  }
                  $cnt++;
                }#else
              }#else
            }#for
            }#for
            }#for
          }#elsif
          #my $portName_from_spice = &check_portName(\@portlist);
          if($class == 0 && @portlist <= 0){
            my @nets = split(/\s*\)\s*\,\s*/, $connLine);
            my $noOfPins = @nets;
            my $cnt = 0;
            for(my $i = 1 ; $i < $noOfPins ; $i++){
              $nets[$i] =~ s/\s*\(\s*/\|/;
              $nets[$i] =~ s/\s*\)\s*//;
              my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
              $pin =~ s/\.//;
              $netNameExpr = $net;
              $netNameExpr =~ s/^\s+//;
              $netNameExpr =~ s/\s+$//;
              if($netNameExpr =~ /\{.*\}/){
                $netNameExpr =~ s/\{/ /g;
                $netNameExpr =~ s/\}/ /g;
                $netNameExpr =~ s/\,/ /g;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                my @netNameExprList = (split(/\s+/,$netNameExpr));
                foreach my $netName (@netNameExprList){
                  if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g;
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g; 
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b0\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vss");
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b1\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd");
                    }
                    $cnt++;
                  }else {
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                    }
                    $cnt++;
                  }
                }#foreach 
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;  
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else {
                  if($cnt == 8){
                    if($pin =~ /_temp_slvr_/){
                      $pin =~ s/_temp_slvr_//;
                      $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                      my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $new_net"); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                    }
                    $cnt = 0;
                  }else {
                    if($pin =~ /_temp_slvr_/){
                       $pin =~ s/_temp_slvr_//;
                       $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                       my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, $new_net); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                    }
                  }
                  $cnt++;
                }#else
              }#else
            }#for      
          }if($class == 0 && @portlist > 0){
            my @nets = split(/\s*\)\s*\,\s*/, $connLine);
            my $noOfPins = @nets;
            my $cnt = 0;
            my @new_port_list = ();
            foreach my $pinName (@portlist){
              if($pinName =~ /_temp_slvr_/){
                @new_port_list = sort {$a cmp $b} @portlist;
              }else {@new_port_list = @portlist;}
            }#foreach
            foreach my $pinName (@new_port_list){
              $pinName =~s/.*_temp_slvr_//;
              for(my $i = 1 ; $i < $noOfPins; $i++){
              $nets[$i] =~ s/\s*\(\s*/\|/;
              $nets[$i] =~ s/\s*\)\s*//;
              my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
              $pin =~ s/\.//;
              if($pinName eq $pin){ 
              $netNameExpr = $net;
              $netNameExpr =~ s/^\s+//;
              $netNameExpr =~ s/\s+$//;
              if($netNameExpr =~ /\{.*\}/){
                $netNameExpr =~ s/\{/ /g;
                $netNameExpr =~ s/\}/ /g;
                $netNameExpr =~ s/\,/ /g;
                $netNameExpr =~ s/^\s+//;
                $netNameExpr =~ s/\s+$//;
                my @netNameExprList = (split(/\s+/,$netNameExpr));
                foreach my $netName (@netNameExprList){
                  if($netName =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g;
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\[\s*[0-9]+\s*\]/){
                    $netName =~ s/\s+//g;
                    $netName =~ s/\s+$//g; 
                    $netName =~ s/\[/$get_opening_bracket/;
                    $netName =~ s/\]/$get_closing_bracket/;
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netName");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName);
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b0\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vss");
                    }
                    $cnt++;
                  }elsif($netName =~ /\s*1'b1\s*/){
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd");
                    }
                    $cnt++;
                  }else {
                    if($cnt == 8){
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, "\n+ $netName"); 
                      $cnt = 0;
                    }else {
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netName); 
                    }
                    $cnt++;
                  }
                }#foreach 
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;  
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }elsif($netNameExpr =~ /\[\s*[0-9]+\s*\]/){
                $netNameExpr =~ s/\s+//g;
                $netNameExpr =~ s/\s+$//g;
                $netNameExpr =~ s/\[/$get_opening_bracket/;
                $netNameExpr =~ s/\]/$get_closing_bracket/;
                if($cnt == 8){
                  push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr");
                  $cnt = 0;
                }else {
                  push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr);
                }
                $cnt++;
              }else {
                if($netNameExpr =~ /\s*1'b0\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vss");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vss"); 
                  }
                  $cnt++;
                }elsif($netNameExpr =~ /\s*1'b1\s*/){
                  if($cnt == 8){
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ vdd");
                    $cnt = 0;
                  }else {
                    push(@{$NET_LIST_HASH{$cell}{$instName}},"vdd"); 
                  }
                  $cnt++;
                }else {
                  if($netNameExpr eq ""){
                    $netNameExpr = "_temp_slvr_$net_empty_cnt";
                    $net_empty_cnt++;
                  }
                  if($cnt == 8){
                    if($pin =~ /_temp_slvr_/){
                      $pin =~ s/_temp_slvr_//;
                      $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                      my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $new_net"); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},"\n+ $netNameExpr"); 
                    }
                    $cnt = 0;
                  }else {
                    if($pin =~ /_temp_slvr_/){
                       $pin =~ s/_temp_slvr_//;
                       $netNameExpr =~ s/_temp_slvr_// if($netNameExpr =~ /_temp_slvr_/);
                       my $new_net = $pin."=".$netNameExpr;
                      push(@{$NET_LIST_HASH{$cell}{$instName}}, $new_net); 
                    }else{
                      push(@{$NET_LIST_HASH{$cell}{$instName}},$netNameExpr); 
                    }
                  }
                  $cnt++;
                }#else
              }#else
            }#if      
          }#for      
        }#foreach      
      }#portName_from_spice == 0       
    }#if exists is hierInst or trans
  }#foreach connLine
#----------------------------------write .sp-----------------------------#
  if($no_write_empty_module == 1){ 
    if(@conns <= 0){next;}
  }
  print $write_fh ".subckt $moduleName " if(! exists $TEMP_CHECK_FILE{$moduleName});
  my $portName_from_spice = &check_portName(\@allPorts_for_top);
  if($portName_from_spice == 1){
    my @sort_port = sort {$a cmp $b} @allPorts_for_top;
    my @new_port_list = ();
    my $sp_portcnt = 0;
    foreach my $port (@sort_port){
      my $new_port = "";
      #$port =~ s/\[.*//;
      if($global_change_pin_vss_to_gnd == 1){
        if($port =~ /vss/i){$new_port = "GND";}
        else {$new_port = $port;}
      }else {
         $new_port = $port;
      } 
      if($vector_bit_blast == 1){
        $new_port =~ s/\[.*//;
        my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($new_port);
        my $busWidth = "";
        $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($new_port) if ($type == 1);
        my %PORT_BIT_BLAST = &get_vector_bit_blast($new_port,$busWidth);
        my @port_with_bit_blast = @{$PORT_BIT_BLAST{$new_port}}; 
        foreach my $bit (@port_with_bit_blast){
          $new_port =~ s/.*_temp_slvr_//;
          if($sp_portcnt == 8){
            push (@new_port_list,"\n+",$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
            push (@new_port_list,"\n+",$new_port)if($bit eq ""); 
            $sp_portcnt = 0;
          }else {
            push (@new_port_list,$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
            push (@new_port_list,$new_port)if($bit eq ""); 
          }
          $sp_portcnt++;
        }#foreach
      }else {
        $new_port =~ s/^\d+_temp_slvr_\s*//;
        $new_port =~ s/\[/</;
        $new_port =~ s/\]/>/;
        if($sp_portcnt == 8){
          push(@new_port_list,"\n+",$new_port);
        }else {
          push(@new_port_list,$new_port);
        }
        $sp_portcnt++;
      }
    }##foreach port
    print $write_fh "@new_port_list\n" if(! exists $TEMP_CHECK_FILE{$moduleName});
  }else {
    if($global_change_pin_vss_to_gnd == 1){
      my @updated_allPorts_for_top = ();
      foreach my $i (@allPorts_for_top){
        if($i =~ /\bvss\b/i){
          push(@updated_allPorts_for_top,"GND"); 
        }else{
          push(@updated_allPorts_for_top,$i); 
        }
      }#foreach
      print $write_fh "@updated_allPorts_for_top\n"if(!exists $TEMP_CHECK_FILE{$moduleName});
    }else {
      print $write_fh "@allPorts_for_top \n"if(!exists $TEMP_CHECK_FILE{$moduleName});
    }
  }
#-----------------------------------------------------------------------------------------#
    foreach my $subckt (keys %INST_NAME_HASH){
        my @inst_list = @{$INST_NAME_HASH{$subckt}}; 
        foreach my $inst_Name (@inst_list){
          print $write_fh "$inst_Name " if(! exists $TEMP_CHECK_FILE{$moduleName}); 
          if(exists $NET_LIST_HASH{$subckt}{$inst_Name}){
            my @net_list = @{$NET_LIST_HASH{$subckt}{$inst_Name}};
            my @new_net_list = ();
            my @net_list_for_equal = ();
            foreach my $net (@net_list){
                if($vector_bit_blast == 1){
                  if($net =~ /=/){
                      if($net =~ /(\d+.\d+)u$/i){
                        $net=~ s/U|u//g if(($in_unit =~/micron|meter/) || ($out_unit =~ /micron|meter/));
                        push(@net_list_for_equal,"$net") ;
                      }elsif($net =~ /(\d+)u$/i){
                        $net =~ s/U|u//g if(($in_unit =~/micron|meter/) || ($out_unit =~ /micron|meter/));
                        push(@net_list_for_equal,"$net") ;
                      }elsif($net =~ /(\d+.\d+)e-/i){
                        my ($port,$value) = (split(/=/,$net))[0,1];
                        my ($digit,$exp) = (split(/e-/,$value))[0,1];
                        if($in_unit eq "micron"){
                          if($out_unit eq "micron"){
                            my $new_var = $net;
                            push(@net_list_for_equal,"$new_var") ;
                          }else {
                            my $new_exp = $exp+06;
                            my $new_var = $digit."e-".$new_exp;
                            push(@net_list_for_equal,"$port=$new_var") ;
                          }
                        }elsif($in_unit eq "meter"){
                          if($out_unit eq "micron"){
                            my $new_exp = "-$exp"+06;
                            my $new_var = $digit."e".$new_exp if($new_exp != 0);
                            push(@net_list_for_equal,"$port=$new_var") ;
                          }else {
                            my $new_var = $net;
                            push(@net_list_for_equal,"$new_var") ;
                          }
                        }
                      }elsif($net =~ /(\d+)e-/i){
                        my ($port,$value) = (split(/=/,$net))[0,1];
                        my ($digit,$exp) = (split(/e-/,$value))[0,1];
                        if($in_unit eq "micron"){
                          if($out_unit eq "micron"){
                            my $new_var = $net;
                            push(@net_list_for_equal,"$new_var") ;
                          }else {
                            my $new_exp = $exp+06;
                            my $new_var = $digit."e-".$new_exp;
                            push(@net_list_for_equal,"$port=$new_var") ;
                          }
                        }elsif($in_unit eq "meter"){
                          if($out_unit eq "micron"){
                            my $new_exp = "-$exp"+06;
                            my $new_var = $digit."e".$new_exp;
                            push(@net_list_for_equal,"$port=$new_var") ;
                          }else {
                            my $new_var = $net;
                            push(@net_list_for_equal,"$new_var") ;
                          }
                        }
                      }else {
                        push(@net_list_for_equal,$net);
                      }
                  }else{ 
                     if($net =~ /\bvss\b/i){
                       push(@new_net_list,"GND")if($global_change_pin_vss_to_gnd == 1);
                       push(@new_net_list,$net)if($global_change_pin_vss_to_gnd == 0);
                     }else{
                       if($net =~ /\<\s*[0-9]+\s*\:\s*[0-9]+\s*\>/){
                         $net =~ s/</ /;
                         $net =~ s/>/ /;
                         $net =~ s/:/ /;
                         my ($netName,$min,$max) = (split(/\s+/,$net))[0,1,2];
                         if($min < $max ){
                           for(my $i = $min;$i <=$max;$i++){
                             push(@new_net_list,$netName.$get_opening_bracket.$i.$get_closing_bracket);
                           }#for
                         }elsif($min > $max){
                           for(my $i = $min;$i>=$max;$i--){
                             push(@new_net_list,$netName.$get_opening_bracket.$i.$get_closing_bracket);
                           }
                         }
                       }elsif(exists $MODULE_ALREADY{$moduleName}->{ins}{$net}){
                           my $busWidth = "";
                           my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputType($net);
                           if ( $type == 1 ) {
                             $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputBits($net); 
                             $busWidth =~ s/\[|</$get_opening_bracket/;
                             $busWidth =~ s/\]|>/$get_closing_bracket/;
                             my %PORT_BIT_BLAST = &get_vector_bit_blast($net,$busWidth);
                             my @port_with_bit_blast = @{$PORT_BIT_BLAST{$net}}; 
                             foreach my $bit(@port_with_bit_blast){
                               push(@new_net_list,$net."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
                               push (@new_net_list,$net)if($bit eq ""); 
                             }#foreach
                           }else {
                               push (@new_net_list,$net); 
                           } 
                       }elsif(exists $MODULE_ALREADY{$moduleName}->{outs}{$net}){
                           my $busWidth = "";
                           my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputType($net);
                           if ( $type == 1 ) {
                             $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputBits($net); 
                             $busWidth =~ s/\[|</$get_opening_bracket/;
                             $busWidth =~ s/\]|>/$get_closing_bracket/;
                             my %PORT_BIT_BLAST = &get_vector_bit_blast($net,$busWidth);
                             my @port_with_bit_blast = @{$PORT_BIT_BLAST{$net}}; 
                             foreach my $bit(@port_with_bit_blast){
                               push(@new_net_list,$net."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
                               push (@new_net_list,$net)if($bit eq ""); 
                             }#foreach
                           }else {
                               push (@new_net_list,$net); 
                           } 
                       }elsif(exists $MODULE_ALREADY{$moduleName}->{bidis}{$net}){
                         my $busWidth = "";
                         my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($net);
                         if ( $type == 1 ) {
                           $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($net); 
                           $busWidth =~ s/\[|</$get_opening_bracket/;
                           $busWidth =~ s/\]|>/$get_closing_bracket/;
                           my %PORT_BIT_BLAST = &get_vector_bit_blast($net,$busWidth);
                           my @port_with_bit_blast = @{$PORT_BIT_BLAST{$net}}; 
                           foreach my $bit(@port_with_bit_blast){
                             push(@new_net_list,$net."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
                             push (@new_net_list,$net)if($bit eq ""); 
                           }#foreach
                        }else {
                           push (@new_net_list,$net); 
                        } 
                        }else {
                           push(@new_net_list,$net);
                         } 
                       } 
                   }#else
                }else {
                  if($net =~ /=/){
                    push(@net_list_for_equal,$net);
                  }else{ 
                   if($global_change_pin_vss_to_gnd == 1){
                     if($net =~ /\bvss\b/i){
                       push(@new_net_list,"GND");
                     }else{
                       push(@new_net_list,$net);
                     }
                   }else {
                       push(@new_net_list,$net);
                   }
                }
              }
            }#foreach net
            print $write_fh "@new_net_list $subckt @net_list_for_equal\n" if(! exists $TEMP_CHECK_FILE{$moduleName});
          }#if exists  
        }#foreach
    }#foreach
    print $write_fh ".ends $moduleName\n"if(! exists $TEMP_CHECK_FILE{$moduleName});
    print $write_fh "\n"if(! exists $TEMP_CHECK_FILE{$moduleName});
    }#foreach moduleName
    if($complete_spice == 1){
      foreach my $subckt (keys %SUBCKT_PORT_DATA){
        print $write_fh ".subckt $subckt " if((!exists $TEMP_CHECK_FILE{$subckt})&& (!exists $MODULE_ALREADY{$subckt}));
        print $write_fh "@{$SUBCKT_PORT_DATA{$subckt}}\n"if((!exists $TEMP_CHECK_FILE{$subckt})&& (!exists $MODULE_ALREADY{$subckt})); 
        if (-d $path_of_the_dir ){
          my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
          foreach my $fileName (@spifiles){
            if($fileName eq "." || $fileName eq ".."){next;}
            chomp($fileName);
            my $temp_file = $fileName;
            $temp_file =~ s/.*\///;
            $temp_file =~ s/\..*//;
            $subckt =~ s/\)//;
            if($temp_file =~ /\b$subckt\b/){
              my $include_found = &check_include_found_from_sp($fileName); 
              if($include_found == 1){
                my $temp_output_file = &include_spi($fileName);
                #&write_sp_data($temp_output_file,$write_fh,$unit_meter,$global_change_pin_vss_to_gnd);
                #&write_sp_data($temp_output_file,$write_fh,$in_unit,$out_unit,$global_change_pin_vss_to_gnd);
              }else {
                #&write_sp_data($fileName,$write_fh,$unit_meter,$global_change_pin_vss_to_gnd);
                #&write_sp_data($fileName,$write_fh,$in_unit,$out_unit,$global_change_pin_vss_to_gnd,$subckt);
                &read_spice_new("-sp",$fileName);
                &write_sp_data($write_fh,$in_unit,$out_unit,$global_change_pin_vss_to_gnd,$subckt,$vector_bit_blast);
              }
            }
          }#foreach
        }#foreach
        print $write_fh ".ends $subckt\n"if((!exists $TEMP_CHECK_FILE{$subckt})&& (!exists $MODULE_ALREADY{$subckt}));
        print $write_fh "\n";
      }
    }
  }#elsif hier
  close($write_fh); 
}#else
}#sub write_spice_file
#-----------------------------------------------------------------------------------------------------------------------#
sub check_portName {
my @portList = @{$_[0]};  
my $portName_from_spice = 0;
foreach my $port (@portList){
  if($port =~ /_temp_slvr_/){
    $portName_from_spice = 1;
    last;
  }else {
    $portName_from_spice = 0;
  }
}
return($portName_from_spice);
}#sub check_portName
#-----------------------------------------------------------------------------------------------------------------------#
sub return_temp_port_list_for_module {
my $moduleName = $_[0];
my @check_port_list = ();
#my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn if(exists $MODULE_ALREADY{$moduleName}); 
#if(@conns ne ""){next;}
my @inPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetInput if(exists $MODULE_ALREADY{$moduleName});
my @outPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutput if(exists $MODULE_ALREADY{$moduleName}); 
my @bidiPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidi if(exists $MODULE_ALREADY{$moduleName});
my @check_port_list = ();
foreach my $i (@inPorts ) { 
  if($i =~ /^_temp_slvr_/){
    push(@check_port_list,$i);
  }else {
    push(@check_port_list,$i);
  }
}#foreach inport
foreach my $i (@outPorts ) { 
  if($i =~ /^_temp_slvr_/){
    push(@check_port_list,$i);
  }else {
    push(@check_port_list,$i);
  }
}#foreach outport
foreach my $i (@bidiPorts ) { 
  if($i =~ /_temp_slvr_/){
    push(@check_port_list,$i);
  }else{
    push(@check_port_list,$i);
  }
}#foreach bidiport
return (@check_port_list);
}#sub return_temp_port_list_for_module
#-----------------------------------------------------------------------------------------------------------------------#
sub return_temp_port_list_for_leaf_inst {
my $cellName = $_[0];
my @pinlist = ();
if(exists $PLDB{$cellName}){
  my @pins = $PLDB{$cellName}->dbMdbGetPins;
  foreach my $pinName (@pins){
    my $pinType = $PLDB{$cellName}->dbMdbGetPinType($pinName);
    if($pinType !=  1 && $pinType != 2){push (@pinlist,$pinName);}
  }#foreach
  foreach my $pinName(@pins){
    my $pinType = $PLDB{$cellName}->dbMdbGetPinType($pinName);
    if($pinType == 1 || $pinType == 2){push (@pinlist,$pinName);}
  }#foreach
}#if
  return(@pinlist);
}#sub return_temp_port_list_for_leaf_inst
#-----------------------------------------------------------------------------------------------------------------------#
sub get_vector_bit_blast {
my $portName = $_[0];
my $busWidth = $_[1];
$busWidth =~ s/\[|<//;
$busWidth =~ s/\]|>//;
my %PORT_BIT_BLAST = ();
my $cnt = 0;
my ($min,$max) = (split(/:/,$busWidth));
if($min < $max){
  for(my $i = $min;$i <=$max;$i++){
    push(@{$PORT_BIT_BLAST{$portName}},$i);
  }#for
}elsif($min > $max){
  for(my $i = $min;$i>=$max;$i--){
    push(@{$PORT_BIT_BLAST{$portName}},$i);
  }#for
}else {
    push(@{$PORT_BIT_BLAST{$portName}},"");
}
  return(%PORT_BIT_BLAST);
}#sub get_vector_bit_blast
#-----------------------------------------------------------------------------------------------------------------------#
sub write_instance_for_top_module {
my $filehandle = $_[0];
my $global_change_pin_vss_to_gnd = $_[1];
my $vector_bit_blast = $_[2];
my $moduleName = $TOP_MODULE;
my @inPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetInput;
my @outPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutput;
my @bidiPorts = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidi;
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
my @all_nets_for_top = ();
my $port_bit_cnt = 0;
#-----------------------------------------------------------------------------------------#
foreach my $i (@inPorts){
  my $busWidth = "";
  my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputType($i);
  $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputBits($i)if ( $type == 1 );
  if($vector_bit_blast == 1){ 
    my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
    my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
    foreach my $bit(@port_with_bit_blast){
      if($port_bit_cnt == 8){
        push (@all_nets_for_top,"\n+",$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
        push (@all_nets_for_top,"\n+",$i)if($bit eq ""); 
        $port_bit_cnt = 0;
      }else {
        push (@all_nets_for_top,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
        push (@all_nets_for_top,$i)if($bit eq ""); 
      }
     $port_bit_cnt++;
    }#foreach bit
  }else {
    $busWidth =~ s/\[|<//;
    $busWidth =~ s/\]|>//;
    if($port_bit_cnt == 8){
      push ( @all_nets_for_top,"\n+",$i."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
      push (@all_nets_for_top,"\n+",$i)if($busWidth eq ""); 
      $port_bit_cnt = 0;
    }else {
      push ( @all_nets_for_top,$i."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
      push (@all_nets_for_top,$i)if($busWidth eq ""); 
    }
  }
  $port_bit_cnt++;
}#foreach
#-----------------------------------------------------------------------------------------#
foreach my $i (@outPorts){
  my $busWidth = "";
  my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputType($i);
  $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputBits($i)if ( $type == 1 );
  if($vector_bit_blast == 1){
    my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
    my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
    foreach my $bit(@port_with_bit_blast){
      if($port_bit_cnt == 8){
        push (@all_nets_for_top,"\n+",$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
        push (@all_nets_for_top,"\n+",$i)if($bit eq ""); 
        $port_bit_cnt = 0;
      }else {
        push (@all_nets_for_top,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
        push (@all_nets_for_top,$i)if($bit eq ""); 
      }
     $port_bit_cnt++;
    }#foreach bit
  }else {
    $busWidth =~ s/\[|<//;
    $busWidth =~ s/\]|>//;
    if($port_bit_cnt == 8){
      push ( @all_nets_for_top,"\n+",$i."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
      push (@all_nets_for_top,$i)if($busWidth eq ""); 
      $port_bit_cnt = 0;
    }else {
      push ( @all_nets_for_top,$i."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
      push (@all_nets_for_top,$i)if($busWidth eq ""); 
    }
  }
  $port_bit_cnt++;
}#foreach
#-----------------------------------------------------------------------------------------#
my $portName_from_spice = &check_portName(\@bidiPorts);
if($portName_from_spice == 1){
  my @sort_port = sort {$a cmp $b} @bidiPorts;
  foreach my $port (@sort_port){
    my $new_port = "";
    if($global_change_pin_vss_to_gnd == 1){
      if($port =~ /vss/i){$new_port = "GND";}
      else {$new_port = $port;}
    }else {
      $new_port = $port;
    }
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($new_port);
    my $busWidth = "";
    $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($new_port) if ($type == 1);
    if($vector_bit_blast == 1){
      my %PORT_BIT_BLAST = &get_vector_bit_blast($new_port,$busWidth);
      my @port_with_bit_blast = @{$PORT_BIT_BLAST{$new_port}}; 
      foreach my $bit (@port_with_bit_blast){
        $new_port =~ s/.*_temp_slvr_//;
        if($port_bit_cnt == 8){
          push (@all_nets_for_top,"\n+",$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@all_nets_for_top,"\n+",$new_port)if($bit eq ""); 
          $port_bit_cnt = 0;
        }else {
          push (@all_nets_for_top,$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@all_nets_for_top,$new_port)if($bit eq ""); 
        }
        $port_bit_cnt++;
      }#foreach
    }else {
      $busWidth =~ s/\[|<//;
      $busWidth =~ s/\]|>//;
      $new_port =~ s/.*_temp_slvr_//;
      if($port_bit_cnt == 8){
        push ( @all_nets_for_top,"\n+",$new_port."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
        push (@all_nets_for_top,"\n+",$new_port)if($busWidth eq ""); 
        $port_bit_cnt = 0;
      }else {
        push ( @all_nets_for_top,$new_port."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
        push (@all_nets_for_top,$new_port)if($busWidth eq ""); 
      }
    }
    $port_bit_cnt++;
  }#foreach
}else {
  foreach my $i (@bidiPorts){
    my $new_port = "";
    if($global_change_pin_vss_to_gnd == 1){
      if($i =~ /\bvss\b/i){$new_port = "GND";}
      else {$new_port = $i;}
    }else {
      $new_port = $i;
    }
    my $busWidth = "";
    my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($new_port);
    $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($new_port)if ( $type == 1 );
    if($vector_bit_blast == 1){
      my %PORT_BIT_BLAST = &get_vector_bit_blast($new_port,$busWidth);
      my @port_with_bit_blast = @{$PORT_BIT_BLAST{$new_port}}; 
      foreach my $bit(@port_with_bit_blast){
        if($port_bit_cnt == 8){
          push (@all_nets_for_top,"\n+",$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@all_nets_for_top,"\n+",$new_port)if($bit eq ""); 
          $port_bit_cnt = 0;
        }else {
          push (@all_nets_for_top,$new_port."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
          push (@all_nets_for_top,$new_port)if($bit eq ""); 
        }
       $port_bit_cnt++;
      }#foreach bit
    }else {
      $busWidth =~ s/\[|<//;
      $busWidth =~ s/\]|>//;
      if($port_bit_cnt == 8){
        push ( @all_nets_for_top,"\n+",$new_port."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
        push (@all_nets_for_top,"\n+",$new_port)if($busWidth eq ""); 
        $port_bit_cnt = 0;
      }else {
        push ( @all_nets_for_top,$new_port."".$get_opening_bracket.$busWidth.$get_closing_bracket)if($busWidth ne ""); 
        push (@all_nets_for_top,$new_port)if($busWidth eq ""); 
      }
    }
    $port_bit_cnt++;
  }#foreach
}#else
print $filehandle "X_$TOP_MODULE @all_nets_for_top $TOP_MODULE\n";
print $filehandle "\n";
}#sub write_instance_for_top_module
#-----------------------------------------------------------------------------------------------------------------------#
sub check_spice_with_instance_port {
my $moduleName = $_[0];
my $path_of_the_dir = $_[1];
my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
$MODULE_ALREADY{$moduleName}->dbVNOMWipeConn;
foreach my $connLine (@conns){
  my $temp_connLine = $connLine; 
  $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
  $temp_connLine =~ s/\(/\)\,/;
  $temp_connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
  my %SUBCKT_PORT_HASH = ();
  my ($cell,$inst) = ( split(/\s+/, $temp_connLine ))[0,1];
  my @nets = split(/\s*\)\s*\,\s*/, $temp_connLine);
  my $noOfPins = @nets;
  if ($MODULE_ALREADY{$moduleName}->dbVNOMHasHierInst($inst)){
    my $class = $MODULE_ALREADY{$cell}->dbVNOMGetClass;
    if($class == 11 ){
      if( -d $path_of_the_dir ){
        my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
        foreach my $fileName (@spifiles){
          if($fileName eq "."|| $fileName eq ".."){next;}
          chomp($fileName);
          my $temp_file = $fileName;
          $temp_file =~ s/.*\///;
          $temp_file =~ s/\..*//;
          if($temp_file =~ /\b$cell\b/){
            my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
            @{$SUBCKT_PORT_HASH{$cell}} = @all_Ports_of_subckt_from_file; 
          }#if
        }#foreach
      }#if
      my @port_list = @{$SUBCKT_PORT_HASH{$cell}};
      my ($UNMATCHED_PORT_OF_VERILOG,$UNMATCHED_PORT_OF_SUBCKT) = &check_port_from_spice_file($inst,$cell,$temp_connLine,\@port_list);
      my %NEW_UNMATCHED_PORT_OF_SUBCKT = %$UNMATCHED_PORT_OF_SUBCKT;
      my @unmatched_portList = @{$NEW_UNMATCHED_PORT_OF_SUBCKT{$inst}};
      foreach my $unmatched_port (@unmatched_portList){
        if (exists $MODULE_ALREADY{$moduleName}->{ins}{$unmatched_port}) {
        }elsif(exists $MODULE_ALREADY{$moduleName}->{outs}{$unmatched_port}){
        }elsif(exists $MODULE_ALREADY{$moduleName}->{bidis}{$unmatched_port}){
        }else {
          $MODULE_ALREADY{$moduleName}->dbVNOMAddBidi($unmatched_port);
        }
      $connLine = $connLine .", .$unmatched_port($unmatched_port)";
      }#foreach
      $connLine = $connLine.");";
      $MODULE_ALREADY{$moduleName}->dbVNOMAddConn($connLine);  
    }else {
      my @port_list = ();
      &check_spice_with_instance_port($cell,$path_of_the_dir);
      my @input = $MODULE_ALREADY{$cell}->dbVNOMGetInput;
      my @output = $MODULE_ALREADY{$cell}->dbVNOMGetOutput;
      my @bidi = $MODULE_ALREADY{$cell}->dbVNOMGetBidi;
      push(@port_list,@input,@output,@bidi);
      my ($UNMATCHED_PORT_OF_VERILOG,$UNMATCHED_PORT_OF_SUBCKT) = &check_port_from_spice_file($inst,$cell,$temp_connLine,\@port_list);
      my %NEW_UNMATCHED_PORT_OF_SUBCKT = %$UNMATCHED_PORT_OF_SUBCKT;
      my @unmatched_portList = @{$NEW_UNMATCHED_PORT_OF_SUBCKT{$inst}};
      foreach my $unmatched_port (@unmatched_portList){
        if (exists $MODULE_ALREADY{$moduleName}->{ins}{$unmatched_port}) {
        }elsif(exists $MODULE_ALREADY{$moduleName}->{outs}{$unmatched_port}){
        }elsif(exists $MODULE_ALREADY{$moduleName}->{bidis}{$unmatched_port}){
        }else {
          $MODULE_ALREADY{$moduleName}->dbVNOMAddBidi($unmatched_port);
        }
        $connLine = $connLine .", .$unmatched_port($unmatched_port)";
      }#foreach
      $connLine = $connLine.");";
      $MODULE_ALREADY{$moduleName}->dbVNOMAddConn($connLine);  
    }#else
  }if($MODULE_ALREADY{$moduleName}->dbVNOMHasLeafInst($inst)){
    if( -d $path_of_the_dir ){
      my @spifiles = `find  -L $path_of_the_dir -name \\*\\.spi -o -name \\*\\.sp -o -name \\*\\.spx -o -name \\*\\.spx\\* ! -name \\*\\.pxi ! -name \\*\\.pex`;
      foreach my $fileName (@spifiles){
        if($fileName eq "."|| $fileName eq ".."){next;}
        chomp($fileName);
        my $temp_file = $fileName;
        $temp_file =~ s/.*\///;
        $temp_file =~ s/\..*//;
        if($temp_file =~ /\b$cell\b/){
          my @all_Ports_of_subckt_from_file = &find_port_list($fileName);
          @{$SUBCKT_PORT_HASH{$cell}} = @all_Ports_of_subckt_from_file; 
        }#if
      }#foreach
    }#if
    my @port_list = @{$SUBCKT_PORT_HASH{$cell}};
    my ($UNMATCHED_PORT_OF_VERILOG,$UNMATCHED_PORT_OF_SUBCKT) = &check_port_from_spice_file($inst,$cell,$temp_connLine,\@port_list);
    my %NEW_UNMATCHED_PORT_OF_SUBCKT = %$UNMATCHED_PORT_OF_SUBCKT;
    my @unmatched_portList = @{$NEW_UNMATCHED_PORT_OF_SUBCKT{$inst}};
    foreach my $unmatched_port (@unmatched_portList){
      if (exists $MODULE_ALREADY{$moduleName}->{ins}{$unmatched_port}) {
      }elsif(exists $MODULE_ALREADY{$moduleName}->{outs}{$unmatched_port}){
      }elsif(exists $MODULE_ALREADY{$moduleName}->{bidis}{$unmatched_port}){
      }else {
        $MODULE_ALREADY{$moduleName}->dbVNOMAddBidi($unmatched_port);
      }
    $connLine = $connLine .", .$unmatched_port($unmatched_port)";
    }#foreach
    $connLine = $connLine.");";
    $MODULE_ALREADY{$moduleName}->dbVNOMAddConn($connLine);  
  }#if leaf inst
}#foreach connLine
}#sub check_spice_with_instance_port
#-----------------------------------------------------------------------------------------------------------------------#
sub create_cmd_file_from_vcd_old {
use Verilog::VCD qw(parse_vcd);
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : create_cmd_file_from_vcd\n";
                                        print "      : -vcd<fileName>\n";
                                        print "      : -cmd<output_fileName>\n";
                                        print "      : -tb_module <top_module>\n";
                                        print "      : -module <{list of moduleName>}\n";
                                        print "      : --blio_write\n";
                                       }

else {
  my $vcd_file;
  my @sigs = ();
  my $cmd_file = $TOP_MODULE;
  my %time_vs_value_hash = ();
  my %dump_vs_value_hash = ();
  my $tb_module_found = 0;
  my $mod = "";
  my $blio_write = 0;
  for(my $i =0; $i<$noOfArguments;$i++){
    if($_[$i] eq "-vcd"){$vcd_file = $_[$i+1];} 
    if($_[$i] eq "-cmd"){$cmd_file = $_[$i+1];} 
    if($_[$i] eq "-tb_module"){$tb_module = $_[$i+1];$tb_module_found = 1;}
    if($_[$i] eq "-module"){$mod = $_[$i+1];}
    if($_[$i] eq "--blio_write") {$blio_write = 1;}
  }#for
  open(WRITE_CMD,">$cmd_file.cmd");
  print WRITE_CMD "blio open $TOP_MODULE.blio.gz\n" if($blio_write == 1);
#  print WRITE_CMD "l gnd\n";
#  print WRITE_CMD "h vdd\n";
  my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
  my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
  #my $vcd = parse_vcd($vcd_file);
  my $vcd = &parse_vcd($vcd_file, {timescale => 'ns'});
  foreach my $code (keys %{ $vcd }){
    my @nets = @{ $vcd->{$code}->{nets} };
    my @nets_tv = @{ $vcd->{$code}->{tv} };
    push @sigs, map {"$_->{hier}.$_->{name}"} @nets;
    my $time_cnt = 0;
    foreach my $arr (@nets_tv){
      my @net = map {"$_->{hier}.$_->{name}"} @nets;
      $net_str = join "",@net;
      my @time_vs_value_arr = &return_time_vs_value_hash($net_str,@$arr[1]);
      if(@$arr[0] == 0){
        $time_cnt++;
      }else {
        push(@{$time_vs_value_hash{@$arr[0]}},@time_vs_value_arr);
      }
      if($time_cnt == 1){
        push(@{$dump_vs_value_hash{"dump"}},@time_vs_value_arr) if(@$arr[0] == 0);
      }else {
        push(@{$time_vs_value_hash{@$arr[0]}},@time_vs_value_arr)if(@$arr[0] == 0);
      }
    }#foreach
  }#foreach
  #&check_port_between_verilog_and_vcd(\@sigs);
  if($tb_module_found == 1){
    if($tb_module eq $TOP_MODULE){
      my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs);
      my ($all_input_sig,$all_output_sig,$check_net_hash) = &get_hash_from_tb_module($tb_module,$mod,\@port_list_with_hier);
      my %input_sig = %$all_input_sig;
      my %output_sig = %$all_output_sig;
      my ($all_input_sig_list ,$all_output_sig_list) = &convert_input_and_output_sig_list($all_input_sig,$all_output_sig);
      my @input_sig_list = @$all_input_sig_list;
      my @output_sig_list = @$all_output_sig_list;
      my %CHECK_NET_HASH = %$check_net_hash;
      foreach my $dumpvar (keys %dump_vs_value_hash){
        my @dump_value = @{$dump_vs_value_hash{$dumpvar}};
        foreach my $dump_vl (@dump_value){
          #print WRITE_CMD "@$dump_vl[1] @$dump_vl[0]\n";
          my @net_hier = (split(/\./,@$dump_vl[0]));
          if(@net_hier == 2){
            my $net = pop @net_hier;
            my $hier_path = join"",@net_hier;
            if($net =~ /\[|</){
              $net =~ s/\[|</ /;
              $net =~ s/\]|>/ /;
              my ($netName,$digit) = (split(/\s+/,$net))[0,1];
               if(exists $CHECK_NET_HASH{$netName}){
                 my $port = $CHECK_NET_HASH{$netName};
                 my $full_path = "";
                 $full_path = "$hier_path.$port$get_opening_bracket$digit$get_closing_bracket" if($digit ne ""); 
                 $full_path = "$hier_path.$port" if($digit eq "");
                 my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                 if(exists $output_sig{$full_path}){
                   #print WRITE_CMD "assert $new_sig @$dump_vl[1]\n";
                 }else {
                   if(@$dump_vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n";
                   }else {
                     print WRITE_CMD "@$dump_vl[1] $new_sig\n";
                   } 
                 }
               }
            }else {
              if(exists $CHECK_NET_HASH{$net}){
                my $port = $CHECK_NET_HASH{$net};
                my $full_path = "$hier_path.$port";
                my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                 if(exists $output_sig{$full_path}){
                   #print WRITE_CMD "assert $new_sig @$dump_vl[1]\n";
                 }else {
                   if(@$dump_vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n";
                   }else {
                     print WRITE_CMD "@$dump_vl[1] $new_sig\n";
                   }
                 }
              }
            }
          }
        }
      }#foreach
      #print WRITE_CMD "w @port_list_with_hier\n";  
      print WRITE_CMD "w @input_sig_list @output_sig_list\n";  
      print WRITE_CMD "logfile $cmd_file.log\n";
      my @time_list = (sort {$a <=> $b} keys %time_vs_value_hash);
      my $temp_time_diff_hash = &calc_time_diff(\@time_list);
      my %time_hash = %$temp_time_diff_hash; 
      foreach my $time (sort {$a <=> $b} keys %time_vs_value_hash){
        my @value = @{$time_vs_value_hash{$time}};
        my $step_size = "";
        if(exists $time_hash{$time}){
          $step_size = $time_hash{$time};
        }
        print WRITE_CMD "stepsize $step_size \n";
        print WRITE_CMD "s\n";
        foreach my $vl (@value){ 
          #print WRITE_CMD "@$vl[1] @$vl[0]\n";
          my @net_hier = (split(/\./,@$vl[0]));
          if(@net_hier == 2){
            my $net = pop @net_hier;
            my $hier_path = join "",@net_hier;
            if($net =~ /\[|</){
              $net =~ s/\[|</ /;
              $net =~ s/\]|>/ /;
              my ($netName,$digit) = (split(/\s+/,$net))[0,1];
              if(exists $CHECK_NET_HASH{$netName}){
                my $port = $CHECK_NET_HASH{$netName};
                my $full_path = ""; 
                $full_path = "$hier_path.$port$get_opening_bracket$digit$get_closing_bracket" if($digit ne ""); 
                $full_path = "$hier_path.$port" if($digit eq "");
                my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                if(exists $output_sig{$full_path}){
                  print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
                }else {
                  if(@$vl[1] eq "x"){
                    print WRITE_CMD "l $new_sig\n";
                  }else {
                    print WRITE_CMD "@$vl[1] $new_sig\n";
                  }
                }
              }  
            }else {
              if(exists $CHECK_NET_HASH{$net}){
                my $port = $CHECK_NET_HASH{$net};
                my $full_path = "$hier_path.$port";
                my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                if(exists $output_sig{$full_path}){
                  print WRITE_CMD "assert $new_sig @$vl[1] \n" if(@$vl[1] ne "x");
                }else {
                  if(@$vl[1] eq "x"){
                    print WRITE_CMD "l $new_sig\n";
                  }else {
                    print WRITE_CMD "@$vl[1] $new_sig\n";
                  }
                }
              }
            }
          }
        }#foreach
      }#foreach
    }else {
      print "ERR : $tb_module is not a top module\n";
    }
  }else {
    my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs);
    my ($all_input_sig,$all_output_sig) = &get_dir_wire_full_path(\@port_list_with_hier);
    my %input_sig = %$all_input_sig;
    my %output_sig = %$all_output_sig;
    my ($all_input_sig_list ,$all_output_sig_list) = &convert_input_and_output_sig_list($all_input_sig,$all_output_sig);
    my @input_sig_list = @$all_input_sig_list;
    my @output_sig_list = @$all_output_sig_list;
    foreach my $dumpvar (keys %dump_vs_value_hash){
      my @dump_value = @{$dump_vs_value_hash{$dumpvar}};
      foreach my $dump_vl (@dump_value){
          my $new_sig = &convert_hier_sig_into_inst_sig(@$dump_vl[0]);
          if(exists $output_sig{@$dump_vl[0]}){
            #my $new_sig = &convert_hier_sig_into_inst_sig(@$dump_vl[0]);
            #print WRITE_CMD "assert @$dump_vl[0] @$dump_vl[1]\n";
            #print WRITE_CMD "assert $new_sig @$dump_vl[1]\n";
          }else{
            #print WRITE_CMD "@$dump_vl[1] @$dump_vl[0]\n";
             if(@$dump_vl[1] eq "x"){
               print WRITE_CMD "l $new_sig\n";
             }else {
               print WRITE_CMD "@$dump_vl[1] $new_sig\n";
             } 
          }
        }
    }#foreach
    #print WRITE_CMD "w @port_list_with_hier\n";  
     
    print WRITE_CMD "w @input_sig_list @output_sig_list\n";  
    print WRITE_CMD "logfile $cmd_file.log\n";
    my @time_list = (sort {$a <=> $b} keys %time_vs_value_hash);
    my $temp_time_diff_hash = &calc_time_diff(\@time_list);
    my %time_hash = %$temp_time_diff_hash; 
    foreach my $time (sort {$a <=> $b} keys %time_vs_value_hash){
      my @value = @{$time_vs_value_hash{$time}};
      my $step_size = "";
      if(exists $time_hash{$time}){
        $step_size = $time_hash{$time};
      }
      print WRITE_CMD "stepsize $step_size\n";
      print WRITE_CMD "s\n";
      foreach my $vl (@value){ 
        my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
        if(exists $output_sig{@$vl[0]}){
          #print WRITE_CMD "assert @$vl[0] @$vl[1]\n";
          print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
        }else {
          #print WRITE_CMD "@$vl[1] @$vl[0]\n";
           if(@$vl[1] eq "x"){
             print WRITE_CMD "l $new_sig\n";
           }else {
             print WRITE_CMD "@$vl[1] $new_sig\n";
           }
        } 
      }#foreach
    }#foreach
  }#else 
  print WRITE_CMD "exit\n";
  close (WRIE_CMD);
}#else
}#sub create_cmd_file_from_vcd_old
#-----------------------------------------------------------------------------------------------------------------------#
sub get_input_and_output_list {
my @sig_list = @{$_[0]};
my @all_input_sig = ();
my @all_output_sig = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
foreach my $sig (@sig_list){
 my $pin = "";
 my $digit = "";
 my $temp_sig = $sig; 
 if($temp_sig =~ /\[|</){
   $temp_sig =~ s/\[|</ /; 
   $temp_sig =~ s/\]|>/ /; 
   ($pin,$digit) = (split(/\s+/,$temp_sig))[0,1];
 }else {
   $pin = $temp_sig;
 }
 if (exists $MODULE_ALREADY{$TOP_MODULE}->{ins}{$pin}){
   $sig = $pin.$get_opening_bracket.$digit.$get_closing_bracket if($digit != "");
   push(@all_input_sig,$sig);
 }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{outs}{$pin}){
   $sig = $pin.$get_opening_bracket.$digit.$get_closing_bracket if($digit != ""); 
   push(@all_output_sig,$sig);
 }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{bidis}{$pin}){
   $sig = $pin.$get_opening_bracket.$digit.$get_closing_bracket if($digit != ""); 
   push(@all_input_sig,$sig);
 } 
}#foreach
return (\@all_input_sig,\@all_output_sig);
}#sub get_input_and_output_list
#-----------------------------------------------------------------------------------------------------------------------#
sub check_port_between_verilog_and_vcd {
my @vcd_port = @{$_[0]};
my @verilog_port = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
my @input = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetInput if(exists $MODULE_ALREADY{$TOP_MODULE});
my @output = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetOutput if(exists $MODULE_ALREADY{$TOP_MODULE});
my @bidi = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetBidi if(exists $MODULE_ALREADY{$TOP_MODULE});
foreach my $i (@input){
  my $busWidth = ""; 
  my $type = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetInputType($i) if(exists $MODULE_ALREADY{$TOP_MODULE});
  if(exists $MODULE_ALREADY{$TOP_MODULE}) {
    $busWidth = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetInputBits($i)if ( $type == 1 );
  }
  my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
  my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
  foreach my $bit(@port_with_bit_blast){
    push(@verilog_port,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
    push (@verilog_port,$i)if($bit eq ""); 
  }#foreach bit
}#foreach
#----------------------------------------------------------------------------------------------#
foreach my $i (@output){
  my $busWidth = ""; 
  my $type = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetOutputType($i);
  $busWidth = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetOutputBits($i)if ( $type == 1 );
  my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
  my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
  foreach my $bit(@port_with_bit_blast){
    push(@verilog_port,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
    push (@verilog_port,$i)if($bit eq ""); 
  }#foreach bit
}#foreach
#----------------------------------------------------------------------------------------------#
foreach my $i (@bidi){
  my $busWidth = ""; 
  my $type = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetBidiType($i);
  $busWidth = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetBidiBits($i)if ( $type == 1 );
  my %PORT_BIT_BLAST = &get_vector_bit_blast($i,$busWidth);
  my @port_with_bit_blast = @{$PORT_BIT_BLAST{$i}}; 
  foreach my $bit(@port_with_bit_blast){
    push(@verilog_port,$i."".$get_opening_bracket.$bit.$get_closing_bracket)if($bit ne ""); 
    push (@verilog_port,$i)if($bit eq ""); 
  }#foreach bit
}#foreach
my $number_of_port_of_verilog = @verilog_port;
my $number_of_port_of_vcd = @vcd_port;
if($number_of_port_of_verilog < $number_of_port_of_vcd){
  print "ERR-TE-CREATE_CMD_FILE_FROM_VCD : some port is missing in .vcd file\n";
}
}#sub check_port_between_verilog_and_vcd 
#-----------------------------------------------------------------------------------------------------------------------#
sub convert_sq_brkt_to_angle_brkt {
my @port = @{$_[0]};
my $portName = join"",@port;
my $new_port = "";
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
 if($portName =~ /\[|</){
   $portName =~ s/\[|</ /; 
   $portName =~ s/\]|>/ /; 
   ($pin,$digit) = (split(/\s+/,$portName))[0,1];
   $new_port = $pin.$get_opening_bracket.$digit.$get_closing_bracket;
 }else {
   $new_port = $portName;
 }
return($new_port);
}#sub convert_sq_brkt_to_angle_brkt
#-----------------------------------------------------------------------------------------------------------------------#
sub set_array_index_delimiter {
  if($_[0] eq '-h' || $_[0] eq '-help'){
    print "Usage : set_array_index_delimiter <opening bracket closing bracket>\n";
    return;
  }
  my $opening_bracket = $_[0];
  my $closing_bracket = $_[1]; 
  $GLOBAL->dbfGlobalSelectOpeningBracket($opening_bracket);
  $GLOBAL->dbfGlobalSelectClosingBracket($closing_bracket);
}#sub set_array_index_delimeter
#-----------------------------------------------------------------------------------------------------------------------#
sub get_vector_bit_blast_of_vcd {
my @sig_list = @{$_[0]};
my @port_list_with_hier = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
foreach my $sig (@sig_list){
  my @sig_with_hier = (split(/\./,$sig));
  my $port = pop (@sig_with_hier);
  if($port =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
    my $portName = $port;
    my $busWidth = $port;
    $portName =~ s/\[.*//;
    $busWidth =~ s/.*\[/[/;
    my %PORT_BIT_BLAST = &get_vector_bit_blast($portName,$busWidth); 
    my @port_with_bit_blast = @{$PORT_BIT_BLAST{$portName}};
    foreach my $bit (@port_with_bit_blast){
      my $port_str = $portName.$get_opening_bracket.$bit.$get_closing_bracket;
      my $join_hier_str = join".",@sig_with_hier; 
      push(@port_list_with_hier,$join_hier_str.".".$port_str); 
    }#foreach
  }elsif ($port =~ /\[\s*[0-9]+\s*\]/){
    $port =~ s/\[|</$get_opening_bracket/;
    $port =~ s/\]|>/$get_closing_bracket/;
    my $join_hier_str = join".",@sig_with_hier; 
    push(@port_list_with_hier,$join_hier_str.".".$port); 
  }else {
    my $join_hier_str = join".",@sig_with_hier; 
    push(@port_list_with_hier,$join_hier_str.".".$port); 
  }
}
return(@port_list_with_hier);
}#sub get_vector_bit_blast_of_vcd
#-----------------------------------------------------------------------------------------------------------------------#
sub return_time_vs_value_hash {
my $net = $_[0];
my $value = $_[1];
my @time_vs_value_arr = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
my @net_hier = (split(/\./,$net));
my $net = pop (@net_hier);
if($net =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/){
  my $portName = $net;
  my $busWidth = $net;
  $portName =~ s/\[.*//;
  $busWidth =~ s/.*\[/[/;
  my %PORT_BIT_BLAST = &get_vector_bit_blast($portName,$busWidth); 
  my @port_with_bit_blast = @{$PORT_BIT_BLAST{$portName}};
  my @reverse_bit = reverse (@port_with_bit_blast);
  my @value_list = ();
  foreach my $val (split //,$value){ 
    my $new_val = "";
    if($val == 1){$new_val = "h";
    }elsif($val == 0){$new_val = "l";}
    if($val eq "x"){$new_val = "x";
    }elsif($val eq "z"){$new_val = "z";}
    push (@value_list,$new_val);
  }#foreach
  my @reverse_value = reverse (@value_list);
  for (my $i =0;$i<=$#reverse_bit;$i++){
    my $net_hier_list = join".",@net_hier;
    my $port_bit = $net_hier_list.".".$portName.$get_opening_bracket.$reverse_bit[$i].$get_closing_bracket; 
    push(@time_vs_value_arr,[$port_bit,$reverse_value[$i]]) if($reverse_value[$i] ne "");
    push(@time_vs_value_arr,[$port_bit,"x"]) if($reverse_value[$i] eq "");
  }#for
}elsif ($net =~ /\[\s*[0-9]+\s*\]/){
  $net =~ s/\[|</$get_opening_bracket/;
  $net =~ s/\]|>/$get_closing_bracket/;
  my $net_hier_list = join".",@net_hier;
  my $net = $net_hier_list.".".$net;
  my $new_val = "";
  if($value == 1){$new_val = "h";
  }elsif($value == 0){$new_val = "l";}
  if($value eq "z"){$new_val = "z";
  }elsif($value eq "x"){$new_val = "x";}
  push(@time_vs_value_arr,[$net,$new_val]);
}else {
  my $net_hier_list = join".",@net_hier;
  my $net = $net_hier_list.".".$net;
  my $new_val = "";
  if($value == 1){$new_val = "h";
  }elsif($value == 0){$new_val = "l";}
  if($value eq "z"){$new_val = "z";
  }elsif($value eq "x"){$new_val = "x";}
  push(@time_vs_value_arr,[$net,$new_val]);
}
return (@time_vs_value_arr);
}#sub return_time_vs_value_hash
#-----------------------------------------------------------------------------------------------------------------------#
sub get_dir_wire_full_path {
my @sig_list = @{$_[0]};
my %all_input_sig = ();
my %all_output_sig = ();
if(!%MODULE_ALREADY){print "WARN : We need a VNOM database so, Please read verilog files\n";}
foreach my $sig (@sig_list){
  my @sig_with_hier = (split(/\./,$sig));
  my $join_hier_str = join".",@sig_with_hier; 
  my @temp_sig_with_hier = @sig_with_hier;
  my $port = pop (@temp_sig_with_hier);
  my $scope = pop (@temp_sig_with_hier);
  my $temp_sig = $port;
  my $pin = "";
  my $digit = "";
  if($temp_sig =~ /\[|</){
    $temp_sig =~ s/\[|</ /; 
    $temp_sig =~ s/\]|>/ /; 
    ($pin,$digit) = (split(/\s+/,$temp_sig))[0,1];
  }else {
    $pin = $temp_sig;
  }
  if(%MODULE_ALREADY){
    if($scope eq $TOP_MODULE){
      if(exists $MODULE_ALREADY{$TOP_MODULE}->{ins}{$pin}){ 
        $all_input_sig{$join_hier_str} = 1;
      }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{outs}{$pin}){ 
        $all_output_sig{$join_hier_str} = 1;
      }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{bidis}{$pin}){ 
      }else {
        my @conns = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetConn;
        my ($input,$output) = &get_in_and_out_from_connLine(\@conns); 
        my @input_sig = @$input;
        my @output_sig = @$output;
        foreach my $in (@input_sig){
          if($in eq $pin){
            $all_input_sig{$join_hier_str} = 1;
          }#if
        }#foreach
        foreach my $out (@output_sig){
          if($out eq $pin){
            $all_output_sig{$join_hier_str} = 1;
          }#if
        }#foreach
      }#else
    }elsif($MODULE_ALREADY{$TOP_MODULE}->dbVNOMHasHierInst($scope)){
      my $cellref = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetHierInstCell($scope);
      if(exists $MODULE_ALREADY{$cellref}){
       if(exists $MODULE_ALREADY{$cellref}->{ins}{$pin}){ 
         $all_input_sig{$join_hier_str} = 1;
       }elsif(exists $MODULE_ALREADY{$cellref}->{outs}{$pin}){ 
         $all_output_sig{$join_hier_str} =1;
       }elsif(exists $MODULE_ALREADY{$cellref}->{bidis}{$pin}){ 
       }else {
         print "ERR : $pin is neither input or output of this $cellref\n";
       } 
      }
    }
  }else {
    #print "WARN : We need a VNOM database so, Please read verilog files\n";
  }
}
return (\%all_input_sig,\%all_output_sig);
}#sub get_dir_wire_full_path
#-----------------------------------------------------------------------------------------------------------------------#
sub get_in_and_out_from_connLine {
my @conns = @{$_[0]};
my @input = ();
my @output = ();
foreach my $connLine (@conns){
  $connLine =~ s/\(/\)\,/;
  $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
  my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
  if ($MODULE_ALREADY{$TOP_MODULE}->dbVNOMHasHierInst($inst)){
    my @nets = split(/\s*\)\s*\,\s*/, $connLine);
    my  $noOfPins = @nets;
    for(my $i = 1 ; $i < $noOfPins ; $i++){
      $nets[$i] =~ s/\s*\(\s*/\|/;
      $nets[$i] =~ s/\s*\)\s*//;
      my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
      $pin =~ s/\.//;
      if ( exists $MODULE_ALREADY{$cell}->{ins}{$pin} ) {
        push(@input,$pin);
      }elsif ( exists $MODULE_ALREADY{$cell}->{outs}{$pin} ) {
        push(@output,$pin);
      }#else {print "ERR : $pin is neither input or output\n";}
    }#for
  }#if
}#foreach
return(\@input,\@output);
}#sub get_in_and_out_from_connLine
#-----------------------------------------------------------------------------------------------------------------------#
sub get_hash_from_tb_module {
my $top_module = $_[0];
my $module = $_[1];
my @sig_list = @{$_[2]};
my @conns = $MODULE_ALREADY{$top_module}->dbVNOMGetConn if(exists $MODULE_ALREADY{$top_module});
my %CHECK_NET_HASH = ();
my %all_input_sig = ();
my %all_output_sig = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
foreach my $connLine (@conns){
  $connLine =~ s/\(/\)\,/;
  $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
  my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
  if($cell eq $module){
    my @nets = split(/\s*\)\s*\,\s*/, $connLine);
    my  $noOfPins = @nets;
    for(my $i = 1 ; $i < $noOfPins ; $i++){
      $nets[$i] =~ s/\s*\(\s*/\|/;
      $nets[$i] =~ s/\s*\)\s*//;
      my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
      $pin =~ s/\.//;
      if($net =~ /\[\s*[0-9]+\s*\]/){
         $net =~ s/\[/</;
         $net =~ s/\]/>/;
         $CHECK_NET_HASH{$net} = $pin;
      }else {
        $CHECK_NET_HASH{$net} = $pin;
      }
    }#for
  }
}#foreach
foreach my $sig (@sig_list){
  my @port_with_hier = (split(/\./,$sig));
  if(@port_with_hier == 2){
    my $net = pop @port_with_hier;
    my $temp_net = $net;
    my $netName;
    my $bit;
    if($temp_net =~ /\<\s*[0-9]+\s*\>/){
      $temp_net =~ s/</ /;
      $temp_net =~ s/>/ /;
      ($netName,$bit) = (split(/\s+/,$temp_net))[0,1];
    }else {
      $netName = $net;
    }
    my $scope = pop @port_with_hier;
    if($scope eq $top_module){
      if(exists $CHECK_NET_HASH{$netName}){
        my $port = $CHECK_NET_HASH{$netName};
        if(exists $MODULE_ALREADY{$module}->{ins}{$port}){
           $all_input_sig{"$scope.$port$get_opening_bracket$bit$get_closing_bracket"} = 1 if($bit ne "");
           $all_input_sig{"$scope.$port"} = 1 if($bit eq "");
        }elsif(exists $MODULE_ALREADY{$module}->{outs}{$port}){
           $all_output_sig{"$scope.$port$get_opening_bracket$bit$get_closing_bracket"} = 1 if($bit ne "");
           $all_output_sig{"$scope.$port"} = 1 if($bit eq "");
        }else {print "$port is neither input or output\n";}
      }elsif(exists $CHECK_NET_HASH{$net}){
        my $port = $CHECK_NET_HASH{$net};
        if(exists $MODULE_ALREADY{$module}->{ins}{$port}){
           $port=~ s/\[/</;
           $port=~ s/\]/>/;
           $all_input_sig{"$scope.$port"} = 1 ;
        }elsif(exists $MODULE_ALREADY{$module}->{outs}{$port}){
           $port=~ s/\[/</;
           $port=~ s/\]/>/;
           $all_output_sig{"$scope.$port"} = 1 ;
        }else {print "$port is neither input or output\n";}
      }   
    }else {print "ERR : $scope is not a top module\n";} 
  }#if port_with_hier==2 
}#foreach 
return(\%all_input_sig,\%all_output_sig,\%CHECK_NET_HASH);
}#sub get_hash_from_tb_module
#-----------------------------------------------------------------------------------------------------------------------#
sub calc_time_diff {
my @time = @{$_[0]};
my %temp_time_diff_hash = ();
for(my $i=0;$i<=$#time;$i++){
  my $time_diff = $time[$i+1] - $time[$i] ;
  $temp_time_diff_hash{$time[$i+1]} = $time_diff;
}#for
  $temp_time_diff_hash{$time[0]} = $time[0];
foreach my  $key (keys %temp_time_diff_hash){
  #print "$key => $temp_time_diff_hash{$key}\n";
}
return (\%temp_time_diff_hash);
}#sub calc_time_diff
#-----------------------------------------------------------------------------------------------------------------------#
sub convert_hier_sig_into_inst_sig {
 my $sigName = $_[0]; 
 my $new_sig = "";
 my @sig_with_hier = (split(/\./,$sigName));
 if(@sig_with_hier == 2){
   shift (@sig_with_hier);
   $new_sig = join "",@sig_with_hier; 
 }else {
   shift (@sig_with_hier);
   my $scope = shift (@sig_with_hier);
   my $port = shift (@sig_with_hier);
   if(%MODULE_ALREADY){
    if($MODULE_ALREADY{$TOP_MODULE}->dbVNOMHasHierInst($scope)){
      my $cellref = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetHierInstCell($scope);
      my $inst = "X"."_".$cellref;
      $new_sig = $inst.".".$port;  
    }
   }
  #&convert_hier_sig_into_inst_sig($sigName);
 }
 return ($new_sig);
}#sub convert_hier_sig_into_inst_sig
#-----------------------------------------------------------------------------------------------------------------------#
sub convert_input_and_output_sig_list {
my $in_sig = $_[0];
my $out_sig = $_[1];
my %input_sig = %$in_sig;
my %output_sig = %$out_sig;
my @input_sig_list = keys %input_sig;
my @output_sig_list = keys %output_sig;
my @new_in_sig_list = ();
my @new_out_sig_list = ();
foreach my $in (@input_sig_list){
  my $new_sig = &convert_hier_sig_into_inst_sig($in);
  push(@new_in_sig_list,$new_sig);
}#foreach
foreach my $out (@output_sig_list){
  my $new_sig = &convert_hier_sig_into_inst_sig($out);
  push(@new_out_sig_list,$new_sig);
}#foreach
return (\@new_in_sig_list,\@new_out_sig_list);
}#sub convert_input_and_output_sig_list
#-----------------------------------------------------------------------------------------------------------------------#
sub create_cmd_file_from_vcd {
use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){print "Usage : create_cmd_file_from_vcd\n";
                                        print "      : -vcd<fileName>\n";
                                        print "      : -cmd<output_fileName>\n";
                                        print "      : -tb_module <top_module>\n";
                                        print "      : -module <{list of moduleName>}\n";
                                        print "      : --blio_write\n";
                                       }
else {
  my $cmd_file = $TOP_MODULE;
  my $tb_module_found = 0;
  my $mod = "";
  my $blio_write = 0;
  for(my $i =0; $i<$noOfArguments;$i++){
    if($_[$i] eq "-vcd"){$vcd_file = $_[$i+1];} 
    if($_[$i] eq "-cmd"){$cmd_file = $_[$i+1];} 
    if($_[$i] eq "-tb_module"){$tb_module = $_[$i+1];$tb_module_found = 1;}
    if($_[$i] eq "-module"){$mod = $_[$i+1];}
    if($_[$i] eq "--blio_write") {$blio_write = 1;}
  }#for
my %data;
my $mult;
my @hier;
my $time = 0;
my $time_cnt = 0;
my %temp_time_hash = ();
my %CHECK_NET_HASH = ();
my @input_sig_list = ();
my @output_sig_list = ();
my %input_sig = ();
my %output_sig = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
open(READ_VCD,$vcd_file);
open(WRITE_CMD,">$cmd_file.cmd");
print WRITE_CMD "blio open $TOP_MODULE.blio.gz\n" if($blio_write == 1);
while(<READ_VCD>){
  chomp();
  if($_ =~ /^\s*\$timescale\b/){
    my $statement = $_;
    my $line;
    if ($line =~ /^\s*\$end\b/) {}
     unless (/ \$end \b /x) {
       do {
         $line = <READ_VCD>;
         $statement .= " $line";
       } until ($line =~ / \$end \b /x);
     }
     $mult = &calc_mult($statement,{timescale => 'ns'});
  }
  elsif ($_ =~ /^\s*\$scope\b/) {
    #push @hier, (split)[2];
    my $scope = (split(/\s+/,$_))[2];
    push(@hier,$scope);
  }
  elsif ($_ =~ /^\s*\$upscope\b/) {
   pop @hier;
  }
  elsif ($_ =~ /^\s*\$var\b/) {
    my (undef, $type, $size, $code, $temp_name,$bus) = (split (/\s+/, $_))[0,1,2,3,4,5];
    my $name;
    if($bus =~ /\[/){
      $name = $temp_name."".$bus;
    }else {
      $name = $temp_name;
    }
    $name =~ s/\s+\$end .*//;
    $name =~ s/\s//g;
    my $path = join '.', @hier;
    my $full_name = "$path.$name";
    push (@{$data{$code}},$full_name);
  }elsif($_ =~ /^\s*\$dumpvars\b/){
    my $statement = $_;
    my $line;
    my @sigs_list = ();
    foreach my $code (keys %data){
      push (@sigs_list,@{$data{$code}});
    }
    if((exists $MODULE_ALREADY{$tb_module}) && (exists $MODULE_ALREADY{$mod})){
      my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs_list);
      my ($all_input_sig,$all_output_sig,$check_net_hash) = &get_hash_from_tb_module($tb_module,$mod,\@port_list_with_hier);
      %input_sig = %$all_input_sig;
      %output_sig = %$all_output_sig;
      my ($all_input_sig_list ,$all_output_sig_list) = &convert_input_and_output_sig_list($all_input_sig,$all_output_sig);
      @input_sig_list = @$all_input_sig_list;
      @output_sig_list = @$all_output_sig_list;
      %CHECK_NET_HASH = %$check_net_hash;
    }if ((%MODULE_ALREADY && $tb_module_found == 0) || (exists $MODULE_ALREADY{$tb_module})){
      my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs_list);
      my ($all_input_sig,$all_output_sig,$check_net_hash) = &get_hash_from_top_module(\@port_list_with_hier);
      %input_sig = %$all_input_sig;
      %output_sig = %$all_output_sig;
      my ($all_input_sig_list ,$all_output_sig_list) = &convert_input_and_output_sig_list($all_input_sig,$all_output_sig);
      @input_sig_list = @$all_input_sig_list;
      @output_sig_list = @$all_output_sig_list;
      %CHECK_NET_HASH = %$check_net_hash;
    }
    unless (/\$end\b/) {
      do {
        $line = <READ_VCD>;
        chomp($line);
        if($line =~ /^([01zx])(.+)/i ){
           my $value = lc $1;
           my $code  = $2;
           if (exists $data{$code}) {
             my @sigs = @{$data{$code}};
             #my $net_str = join "",@sigs;
             my $net_str = $sigs[0];
             if((exists $MODULE_ALREADY{$tb_module}) && (exists $MODULE_ALREADY{$mod})){
               my @net_hier = (split(/\./,$net_str));
               if(@net_hier == 2){
                 my @value_arr = &return_time_vs_value_hash($net_str,$value);
                 foreach my $vl (@value_arr){
                   my $net = @$vl[0];
                   $net =~s/.*\.//;
                   if(exists $CHECK_NET_HASH{$net}){
                     my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                     my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                     if($new_vl == 0){
                       if(@$vl[1] eq "x"){
                         print WRITE_CMD "l $new_sig\n";
                       }else {
                         print WRITE_CMD "@$vl[1] $new_sig\n";
                       }
                     }
                   }
                 }
               }
             }elsif ((%MODULE_ALREADY && $tb_module_found == 0)||(exists $MODULE_ALREADY{$tb_module})){
               my @net_hier = (split(/\./,$net_str));
               if(@net_hier == 2){
                 my @value_arr = &return_time_vs_value_hash($net_str,$value);
                 foreach my $vl (@value_arr){
                   my $net = @$vl[0];
                   $net =~s/.*\.//;
                   if(exists $CHECK_NET_HASH{$net}){
                     my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                     my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                     if($new_vl == 0){
                       if(@$vl[1] eq "x"){
                         print WRITE_CMD "l $new_sig\n";
                       }else {
                         print WRITE_CMD "@$vl[1] $new_sig\n";
                       }
                     }
                   }
                 }
               }
             }elsif(!%MODULE_ALREADY){
               my @value_arr = &return_time_vs_value_hash($net_str,$value);
               foreach my $vl (@value_arr){
                 my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                 my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                 push(@input_sig_list,$new_sig) if($new_sig ne "");
                 if($new_vl == 0){
                   if(@$vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n"if($new_sig ne "");
                   }else {
                     print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig ne "");
                   }
                 }
               }#foreach
             }elsif ((!exists $MODULE_ALREADY{$tb_module}) || (!exists $MODULE_ALREADY{$mod})){
               my @value_arr = &return_time_vs_value_hash($net_str,$value);
               foreach my $vl (@value_arr){
                 my @net_hier = (split(/\./,@$vl[0]));
                 my $tb_mod = shift (@net_hier);
                 if($tb_mod ne $tb_module){print "ERR : $tb_module not exists in .vcd file and .cmd file is blank\n";exit;}
                 else {
                 my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                 my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                 push(@input_sig_list,$new_sig) if($new_sig !~ /X_/i);
                 #if($new_vl == 0){
                   if(@$vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n"if($new_sig !~ /X_/i);
                   }else {
                     print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig !~ /X_/i);
                   }
                 #}
                 }
               }#foreach
             }
           }
        }elsif($line =~  /^[br](\S+)\s+(.+)/i){
          my $value = lc $1;
          my $code  = $2;
          if (exists $data{$code}) {
            my @sigs = @{$data{$code}};
             my $net_str = join "",@sigs;
             if((exists $MODULE_ALREADY{$tb_module}) && (exists $MODULE_ALREADY{$mod})) {
               my @net_hier = (split(/\./,$net_str));
               my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs);
               if(@net_hier == 2){
                 my @value_arr = &return_time_vs_value_hash($net_str,$value);
                 foreach my $vl (@value_arr){
                   my $net = @$vl[0];
                   $net=~ s/.*\.//;
                   if($net =~ /\[|</){
                     $net =~ s/\[|</ /;
                     $net =~ s/\]|>/ /;
                     my ($netName,$digit) = (split(/\s+/,$net))[0,1];
                     if(exists $CHECK_NET_HASH{$netName}){
                       my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                       my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                       if($new_vl == 0){
                         if(@$vl[1] eq "x"){
                           print WRITE_CMD "l $new_sig\n";
                         }else {
                           print WRITE_CMD "@$vl[1] $new_sig\n";
                         }
                       }
                     }
                   }else {
                     if(exists $CHECK_NET_HASH{$net}){
                       my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                       my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                       if($new_vl == 0){
                         if(@$vl[1] eq "x"){
                           print WRITE_CMD "l $new_sig\n";
                         }else {
                           print WRITE_CMD "@$vl[1] $new_sig\n";
                         }
                       }
                     }
                   }
                 }#foreach
               }#if net_hier == 2
             }elsif((%MODULE_ALREADY && $tb_module_found == 0)||(exists $MODULE_ALREADY{$tb_module})){
               my @net_hier = (split(/\./,$net_str));
               my @port_list_with_hier = &get_vector_bit_blast_of_vcd(\@sigs);
               if(@net_hier == 2){
                 my @value_arr = &return_time_vs_value_hash($net_str,$value);
                 foreach my $vl (@value_arr){
                   my $net = @$vl[0];
                   $net=~ s/.*\.//;
                   if($net =~ /\[|</){
                     $net =~ s/\[|</ /;
                     $net =~ s/\]|>/ /;
                     my ($netName,$digit) = (split(/\s+/,$net))[0,1];
                     if(exists $CHECK_NET_HASH{$netName}){
                       my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                       my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                       if($new_vl == 0){
                         if(@$vl[1] eq "x"){
                           print WRITE_CMD "l $new_sig\n";
                         }else {
                           print WRITE_CMD "@$vl[1] $new_sig\n";
                         }
                       }
                     }
                   }else {
                     if(exists $CHECK_NET_HASH{$net}){
                       my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                       my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                       if($new_vl == 0){
                         if(@$vl[1] eq "x"){
                           print WRITE_CMD "l $new_sig\n";
                         }else {
                           print WRITE_CMD "@$vl[1] $new_sig\n";
                         }
                       }
                     }
                   }
                 }#foreach
               }#if net_hier == 2
             }elsif(!%MODULE_ALREADY){
               my @value_arr = &return_time_vs_value_hash($net_str,$value);
               foreach my $vl (@value_arr){
                 my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                 my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                 push(@input_sig_list,$new_sig) if($new_sig ne "");
                 if($new_vl == 0){
                   if(@$vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n"if($new_sig ne "");
                   }else {
                     print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig ne "");
                   }
                 }
               }#foreach
             }elsif((!exists $MODULE_ALREADY{$tb_module}) || (!exists $MODULE_ALREADY{$mod})){
               my @value_arr = &return_time_vs_value_hash($net_str,$value);
               foreach my $vl (@value_arr){
                 my $new_vl = &check_signal_input_or_output(@$vl[0]); 
                 my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
                 push(@input_sig_list,$new_sig) if($new_sig !~ /X_/i);
                 #if($new_vl == 0){
                   if(@$vl[1] eq "x"){
                     print WRITE_CMD "l $new_sig\n"if($new_sig !~ /X_/i);
                   }else {
                     print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig !~ /X_/i);
                   }
                 #}
               }#foreach
             } 
          }
        }
      } until ($line =~ /\$end\b/);
    }
    print WRITE_CMD "w @input_sig_list @output_sig_list\n";
    print WRITE_CMD "logfile $cmd_file.log \n";
  }elsif ($_ =~ /^[#](\d+)/) {
    my ($prev,$val) = each %temp_time_hash;
#   $time = $mult * $1;
    $time =  $1;
    $endtime = $time;
    if($time == 0){$time_cnt++;
      my $diff = ($time - $prev)* $mult;
      print WRITE_CMD "stepsize $diff\n"if($time_cnt > 1);
      print WRITE_CMD "s\n" if($time_cnt > 1);
    }else {
      my $diff = ($time - $prev)* $mult;
      print WRITE_CMD "stepsize $diff\n";
      print WRITE_CMD "s\n";
    }
    %temp_time_hash = ();
    $temp_time_hash{$time} = $time;
  }
  elsif ($_ =~ /^([01zx])(.+)/i || /^[br](\S+)\s+(.+)/i) {
     my $value = lc $1;
     my $code  = $2;
     if (exists $data{$code}) {
       my @sigs = @{$data{$code}};
       #print "$code => @sigs => $value\n"; 
       my @value_list = &return_time_vs_value_hash(@sigs,$value);
         foreach my $vl (@value_list){
           if((exists $MODULE_ALREADY{$tb_module}) && (exists $MODULE_ALREADY{$mod})) {
             my @net_hier = (split(/\./,@$vl[0]));
             if(@net_hier == 2){
               my $net = pop @net_hier;
               my $hier_path = join "",@net_hier;
               if($net =~ /\[|</){
                 $net =~ s/\[|</ /;
                 $net =~ s/\]|>/ /;
                 my ($netName,$digit) = (split(/\s+/,$net))[0,1];
                 if(exists $CHECK_NET_HASH{$netName}){
                   my $port = $CHECK_NET_HASH{$netName};
                   my $full_path = ""; 
                   $full_path = "$hier_path.$port$get_opening_bracket$digit$get_closing_bracket" if($digit ne ""); 
                   $full_path = "$hier_path.$port" if($digit eq "");
                   my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                   if(exists $output_sig{$full_path}){
                     print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
                   }else {
                     if(@$vl[1] eq "x"){
                       print WRITE_CMD "l $new_sig\n";
                     }else {
                       print WRITE_CMD "@$vl[1] $new_sig\n";
                     }
                   }
                 }  
             }else {
              if(exists $CHECK_NET_HASH{$net}){
                my $port = $CHECK_NET_HASH{$net};
                my $full_path = "$hier_path.$port";
                my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                if(exists $output_sig{$full_path}){
                  print WRITE_CMD "assert $new_sig @$vl[1] \n" if(@$vl[1] ne "x");
                }else {
                  if(@$vl[1] eq "x"){
                    print WRITE_CMD "l $new_sig\n";
                  }else {
                    print WRITE_CMD "@$vl[1] $new_sig\n";
                  }
                }
              }
            }
             }
           }elsif((%MODULE_ALREADY && $tb_module_found == 0)||(exists $MODULE_ALREADY{$tb_module})) {
             my @net_hier = (split(/\./,@$vl[0]));
             if(@net_hier == 2){
               my $net = pop @net_hier;
               my $hier_path = join "",@net_hier;
               if($net =~ /\[|</){
                 $net =~ s/\[|</ /;
                 $net =~ s/\]|>/ /;
                 my ($netName,$digit) = (split(/\s+/,$net))[0,1];
                 if(exists $CHECK_NET_HASH{$netName}){
                   my $port = $CHECK_NET_HASH{$netName};
                   my $full_path = ""; 
                   $full_path = "$hier_path.$port$get_opening_bracket$digit$get_closing_bracket" if($digit ne ""); 
                   $full_path = "$hier_path.$port" if($digit eq "");
                   my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                   if(exists $output_sig{$full_path}){
                     print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
                   }else {
                     if(@$vl[1] eq "x"){
                       print WRITE_CMD "l $new_sig\n";
                     }else {
                       print WRITE_CMD "@$vl[1] $new_sig\n";
                     }
                   }
                }  
             }else {
              if(exists $CHECK_NET_HASH{$net}){
                my $port = $CHECK_NET_HASH{$net};
                my $full_path = "$hier_path.$port";
                my $new_sig = &convert_hier_sig_into_inst_sig($full_path);
                if(exists $output_sig{$full_path}){
                  print WRITE_CMD "assert $new_sig @$vl[1] \n" if(@$vl[1] ne "x");
                }else {
                  if(@$vl[1] eq "x"){
                    print WRITE_CMD "l $new_sig\n";
                  }else {
                    print WRITE_CMD "@$vl[1] $new_sig\n";
                  }
                }
              }
            }
           }
           }elsif(!%MODULE_ALREADY){
             my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
             if(exists $output_sig{@$vl[0]}){
               print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
             }else {
               if(@$vl[1] eq "x"){
                 print WRITE_CMD "l $new_sig\n"if($new_sig ne "");
               }else {
                 print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig ne "");
               }
             }
           }elsif((!exists $MODULE_ALREADY{$tb_module}) || (!exists $MODULE_ALREADY{$mod})){
             my $new_sig = &convert_hier_sig_into_inst_sig(@$vl[0]);
             if(exists $output_sig{@$vl[0]}){
               print WRITE_CMD "assert $new_sig @$vl[1]\n" if(@$vl[1] ne "x");
             }else {
               if(@$vl[1] eq "x"){
                 print WRITE_CMD "l $new_sig\n"if($new_sig !~ /X_/i);
               }else {
                 print WRITE_CMD "@$vl[1] $new_sig\n"if($new_sig !~ /X_/i);
               }
             }
           }
         }#foreach
     }
  }
}#while
print WRITE_CMD "exit\n";
close (WRITE_CMD);
}#else
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command create_cmd_file_from_vcd took:",timestr($td),"\n";
}#sub create_cmd_file_from_vcd
#-----------------------------------------------------------------------------------------------------------------------#
sub calc_mult {
    
    my ($statement, $opt) = @_;

    my @fields = split /\s+/, $statement;
    pop   @fields;
    shift @fields; 
    my $tscale = join '', @fields;

    my $new_units;
    if (exists $opt->{timescale}) {
        $new_units = lc $opt->{timescale};
        $new_units =~ s/\s//g;
        $timescale = "1$new_units";
    }
    else {
        $timescale = $tscale;
        return 1;
    }

    my $mult;
    my $units;
    if ($tscale =~ / (\d+) ([a-z]+) /xi) {
        $mult  = $1;
        $units = lc $2;
    }
   
    my %mults = (
        'fs' => 1e-15,
        'ps' => 1e-12,
        'ns' => 1e-09,
        'us' => 1e-06,
        'ms' => 1e-03,
         's' => 1e-00,
    );
    my $usage = join '|', sort { $mults{$a} <=> $mults{$b} } keys %mults;

    my $scale;
    if (exists $mults{$units}) {
        $scale = $mults{$units};
    }
    my $new_scale;
    if (exists $mults{$new_units}) {
        $new_scale = $mults{$new_units};
    }
    return (($mult * $scale) / $new_scale);
}
#------------------------------------------------------------------------------------------------------------#
sub check_signal_input_or_output {
  my $sig = $_[0];
  my @sig_with_hier = (split(/\./,$sig));
  my $join_hier_str = join".",@sig_with_hier; 
  my @temp_sig_with_hier = @sig_with_hier;
  my $port = pop (@temp_sig_with_hier);
  my $scope = pop (@temp_sig_with_hier);
  my $temp_sig = $port;
  my $pin = "";
  my $digit = "";
  if($temp_sig =~ /\[|</){
    $temp_sig =~ s/\[|</ /; 
    $temp_sig =~ s/\]|>/ /; 
    ($pin,$digit) = (split(/\s+/,$temp_sig))[0,1];
  }else {
    $pin = $temp_sig;
  }
  if(%MODULE_ALREADY){
    if($scope eq $TOP_MODULE){
      if(exists $MODULE_ALREADY{$TOP_MODULE}->{ins}{$pin}){
       return(0);
      }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{outs}{$pin}){
       return(1);
      }elsif(exists $MODULE_ALREADY{$TOP_MODULE}->{bidis}{$pin}){ 
      }else {
        my @conns = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetConn;
        my ($input,$output) = &get_in_and_out_from_connLine(\@conns); 
        my @input_sig = @$input;
        my @output_sig = @$output;
        foreach my $in (@input_sig){
          if($in eq $pin){
            return(0);
          }#if
        }#foreach
        foreach my $out (@output_sig){
          if($out eq $pin){
            return(1);
          }#if
        }#foreach
      }#else
    }elsif ($MODULE_ALREADY{$TOP_MODULE}->dbVNOMHasHierInst($scope)){
      my $cellref = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetHierInstCell($scope);
      if(exists $MODULE_ALREADY{$cellref}){
        if(exists $MODULE_ALREADY{$cellref}->{ins}{$pin}){ 
          return (0);
        }elsif(exists $MODULE_ALREADY{$cellref}->{outs}{$pin}){ 
          return (1);
        }elsif(exists $MODULE_ALREADY{$cellref}->{bidis}{$pin}){ 
        }else {
          print "ERR : $pin is neither input or output of this $cellref\n";
        } 
      }
    }
  }
}#sub check_signal_input_or_output
#------------------------------------------------------------------------------------------------------------#
sub get_hash_from_top_module {
my @sig_list = @{$_[0]};
my %CHECK_NET_HASH = ();
my %all_input_sig = ();
my %all_output_sig = ();
my $get_opening_bracket = $GLOBAL->dbfGlobalGetOpeningBracket;
my $get_closing_bracket = $GLOBAL->dbfGlobalGetClosingBracket;
my @conns = $MODULE_ALREADY{$TOP_MODULE}->dbVNOMGetConn if(exists $MODULE_ALREADY{$TOP_MODULE});
my $connLine = @conns[0];
my $module = "";
foreach my $connLine (@conns){
$connLine =~ s/\(/\)\,/;
$connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
my @conns_cell = $MODULE_ALREADY{$cell}->dbVNOMGetConn;
if(@conns_cell != 0){
  my @nets = split(/\s*\)\s*\,\s*/, $connLine);
  my  $noOfPins = @nets;
  $module = $cell;
  for(my $i = 1 ; $i < $noOfPins ; $i++){
    $nets[$i] =~ s/\s*\(\s*/\|/;
    $nets[$i] =~ s/\s*\)\s*//;
    my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
    $pin =~ s/\.//;
    if($net =~ /\[\s*[0-9]+\s*\]/){
       $net =~ s/\[/</;
       $net =~ s/\]/>/;
       $CHECK_NET_HASH{$net} = $pin;
    }else {
      $CHECK_NET_HASH{$net} = $pin;
    }
  }#for
}#if 
}#for
foreach my $sig (@sig_list){
  my @port_with_hier = (split(/\./,$sig));
  if(@port_with_hier == 2){
    my $net = pop @port_with_hier;
    my $temp_net = $net;
    my $netName;
    my $bit;
    if($temp_net =~ /\<\s*[0-9]+\s*\>/){
      $temp_net =~ s/</ /;
      $temp_net =~ s/>/ /;
      ($netName,$bit) = (split(/\s+/,$temp_net))[0,1];
    }else {
      $netName = $net;
    }
    my $scope = pop @port_with_hier;
    if($scope eq $TOP_MODULE){
      if(exists $CHECK_NET_HASH{$netName}){
        my $port = $CHECK_NET_HASH{$netName};
        if(exists $MODULE_ALREADY{$module}->{ins}{$port}){
           $all_input_sig{"$scope.$port$get_opening_bracket$bit$get_closing_bracket"} = 1 if($bit ne "");
           $all_input_sig{"$scope.$port"} = 1 if($bit eq "");
        }elsif(exists $MODULE_ALREADY{$module}->{outs}{$port}){
           $all_output_sig{"$scope.$port$get_opening_bracket$bit$get_closing_bracket"} = 1 if($bit ne "");
           $all_output_sig{"$scope.$port"} = 1 if($bit eq "");
        }else {print "$port is neither input or output\n";}
      }elsif(exists $CHECK_NET_HASH{$net}){
        my $port = $CHECK_NET_HASH{$net};
        if(exists $MODULE_ALREADY{$module}->{ins}{$port}){
           $port=~ s/\[/</;
           $port=~ s/\]/>/;
           $all_input_sig{"$scope.$port"} = 1 ;
        }elsif(exists $MODULE_ALREADY{$module}->{outs}{$port}){
           $port=~ s/\[/</;
           $port=~ s/\]/>/;
           $all_output_sig{"$scope.$port"} = 1 ;
        }else {print "$port is neither input or output\n";}
      }   
    }#else {#print "ERR : $scope is not a top module\n";} 
  }#if port_with_hier==2 
}#foreach 
return(\%all_input_sig,\%all_output_sig,\%CHECK_NET_HASH);
}#sub get_hash_from_top_module 
#------------------------------------------------------------------------------------------------------------#

1;
