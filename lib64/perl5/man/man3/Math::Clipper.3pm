.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::Clipper 3"
.TH Math::Clipper 3 "2015-06-07" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Math::Clipper \- Polygon clipping in 2D
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Math::Clipper \*(Aq:all\*(Aq;
\&
\& my $clipper = Math::Clipper\->new;
\&
\& $clipper\->add_subject_polygon( [ [\-100,  100], [  0, \-200], [100, 100] ] );
\& $clipper\->add_clip_polygon(    [ [\-100, \-100], [100, \-100], [  0, 200] ] );
\& my $result = $clipper\->execute(CT_DIFFERENCE);
\& # $result is now a reference to an array of three triangles
\&
\& $clipper\->clear();
\& # all data from previous operation cleared
\& # object ready for reuse
\&
\&
\& # Example with floating point coordinates:
\& # Clipper requires integer input. 
\& # These polygons won\*(Aqt work.
\&
\& my $poly_1 = [
\&               [\-0.001, 0.001],
\&               [0, \-0.002],
\&               [0.001, 0.001]
\&              ];
\& my $poly_2 = [
\&               [\-0.001, \-0.001],
\&               [0.001, \-0.001],
\&               [0, 0.002]
\&              ];
\&
\& # But we can have them automatically scaled up (in place) to a safe integer range
\&
\& my $scale = integerize_coordinate_sets( $poly_1 , $poly_2 );
\& $clipper\->add_subject_polygon( $poly_1 );
\& $clipper\->add_clip_polygon(    $poly_2 );
\& my $result = $clipper\->execute(CT_DIFFERENCE);
\& # to convert the results (in place) back to the original scale:
\& unscale_coordinate_sets( $scale, $result );
\&
\& # Example using 32 bit integer math instead of the default 53 or 64
\& # (less precision, a bit faster)
\& my $clipper32 = Math::Clipper\->new;
\& my $scale32 = integerize_coordinate_sets( { bits=>32 } , $poly_1 , $poly_2 );
\& $clipper32\->add_subject_polygon( $poly_1 );
\& $clipper32\->add_clip_polygon(    $poly_2 );
\& my $result32 = $clipper\->execute(CT_DIFFERENCE);
\& unscale_coordinate_sets( $scale32, $result32 );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Clipper\*(C'\fR is a \*(C+ (and Delphi) library that implements
polygon clipping.
.SS "Exports"
.IX Subsection "Exports"
The module optionally exports a few constants to your
namespace. Standard Exporter semantics apply
(including the \f(CW\*(C`:all\*(C'\fR tag).
.PP
The list of exportable constants is comprised of
the clip operation types (which should be self-explanatory):
.PP
.Vb 4
\&    CT_INTERSECTION
\&    CT_UNION
\&    CT_DIFFERENCE
\&    CT_XOR
.Ve
.PP
Additionally, there are constants that set the polygon fill type
during the clipping operation:
.PP
.Vb 4
\&    PFT_EVENODD
\&    PFT_NONZERO
\&    PFT_POSITIVE
\&    PFT_NEGATIVE
.Ve
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
\&\fI\s-1INTEGERS\s0\fR: Clipper 4.x works with polygons with integer coordinates.
Data in floating point format will need to be scaled appropriately
to be converted to the available integer range before polygons are
added to a clipper object. (Scaling utilities are provided here.)
.PP
A \fIPolygon\fR is represented by a reference to an array of 2D points.
A \fIPoint\fR is, in turn, represented by a reference to an array containing two
numbers: The \fIX\fR and \fIY\fR coordinates. A 1x1 square polygon example:
.PP
.Vb 4
\&  [ [0, 0],
\&    [1, 0],
\&    [1, 1],
\&    [0, 1] ]
.Ve
.PP
Sets of polygons, as returned by the \f(CW\*(C`execute\*(C'\fR method, 
are represented by an array reference containing 0 or more polygons.
.PP
Clipper also has a polygon type that explicitly associates an outer polygon with
any additional polygons that describe \*(L"holes\*(R" in the filled region of the
outer polygon. This is called an \fIExPolygon\fR. The data structure for 
an \fIExPolygon\fR is as follows,:
.PP
.Vb 6
\&  { outer => [ <polygon> ],
\&    holes => [ 
\&               [ <polygon> ],
\&               [ <polygon> ],
\&               ...
\&             ]
\&  
\&  }
.Ve
.PP
Clipper additionally offers an export type named \fIPolyTree\fR which represents several
nested polygons by assigning each one to its parent. The \fIPolyTree\fR structure is an
arrayref looking like this one:
.PP
.Vb 10
\&  [
\&      { outer => [ ..points.. ], children => [] },
\&      {
\&         outer => [ ..points.. ],
\&         children => [
\&            { hole => [ ..points.. ], children => [] },
\&            { hole => [ ..points.. ], children => [] },
\&         ],
\&      }
\&  ]
.Ve
.PP
Each item is a hashref which may contain either the \fIcontour\fR or the \fIhole\fR
key, containing the polygon points. It also contains a \fIchildren\fR key containing
an arrayref of hashrefs itself, and so on.
The Clipper documentation reports that it's more computationally expensive to process 
(roughly 5\-10% slower), it should only be used when parent-child polygon relationships 
are needed and not just polygon coordinates.
.PP
The \*(L"fill type\*(R" of a polygon refers to the strategy used to determine
which side of a polygon is the inside, and whether a polygon represents
a filled region, or a hole. You may optionally specify the fill type of
your subject and clip polygons when you call the \f(CW\*(C`execute\*(C'\fR method.
.PP
When you specify the \s-1NONZERO\s0 fill type, the winding order of
polygon points determines whether a polygon is filled, or represents a hole.
Clipper uses the convention that counter clockwise wound polygons 
are filled, while clockwise wound polygons represent holes. This
strategy is more explicit, but requires that you manage winding order of all polygons.
.PP
The \s-1EVENODD\s0 fill type strategy uses a test segment, with it's start point inside a polygon,
and it's end point out beyond the bounding box of all polygons in question. All intersections 
between the segment and all polygons are calculated. If the intersection
count is odd, the inner-most (if nested) polygon containing the segment's start point is considered to be
filled. When the intersection count is even, that polygon is considered to be a hole.
.PP
For an example case in which \s-1NONZERO\s0 and \s-1EVENODD\s0 produce different results see 
\&\*(L"\s-1NONZERO\s0 vs. \s-1EVENODD\*(R"\s0 section below.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Constructor that takes no arguments returns a new
\&\f(CW\*(C`Math::Clipper\*(C'\fR object.
.SS "add_subject_polygon"
.IX Subsection "add_subject_polygon"
Adds a(nother) polygon to the set of polygons that
will be clipped.
.SS "add_clip_polygon"
.IX Subsection "add_clip_polygon"
Adds a(nother) polygon to the set of polygons that
define the clipping operation.
.SS "add_subject_polygons"
.IX Subsection "add_subject_polygons"
Works the same as \f(CW\*(C`add_subject_polygon\*(C'\fR but
adds a whole set of polygons.
.SS "add_clip_polygons"
.IX Subsection "add_clip_polygons"
Works the same as \f(CW\*(C`add_clip_polygon\*(C'\fR but
adds a whole set of polygons.
.SS "execute"
.IX Subsection "execute"
Performs the actual clipping operation.
Returns the result as a reference to an array of polygons.
.PP
.Vb 1
\&    my $result = $clipper\->execute( CT_UNION );
.Ve
.PP
Parameters: the type of the clipping operation defined
by one of the constants (\f(CW\*(C`CT_*\*(C'\fR).
.PP
Additionally, you may define the polygon fill types (\f(CW\*(C`PFT_*\*(C'\fR)
of the subject and clipping polygons as second and third parameters
respectively. By default, even-odd filling (\f(CW\*(C`PFT_EVENODD\*(C'\fR) will be
used.
.PP
.Vb 1
\&    my $result = $clipper\->execute( CT_UNION, PFT_EVENODD, PFT_EVENODD );
.Ve
.SS "ex_execute"
.IX Subsection "ex_execute"
Like \f(CW\*(C`execute\*(C'\fR, performs the actual clipping operation, but
returns a reference to an array of ExPolygons. (see \*(L"\s-1CONVENTIONS\*(R"\s0)
.SS "pt_execute"
.IX Subsection "pt_execute"
Like \f(CW\*(C`execute\*(C'\fR, performs the actual clipping operation, but
returns a PolyTree structure. (see \*(L"\s-1CONVENTIONS\*(R"\s0)
.SS "clear"
.IX Subsection "clear"
For reuse of a \f(CW\*(C`Math::Clipper\*(C'\fR object, you can call the
\&\f(CW\*(C`clear\*(C'\fR method to remove all polygons and internal data from previous clipping operations.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
.SS "integerize_coordinate_sets"
.IX Subsection "integerize_coordinate_sets"
Takes an array of polygons and scales all point coordinates so that the values
will fit in the integer range available. Returns an array reference containing the scaling factors
used for each coordinate column. The polygon data will be scaled in-place. The scaling vector is returned
so you can \*(L"unscale\*(R" the data when you're done, using \f(CW\*(C`unscale_coordinate_sets\*(C'\fR.
.PP
.Vb 1
\&    my $scale_vector = integerize_coordinate_sets( $poly1 , $poly2 , $poly3 );
.Ve
.PP
The main purpose of this function is to convert floating point coordinate data to integers.
As of Clipper version 4, only integer coordinate data is allowed. This helps make the 
intersection algorithm robust, but it's a bit inconvenient if your data is in floating point format.
.PP
This utility function is meant to make it easy to convert your data to Clipper-friendly integers, while
retaining as much precision as possible. When you're done with your clipping operations, you can use the
\&\f(CW\*(C`unscale_coordinate_sets\*(C'\fR function to scale results back to your original scale.
.PP
Convert all your polygons at once, with one call to \f(CW\*(C`integerize_coordinate_sets\*(C'\fR, before loading the
polygons into your clipper object. The scaling factors need to be calculated so that all
polygons involved fit in the available integer space.
.PP
By default, the scaling is uniform between coordinate columns (e.g., the X values are scaled by the same
factor as the Y values) making all the scaling factors returned the same. In other words, by default, the aspect ratio
between X and Y is constrained.
.PP
Options may be passed in an anonymous hash, as the first argument, to override defaults.
If the first argument is not a hash reference, it is taken instead as the first polygon to be scaled.
.PP
.Vb 6
\&    my $scale_vector = integerize_coordinate_sets( {
\&                                                    constrain => 0, # don\*(Aqt do uniform scaling
\&                                                    bits => 32     # use the +/\-1,073,741,822 integer range
\&                                                    },
\&                                                    $poly1 , $poly2 , $poly3
\&                                                 );
.Ve
.PP
The \f(CW\*(C`bits\*(C'\fR option can be 32, 53, or 64. The default will be 53 or 64, depending on whether your
Perl uses 64 bit integers \s-1AND\s0 long doubles by default. (The scaling involves math with native doubles,
so it's not enough to just have 64 bit integers.)
.PP
Setting the \f(CW\*(C`bits\*(C'\fR option to 32 may provide a modest speed boost, by allowing Clipper to 
avoid calculations with large integer types.
.PP
The \f(CW\*(C`constrain\*(C'\fR option is a boolean. Default is true. When set to false, each
column of coordinates (X, Y) will be scaled independently. This may be useful
when the domain of the X values is very much larger or smaller than the domain
of the Y values, to get better resolution for the smaller domain. The different scaling
factors will be available in the returned scaling vector (array reference).
.PP
This utility will also operate on coordinates with three or more dimensions. Though the context here
is 2D, be aware of this if you happen to feed it 3D data. Large domains in the higher dimensions
could squeeze the 2D data to nothing if scaling is uniform.
.SS "unscale_coordinate_sets"
.IX Subsection "unscale_coordinate_sets"
This undoes the scaling done by \f(CW\*(C`integerize_coordinate_sets\*(C'\fR. Use this on the polygons returned
by the \f(CW\*(C`execute\*(C'\fR method. Pass the scaling vector returned by \f(CW\*(C`integerize_coordinate_sets\*(C'\fR, and 
the polygons to \*(L"unscale\*(R". The polygon coordinates will be updated in place.
.PP
.Vb 1
\&    unscale_coordinate_sets($scale,$clipper_result);
.Ve
.SS "offset"
.IX Subsection "offset"
.Vb 2
\&    my $offset_polygons = offset($polygons, $distance);
\&    my $offset_polygons = offset($polygons, $distance, $scale, $jointype, $miterlimit);
.Ve
.PP
Takes a reference to an array of polygons (\f(CW$polygons\fR), a positive or negative offset dimension 
(\f(CW$distance\fR), and, optionally, a scaling factor (\f(CW$scale\fR), a join type (\f(CW$jointype\fR) and a numeric 
angle limit for the \f(CW\*(C`JT_MITER\*(C'\fR join type.
.PP
The polygons will use the \s-1NONZERO\s0 fill strategy, so filled areas and holes can be specified by polygon winding order.
.PP
A positive offset dimension makes filled polygons grow outward, and their holes shrink.
A negative offset makes polygons shrink and their holes grow.
.PP
Coordinates will be multiplied by the scaling factor before the offset operation and the results divided by the scaling factor.
The default scaling factor is 100. Setting the scaling factor higher will result in more points and smoother contours in the offset results.
.PP
Returns a new set of polygons, offset by the given dimension.
.PP
.Vb 3
\&    my $offset_polygons = offset($polygons, 5.5); # offset by 5.5
\&        or
\&    my $offset_polygons = offset($polygons, 5.5, 1000); # smoother results, proliferation of points
.Ve
.PP
\&\fB\s-1WARNING: \s0\fRAs you increase the scaling factor, the number of points grows quickly, and will happily consume all of your \s-1RAM.\s0
Large offset dimensions also contribute to a proliferation of points.
.PP
Floating point data in the input is acceptable \- in that case, the scaling factor also 
determines how many decimal digits you'll get in the results. It is not necessary,
and generally not desirable to use \f(CW\*(C`integerize_coordinate_sets\*(C'\fR to prepare data for this function.
.PP
When doing negative offsets, you may find the winding order of the results to be the opposite 
of what you expect, although this seems to be fixed in recent Clipper versions. Check the order and change 
it if it is important in your application.
.PP
Join type can be one of \f(CW\*(C`JT_MITER\*(C'\fR, \f(CW\*(C`JT_ROUND\*(C'\fR or \f(CW\*(C`JT_SQUARE\*(C'\fR.
.SS "int_offset"
.IX Subsection "int_offset"
.Vb 1
\&    my $offset_polygons = int_offset($polygons, $distance, $scale, $jointype, $miterlimit);
.Ve
.PP
This function is a faster replacement for \fIoffset()\fR when input coordinates are integers. 
If floats are supplied to it, their decimal digits will be truncated so the offset might 
work on invalid geometry (truncation can lead to self-intersecting polygons). Be sure to
only use this one if your input polygons only have integer coordinates.
.SS "int_offset2"
.IX Subsection "int_offset2"
.Vb 1
\&    my $offset_polygons = int_offset($polygons, $distance1, $distance2, $scale, $jointype, $miterlimit);
.Ve
.PP
This function works like \fIint_offset()\fR but it does two consecutive offsets with the given 
distances. The purpose of the \fI*offset2\fR functions is to avoid overhead when two consecutive
offsets are needed (scaling/unscaling only happens once, and no conversion to Perl variables
happens in between).
.SS "ex_int_offset"
.IX Subsection "ex_int_offset"
.Vb 1
\&    my $offset_expolygons = ex_int_offset($polygons, $distance, $scale, $jointype, $miterlimit);
.Ve
.PP
This function works like \fIint_offset()\fR but it does a \s-1UNION\s0 operation on the resulting polygons
and returns an arrayref of ExPolygons.
.SS "ex_int_offset2"
.IX Subsection "ex_int_offset2"
.Vb 1
\&    my $offset_expolygons = ex_int_offset2($polygons, $distance1, $distance2, $scale, $jointype, $miterlimit);
.Ve
.PP
This function works like \fIex_int_offset()\fR but it does two consecutive offsets with the given 
distances before performing the \s-1UNION\s0 operation.
.SS "area"
.IX Subsection "area"
Returns the signed area of a single polygon.
A counter clockwise wound polygon area will be positive.
A clockwise wound polygon area will be negative.
Coordinate data should be integers.
.PP
.Vb 1
\&    $area = area($polygon);
.Ve
.SS "orientation"
.IX Subsection "orientation"
Determine the winding order of a polygon. It returns a true value if the polygon is counter-clockwise
\&\fBand\fR you're assuming a display where the Y\-axis coordinates are positive \fIupward\fR, or if the polygon 
is clockwise and you're assuming a positive-downward Y\-axis. Coordinate data should be integers.
The majority of 2D graphic display libraries have their origin (0,0) at the top left corner, thus Y
increases downward; however some libraries (Quartz, OpenGL) as well as non-display applications (\s-1CNC\s0)
assume Y increases upward.
.PP
.Vb 3
\&    my $poly = [ [0, 0] , [2, 0] , [1, 1] ]; # a counter clockwise wound polygon (assuming Y upward)
\&    my $direction = orientation($poly);
\&    # now $direction == 1
.Ve
.PP
This function was previously named \f(CW\*(C`is_counter_clockwise()\*(C'\fR. This symbol is still exported for backwards
compatibility; however you're encouraged to switch it to \f(CW\*(C`orientation()\*(C'\fR as the underlying Clipper
library switched to it too to clarify the Y axis convention issue.
.SS "simplify_polygon =head2 simplify_polygons"
.IX Subsection "simplify_polygon =head2 simplify_polygons"
These functions convert self-intersecting polygons (known as \fIcomplex\fR polygons) to \fIsimple\fR
polygons. \f(CW\*(C`simplify_polygon()\*(C'\fR takes a single polygon as first argument, while \f(CW\*(C`simplify_polygons()\*(C'\fR
takes multiple polygons in a single arrayref. The second argument must be a polyfilltype constant 
(PFT_*, see above). Both return an arrayref of polygons.
.SH "MAXIMUM COORDINATE VALUES AND 64 BIT SUPPORT"
.IX Header "MAXIMUM COORDINATE VALUES AND 64 BIT SUPPORT"
Clipper accepts 64 bit integer input, but limits the domain of input coordinate values
to +/\-4,611,686,018,427,387,902, to allow enough overhead for certain calculations.
Coordinate values up to these limits are possible with Perls built to support 64 bit integers.
.PP
A typical Perl that supports 32 bit integers can alternatively store 53 bit integers as floating point 
numbers. In this case, the coordinate domain is limited to +/\-9,007,199,254,740,992.
.PP
When optionally constraining coordinate values to 32 bit integers, the domain is +/\-1,073,741,822.
.PP
The \f(CW\*(C`integerize_coordinate_sets\*(C'\fR utility function automatically respects whichever limit applies to
your Perl build.
.SH "NONZERO vs. EVENODD"
.IX Header "NONZERO vs. EVENODD"
Consider the following example:
.PP
.Vb 3
\&    my $p1 = [ [0,0], [200000,0], [200000,200000]             ];   # CCW
\&    my $p2 = [ [0,200000], [0,0], [200000,200000]             ];   # CCW
\&    my $p3 = [ [0,0], [200000,0], [200000,200000], [0,200000] ];   # CCW
\&
\&    my $clipper = Math::Clipper\->new;
\&    $clipper\->add_subject_polygon($p1);
\&    $clipper\->add_clip_polygons([$p2, $p3]);
\&    my $result = $clipper\->execute(CT_UNION, PFT_EVENODD, PFT_EVENODD);
.Ve
.PP
\&\f(CW$p3\fR is a square, and \f(CW$p1\fR and \f(CW$p2\fR are triangles covering two halves of the \f(CW$p3\fR area.
The \f(CW\*(C`CT_UNION\*(C'\fR operation will produce different results, depending on whether \f(CW\*(C`PFT_EVENODD\*(C'\fR or \f(CW\*(C`PFT_NONZERO\*(C'\fR
is used. These are the two different strategies used by Clipper to identify filled vs. empty regions.
.PP
Let's see the thing in detail: \f(CW$p2\fR and \f(CW$p3\fR are the clip polygons. \f(CW$p2\fR overlaps half of \f(CW$p3\fR. 
With the \f(CW\*(C`PFT_EVENODD\*(C'\fR fill strategy, the number of polygons that overlap in a given area determines 
whether that area is a hole or a filled region. If an odd number of polygons overlap there, it's a 
filled region. If an even number, it's a hole/empty region. So with \f(CW\*(C`PFT_EVENODD\*(C'\fR, winding order 
doesn't matter. What matters is where areas overlap.
.PP
So, using \f(CW\*(C`PFT_EVENODD\*(C'\fR, and considering \f(CW$p2\fR and \f(CW$p3\fR as the set of clipping polygons, the fact that 
\&\f(CW$p2\fR overlaps half of \f(CW$p3\fR means that the region where they overlap is empty. In effect, in this example, 
the set of clipping polygons ends up defining the same shape as the subject polygon \f(CW$p1\fR. So the union 
is just the union of two identical polygons, and the result is a triangle equivalent to \f(CW$p1\fR.
.PP
If, instead, the \f(CW\*(C`PFT_NONZERO\*(C'\fR strategy is specified, the set of clipping polygons is understood as two filled 
polygons, because of the winding order. The area where they overlap is considered filled,
because there is at least one filled polygon in that area. The set of clipping polygons in this case is equivalent
to the square \f(CW$p3\fR, and the result of the \f(CW\*(C`CT_UNION\*(C'\fR operation is also equivalent to the square \f(CW$p3\fR.
.PP
This is a good example of how \f(CW\*(C`PFT_NONZERO\*(C'\fR is more explicit, and perhaps more intuitive.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The SourceForge project page of Clipper:
.PP
<http://sourceforge.net/projects/polyclipping/>
.SH "VERSION"
.IX Header "VERSION"
This module was built around, and includes, Clipper version 5.1.5.
.SH "AUTHOR"
.IX Header "AUTHOR"
The Perl module was written by:
.PP
Steffen Mueller (<smueller@cpan.org>),
Mike Sheldrake and Alessandro Ranellucci (aar/alexrj)
.PP
But the underlying library \f(CW\*(C`Clipper\*(C'\fR was written by
Angus Johnson. Check the SourceForge project page for
contact information.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
The \f(CW\*(C`Math::Clipper\*(C'\fR module is
.PP
Copyright (C) 2010, 2011, 2014 by Steffen Mueller
.PP
Copyright (C) 2011 by Mike Sheldrake
.PP
Copyright (C) 2012, 2013 by Alessandro Ranellucci and Mike Sheldrake
.PP
but we are shipping a copy of the \f(CW\*(C`Clipper\*(C'\fR \*(C+ library, which
is
.PP
Copyright (C) 2010, 2011, 2012 by Angus Johnson.
.PP
\&\f(CW\*(C`Math::Clipper\*(C'\fR is available under the same
license as \f(CW\*(C`Clipper\*(C'\fR itself. This is the \f(CW\*(C`boost\*(C'\fR license:
.PP
.Vb 2
\&  Boost Software License \- Version 1.0 \- August 17th, 2003
\&  http://www.boost.org/LICENSE_1_0.txt
\&  
\&  Permission is hereby granted, free of charge, to any person or organization
\&  obtaining a copy of the software and accompanying documentation covered by
\&  this license (the "Software") to use, reproduce, display, distribute,
\&  execute, and transmit the Software, and to prepare derivative works of the
\&  Software, and to permit third\-parties to whom the Software is furnished to
\&  do so, all subject to the following:
\&  
\&  The copyright notices in the Software and this entire statement, including
\&  the above license grant, this restriction and the following disclaimer,
\&  must be included in all copies of the Software, in whole or in part, and
\&  all derivative works of the Software, unless such copies or derivative
\&  works are solely in the form of machine\-executable object code generated by
\&  a source language processor.
\&  
\&  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
\&  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
\&  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON\-INFRINGEMENT. IN NO EVENT
\&  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
\&  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
\&  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
\&  DEALINGS IN THE SOFTWARE.
.Ve
