.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Verilog::VCD 3"
.TH Verilog::VCD 3 "2014-06-12" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Verilog::VCD \- Parse a Verilog VCD text file
.SH "VERSION"
.IX Header "VERSION"
This document refers to Verilog::VCD version 0.05.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Verilog::VCD qw(parse_vcd);
\&    my $vcd = parse_vcd(\*(Aq/path/to/some.vcd\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Verilog is a Hardware Description Language (\s-1HDL\s0) used to model digital logic.
While simulating logic circuits, the values of signals can be written out to
a Value Change Dump (\s-1VCD\s0) file.  This module can be used to parse a \s-1VCD\s0 file
so that further analysis can be performed on the simulation data.  The entire
\&\s-1VCD\s0 file can be stored in a Perl data structure and manipulated using
standard hash and array operations.
.SS "Input File Syntax"
.IX Subsection "Input File Syntax"
The syntax of the \s-1VCD\s0 text file is described in the documentation of
the \s-1IEEE\s0 standard for Verilog.  Only the four-state \s-1VCD\s0 format is supported.
The extended \s-1VCD\s0 format (with strength information) is not supported.
Since the input file is assumed to be legal \s-1VCD\s0 syntax, only minimal
validation is performed.
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.ie n .SS "parse_vcd($file, $opt_ref)"
.el .SS "parse_vcd($file, \f(CW$opt_ref\fP)"
.IX Subsection "parse_vcd($file, $opt_ref)"
Parse a \s-1VCD\s0 file and return a reference to a data structure which
includes hierarchical signal definitions and time-value data for all
the specified signals.  A file name is required.  By default, all
signals in the \s-1VCD\s0 file are included, and times are in units
specified by the \f(CW$timescale\fR \s-1VCD\s0 keyword.
.PP
.Vb 1
\&    my $vcd = parse_vcd(\*(Aq/path/to/some.vcd\*(Aq);
.Ve
.PP
It returns a reference to a nested data structure.  The top of the
structure is a Hash-of-Hashes.  The keys to the top hash are the \s-1VCD\s0
identifier codes for each signal.  The following is an example
representation of a very simple \s-1VCD\s0 file.  It shows one signal named
\&\f(CW\*(C`chip.cpu.alu.clk\*(C'\fR, whose \s-1VCD\s0 code is \f(CW\*(C`+\*(C'\fR.  The time-value pairs
are stored as an Array-of-Arrays, referenced by the \f(CW\*(C`tv\*(C'\fR key.  The
time is always the first number in the pair, and the times are stored in
increasing order in the array.
.PP
.Vb 10
\&    {
\&      \*(Aq+\*(Aq => {
\&               \*(Aqtv\*(Aq => [
\&                         [
\&                           \*(Aq0\*(Aq,
\&                           \*(Aq1\*(Aq
\&                         ],
\&                         [
\&                           \*(Aq12\*(Aq,
\&                           \*(Aq0\*(Aq
\&                         ],
\&                       ],
\&               \*(Aqnets\*(Aq => [
\&                           {
\&                             \*(Aqhier\*(Aq => \*(Aqchip.cpu.alu.\*(Aq,
\&                             \*(Aqname\*(Aq => \*(Aqclk\*(Aq,
\&                             \*(Aqtype\*(Aq => \*(Aqreg\*(Aq,
\&                             \*(Aqsize\*(Aq => \*(Aq1\*(Aq
\&                           }
\&                         ]
\&             }
\&    };
.Ve
.PP
Since each code could have multiple hierarchical signal names, the names are
stored as an Array-of-Hashes, referenced by the \f(CW\*(C`nets\*(C'\fR key.  The example above
only shows one signal name for the code.
.PP
\fI\s-1OPTIONS\s0\fR
.IX Subsection "OPTIONS"
.PP
Options to \f(CW\*(C`parse_vcd\*(C'\fR should be passed as a hash reference.
.IP "timescale" 4
.IX Item "timescale"
It is possible to scale all times in the \s-1VCD\s0 file to a desired timescale.
To specify a certain timescale, such as nanoseconds:
.Sp
.Vb 1
\&    my $vcd = parse_vcd($file, {timescale => \*(Aqns\*(Aq});
.Ve
.Sp
Valid timescales are:
.Sp
.Vb 1
\&    s ms us ns ps fs
.Ve
.IP "siglist" 4
.IX Item "siglist"
If only a subset of the signals included in the \s-1VCD\s0 file are needed,
they can be specified by a signal list passed as an array reference.
The signals should be full hierarchical paths separated by the dot
character.  For example:
.Sp
.Vb 6
\&    my @signals = qw(
\&        top.chip.clk
\&        top.chip.cpu.alu.status
\&        top.chip.cpu.alu.sum[15:0]
\&    );
\&    my $vcd = parse_vcd($file, {siglist => \e@signals});
.Ve
.Sp
Limiting the number of signals can substantially reduce memory usage of the
returned data structure because only the time-value data for the selected
signals is loaded into the data structure.
.IP "use_stdout" 4
.IX Item "use_stdout"
It is possible to print time-value pairs directly to \s-1STDOUT\s0 for a
single signal using the \f(CW\*(C`use_stdout\*(C'\fR option.  If the \s-1VCD\s0 file has
more than one signal, the \f(CW\*(C`siglist\*(C'\fR option must also be used, and there
must only be one signal specified.  For example:
.Sp
.Vb 4
\&    my $vcd = parse_vcd($file, {
\&                    use_stdout => 1,
\&                    siglist    => [(top.clk)]
\&                });
.Ve
.Sp
The time-value pairs are output as space-separated tokens, one per line.
For example:
.Sp
.Vb 4
\&    0 x
\&    15 0
\&    277 1
\&    500 0
.Ve
.Sp
Times are listed in the first column.
Times units can be controlled by the \f(CW\*(C`timescale\*(C'\fR option.
.IP "only_sigs" 4
.IX Item "only_sigs"
Parse a \s-1VCD\s0 file and return a reference to a data structure which
includes only the hierarchical signal definitions.  Parsing stops once
all signals have been found.  Therefore, no time-value data are
included in the returned data structure.  This is useful for
analyzing signals and hierarchies.
.Sp
.Vb 1
\&    my $vcd = parse_vcd($file, {only_sigs => 1});
.Ve
.SS "list_sigs($file)"
.IX Subsection "list_sigs($file)"
Parse a \s-1VCD\s0 file and return a list of all signals in the \s-1VCD\s0 file.
Parsing stops once all signals have been found.  This is
helpful for deciding how to limit what signals are parsed.
.PP
Here is an example:
.PP
.Vb 1
\&    my @signals = list_sigs(\*(Aqinput.vcd\*(Aq);
.Ve
.PP
The signals are full hierarchical paths separated by the dot character
.PP
.Vb 2
\&    top.chip.cpu.alu.status
\&    top.chip.cpu.alu.sum[15:0]
.Ve
.SS "get_timescale( )"
.IX Subsection "get_timescale( )"
This returns a string corresponding to the timescale as specified
by the \f(CW$timescale\fR \s-1VCD\s0 keyword.  It returns the timescale for
the last \s-1VCD\s0 file parsed.  If called before a file is parsed, it
returns an undefined value.  If the \f(CW\*(C`parse_vcd\*(C'\fR \f(CW\*(C`timescale\*(C'\fR option
was used to specify a timescale, the specified value will be returned
instead of what is in the \s-1VCD\s0 file.
.PP
.Vb 2
\&    my $vcd = parse_vcd($file); # Parse a file first
\&    my $ts  = get_timescale();  # Then query the timescale
.Ve
.SS "get_endtime( )"
.IX Subsection "get_endtime( )"
This returns the last time found in the \s-1VCD\s0 file, scaled
appropriately.  It returns the last time for the last \s-1VCD\s0 file parsed.
If called before a file is parsed, it returns an undefined value.
.PP
.Vb 2
\&    my $vcd = parse_vcd($file); # Parse a file first
\&    my $et  = get_endtime();    # Then query the endtime
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
Nothing is exported by default.  Functions may be exported individually, or
all functions may be exported at once, using the special tag \f(CW\*(C`:all\*(C'\fR.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Error conditions cause the program to die using \f(CW\*(C`croak\*(C'\fR from the
Carp Core module.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
Only the following \s-1VCD\s0 keywords are parsed:
.PP
.Vb 3
\&    $end                $scope
\&    $enddefinitions     $upscope
\&    $timescale          $var
.Ve
.PP
The extended \s-1VCD\s0 format (with strength information) is not supported.
.PP
The default mode of \f(CW\*(C`parse_vcd\*(C'\fR is to load the entire \s-1VCD\s0 file into the
data structure.  This could be a problem for huge \s-1VCD\s0 files.  The best solution
to any memory problem is to plan ahead and keep \s-1VCD\s0 files as small as possible.
When simulating, dump fewer signals and scopes, and use shorter dumping
time ranges.  Another technique is to parse only a small list of signals
using the \f(CW\*(C`siglist\*(C'\fR option; this method only loads the desired signals into
the data structure.  Finally, the \f(CW\*(C`use_stdout\*(C'\fR option will parse the input \s-1VCD\s0
file line-by-line, instead of loading it into the data structure, and directly
prints time-value data to \s-1STDOUT. \s0 The drawback is that this only applies to
one signal.
.SH "BUGS"
.IX Header "BUGS"
There are no known bugs in this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Refer to the following Verilog documentation:
.PP
.Vb 3
\&    IEEE Standard for Verilog (c) Hardware Description Language
\&    IEEE Std 1364\-2005
\&    Section 18.2, "Format of four\-state VCD file"
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Gene Sullivan (gsullivan@cpan.org)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2012 Gene Sullivan.  All rights reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See perlartistic.
