

sub set_map_seed_placement{
  if( $_[0] eq '-h') {
    print "\nUsage : set_map_seed_placement [<number for seed place option>] ";
    print "\n         note   : By default,the option is 2";
    print "\n         If -1  : It will add legal location for unplaced cells and IO";
    print "\n         If  0  : It will map the seed placement to legal rows.Row may go beyond the CHIP boundary.Overlap between cells will be removed";
    print "\n         If  1  : It will map the seed placement to legal rows.Row may go beyond the CHIP boundary";
    print "\n                : Cell will be moved to nearest x-sites and overlap will be removed";
    print "\n         If  2  : It will move cells only for those rows which are going beyond the CHIP boundary. It will move cells only to nearest rows";
    print "\n                : Cell will be moved to nearest x-sites and overlap will be removed";
    print "\n         If  3  : It will move cells so that utilization of all the rows is almost same ";
    print "\n         If  4  : It will map the seed placement to legal rows and x-sites. Checks are added if any rows are going beyond CHIP boundary";
    print "\n         If  5  : It will map the seed placement to legal rows and x-sites. Rows may going beyond CHIP boundary";
    print "\n         If  6  : It will move cells so that utilization of all the rows is almost same. This will happen only if any row is going beyond the CHIP boundary ";
    print "\n         If  7  : It will move cells only for those rows which are going beyond the CHIP boundary. It will move cells only to nearest rows";
    print "\n         If  8  : It will map the seed placement to legal rows.Row may go beyond the CHIP boundary";
    print "\n                : Cell will be moved to nearest x-sites and overlap will be removed";
    print "\n                : Number of rows may not match with the number of rows in the CHIP";
    print "\n         If  9  : It will map the seed placement to legal rows.Row may go beyond the CHIP boundary.Overlap between cells will be removed";
    print "\n                : Number of rows may not match with the number of rows in the CHIP\n";
    return ;
  }
  my $map_seed_option = -2; 
  my $noOfArguments = @_;
  if($noOfArguments >= 1){
     $map_seed_option = $_[0]; 
  }
  if($map_seed_option eq "-1"){
    print "\nIt will add legal location for unplaced cells and IO\n";
  } elsif($map_seed_option eq "0"){
    print "\nIt will map the seed placement to legal rows.Row may go beyond the CHIP boundary.Overlap between cells will be removed\n";
  } elsif($map_seed_option eq "1"){
    print "\nIt will map the seed placement to legal rows.Row may go beyond the CHIP boundary";
    print "\nCell will be moved to nearest x-sites and overlap will be removed\n";
  } elsif($map_seed_option eq "2"){
    print "\nIt will move cells only for those rows which are going beyond the CHIP boundary. It will move cells only to nearest rows";
    print "\nCell will be moved to nearest x-sites and overlap will be removed\n";
  } elsif($map_seed_option eq "3"){
    print "\nIt will move cells so that utilization of all the rows is almost same\n";
  } elsif($map_seed_option eq "4"){
    print "\nIt will map the seed placement to legal rows and x-sites. Checks are added if any rows are going beyond CHIP boundary\n";
  } elsif($map_seed_option eq "5"){
    print "\nIt will map the seed placement to legal rows and x-sites. Rows may going beyond CHIP boundary\n";
  } elsif($map_seed_option eq "6"){
    print "\nIt will move cells so that utilization of all the rows is almost same. This will happen only if any row is going beyond the CHIP boundary\n";
  } elsif($map_seed_option eq "7"){
    print "\nIt will move cells only for those rows which are going beyond the CHIP boundary. It will move cells only to nearest rows\n";
  } elsif($map_seed_option eq "8"){
    print "\nIt will map the seed placement to legal rows.Row may go beyond the CHIP boundary";
    print "\nCell will be moved to nearest x-sites and overlap will be removed";
    print "\nNumber of rows may not match with the number of rows in the CHIP\n";
  } elsif($map_seed_option eq "9"){
    print "\nIt will map the seed placement to legal rows.Row may go beyond the CHIP boundary.Overlap between cells will be removed";
    print "\nNumber of rows may not match with the number of rows in the CHIP\n";
  } elsif($map_seed_option eq "100"){
    print "\nTesting mode\n";
  }else {
    $map_seed_option = 2; 
    print "\nNo options or invalid option selected. Default behaviour is option 2";
    print "\nIt will move cells only for those rows which are going beyond the CHIP boundary. It will move cells only to nearest rows";
    print "\nCell will be moved to nearest x-sites and overlap will be removed\n";
  }
  $GLOBAL->dbfGlobalSetMapSeed($map_seed_option) ;
} #sub set_map_seed_placement








sub set_node_no {

  my %TEMP_LOC = ();
  my $cnt = 0;
print "INFO-UTS-SET_NODE_NO : 001 : Setting node no of Ports\n";
  foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
    $TEMP_LOC{$port} = $cnt;
    $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortSetNodeNum($cnt);
    $cnt++;
  }
print "INFO-UTS-SET_NODE_NO : 002 : Setting node no of Instance\n";
  foreach my $inst (keys %{COMP_ALREADY} ) {
    $TEMP_LOC{$inst} = $cnt; 
    $CADB{$inst}->dbCadbSetNodeNum($cnt);
    $cnt++;
  }

  foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
    my $po = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetNodeNum;
    #print "PORT $port : $po\n";
  }
  foreach my $inst (keys %{COMP_ALREADY} ) {
    my $node = $CADB{$inst}->dbCadbGetNodeNum;
    #print "NODE $inst : $node\n";
  }
}#sub Set_node_no



sub set_cur_loc_to_orig_loc {

  my %TEMP_LOC = ();
  my $cnt = 0;
print "INFO-UTS-SET_CURR_LOC_ORG_LOC : 001 : setting current location of ports to original location\n";
  foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
    $TEMP_LOC{$port} = $cnt;
    my @port_loc = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetLoc;
    $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortSetorigLoc($port_loc[0], $port_loc[1]);
    $cnt++;
  }
print "INFO-UTS-SET_CURR_LOC_ORG_LOC : 002 : setting current location of instance to original location\n";
  foreach my $inst (keys %{COMP_ALREADY} ) {
    $TEMP_LOC{$inst} = $cnt; 
    my @node_loc = $CADB{$inst}->dbCadbGetLoc;
    $CADB{$inst}->dbCadbSetorigLoc($node_loc[0],$node_loc[1]);
    $cnt++;
  }
print "INFO-UTS-SET_CURR_LOC_ORG_LOC : 003 : location set for ports and instance\n";

  foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
    my @p_loc = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetorigLoc;
    #print "PORT $port : @p_loc\n";
  }
  foreach my $inst (keys %{COMP_ALREADY} ) {
    my @n_loc = $CADB{$inst}->dbCadbGetorigLoc;
    #print "NODE $inst : @n_loc\n";
  }
}#sub set_cur_loc_to_orig_loc

sub node_displacement {

  my %TEMP_LOC = ();
  my $cnt = 0;
  my @org_port_loc = ();
  my @new_port_loc = ();
  my @org_inst_loc = ();
  my @new_inst_loc = ();
  my $total_dis_portX;
  my $total_dis_portY;
  my $total_dis_instX;
  my $total_dis_instY;
  open(WRITE_DISP_INFO,">y_disp_file");
  print "INFO-UTS-NODE_DIS : 001 : Start finding displacement for ports and instances\n";
  foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
    $TEMP_LOC{$port} = $cnt;
    @org_port_loc = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetorigLoc;
    @new_port_loc = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetLoc;
    my $dis_portX1 = $new_port_loc[0] - $org_port_loc[0];
    my $dis_portY1 = $new_port_loc[1] - $org_port_loc[1];
    $total_dis_portX += abs $dis_portX1;
    $total_dis_portY += abs $dis_portY1;
    $cnt++;
  }
  my $port_cnt = $cnt; 
  my $imax = -1;
  my $instance;
  my $nodeNo;
  foreach my $inst (keys %{COMP_ALREADY} ) {
    #my $inst = u1669;
    $TEMP_LOC{$inst} = $cnt; 
    @org_inst_loc = $CADB{$inst}->dbCadbGetorigLoc;
    @new_inst_loc = $CADB{$inst}->dbCadbGetLoc;
    my $dis_instX1 = $new_inst_loc[0] - $org_inst_loc[0];
    my $dis_instY1 = $new_inst_loc[1] - $org_inst_loc[1];
    my $tempYDisp = abs($dis_instY1/2000) ;
    print WRITE_DISP_INFO "Node=$cnt displacement=$tempYDisp \n";
    my $total = abs ($dis_instX1 / (2000))  + abs ($dis_instY1 / (2000));
    if ($total > $imax) {
      $imax = $total;
      $instance = $inst;
      $nodeNo = $CADB{$inst}->dbCadbGetNodeNum; 
    }
    $total_dis_instX += abs ($dis_instX1 / (2000));
    $total_dis_instY += abs ($dis_instY1 / (2000));
    $cnt++;
  }
  my $max = $imax;
  print "INFO-UTS-NODE_DIS : 002 : max dis is $max : Instance is $instance : Node is $nodeNo\n";
  my $total_cnt = $cnt;
  my $inst_cnt = $total_cnt - $port_cnt;
  my $a_i_x_d = $total_dis_instX;# / (2000);
  my $a_i_y_d = $total_dis_instY;# / (2000);
  my $avg = ($a_i_x_d + $a_i_y_d) / $inst_cnt;
  my $tt = $a_i_x_d + $a_i_y_d;
  print "INFO-UTS-NODE_DIS : 003 : Total is for instances : $tt\n";
  print "INFO-UTS-NODE_DIS : 004 : avg displacement for instances is : $avg\n";
 close(WRITE_DISP_INFO);
}#sub node_displacement

sub displacement_distribution {
my $noOfArguments = @_;
my $noOfSteps = 10;
for(my $i=0; $i<$noOfArguments; $i++){
    if($_[$i] eq "-steps"){$noOfSteps = $_[$i+1];}
}
  my @INST_DISPLACEMENT = ();
  foreach my $inst (keys %{COMP_ALREADY} ) {
#print "inst $inst\n";
    my @org_inst_loc = $CADB{$inst}->dbCadbGetorigLoc;
    my @new_inst_loc = $CADB{$inst}->dbCadbGetLoc;
#print "org @org_inst_loc, new @new_inst_loc\n";
    my $dis_instX = $new_inst_loc[0] - $org_inst_loc[0];
    my $dis_instY = $new_inst_loc[1] - $org_inst_loc[1];
    my $total = abs ($dis_instX / (2000))  + abs ($dis_instY / (2000));
#print "total length is $total\n";
    push(@INST_DISPLACEMENT, $total);
  }
@INST_DISPLACEMENT = sort{$a<=>$b}@INST_DISPLACEMENT;
my $MinDis = $INST_DISPLACEMENT[0];
my $MaxDis = $INST_DISPLACEMENT[-1];
#print " $MinDis,$MaxDis,$noOfSteps\n";
my $stepSize = ($MaxDis - $MinDis)/$noOfSteps;
#print " step $stepSize\n";
my @distributedDis = ();
 foreach(@INST_DISPLACEMENT){
        my $index = int (($_ - $MinDis)/$stepSize) ;
           $distributedDis[$index] += 1 ;
 }
print "DISPLACEMENT RANGE:         NO OF INSTANCES:\n";
 for(my $i=0; $i<$noOfSteps; $i++){
     my $Lrange = $MinDis + $i*$stepSize;  
     my $Urange = $MinDis + ($i+1)*$stepSize;  
 print "$Lrange - $Urange            $distributedDis[$i]\n";
 }

}#sub displacement_distribution


#---------------- write the design info file-------------------#
#---------------------------------------------------------------------------------------------------------------------------#
#--------------------------------------------------------------------------------------------------------------#
#------------------------------------------------------------------------------------------------------------------------#
sub get_inst_pins_offset {
my $cellref = $_[0];
my $pin = $_[1];
my $pincnt = 0;
  if(exists $PLDB{$cellref}){
     @pins = $PLDB{$cellref}->dbMdbGetPins;        
    foreach $p (@pins){
        if($p eq $pin){
          return($pincnt);
                      }
           $pincnt++;
                      }#foreach pin
                            }#if exists cell
   return -1 ;
}#sub get_inst_pins_offset
#-------------------------------------------------------------------------------------------------------------------------------------------------#
sub set_option_desinfofile {
    my $noOfArguments = @_;
    if ($noOfArguments < 1 || $_[0] eq "-h"){print "Usage : set_option_desinfofile \n";
                                             print "      : -spacing\n";
                                             print "      : -maxFilledPercent\n"; 
                                             print "      : --alignX\n";
                                             }#if
else{
     $ALIGN = 0;
     for (my $i = 0; $i<$noOfArguments; $i++){
          if($_[$i] eq "-spacing"){$spacing = $_[$i+1];}     
          if($_[$i] eq "-maxFilledPercent"){$max_filled_percent = $_[$i+1];}
          if($_[$i] eq "--alignX"){$alignX = $_[$i+1];$ALIGN =1;}
                                              }#for 
my $DEFAULT_MAX_FILLED_PERCENT = 100;
$DBSCALEFACTOR = $DEF_DATABASE_UNIT;

$sp = $spacing/$DBSCALEFACTOR;
$GLOBAL->dbfGlobalSetDesSpacing($sp);

if($ALIGN == 1){$GLOBAL->dbfGlobalSetAlignX(1);}
else {$GLOBAL->dbfGlobalSetAlignX(0);}

if (exists $DIE_ALREADY{dieArea}){
$gui_Diellx = $DIE_ALREADY{dieArea}[0];
$gui_Dielly = $DIE_ALREADY{dieArea}[1];
$gui_Dieurx = $DIE_ALREADY{dieArea}[2];
$gui_Dieury = $DIE_ALREADY{dieArea}[3];

$guiMu_Diellx = $gui_Diellx/$DBSCALEFACTOR;
$guiMu_Dielly = $gui_Dielly/$DBSCALEFACTOR;
$guiMu_Dieurx = $gui_Dieurx/$DBSCALEFACTOR;
$guiMu_Dieury = $gui_Dieury/$DBSCALEFACTOR;

$gui_Width = abs ($guiMu_Dieurx - $guiMu_Diellx);
$gui_Height = abs ($guiMu_Dieury - $guiMu_Dielly);

if ($gui_Width < $gui_Height){$gridsize = $gui_Width;}
else { $gridsize = $gui_Height;}
$GLOBAL->dbfGlobalSetGridSize($gridsize);
}#if exists die area
if ( $max_filled_percent <= $DEFAULT_MAX_FILLED_PERCENT){$max = $max_filled_percent;}
else{$max = $DEFAULT_MAX_FILLED_PERCENT;print "WARN-UTS : 001 : maxfilledPercent is not more than 100\n";}
$GLOBAL->dbfGlobalSetMaxFilledPercent($max);
}#else
}#sub set_option_desinfofile




sub write_controlFile {
my $noOfArguments = @_;
if( $noOfArguments > 6 || $_[0] eq '-h'){
  if( $noOfArguments > 6 ){
    print "\nError: wrong number of input for control file generation";
  }
  print "Usage : write_controlFile [-trim_float_only <0|1> ]\n";
  print "                         [-AddLinkEdge <0|1> ]\n";
  print "                         [-basic_mode <0|1|2> ]\n";
  print "                         [-phase2_only <0|1> ]\n";
  print "                         [-very_high_fanout <integer value> ]\n";
  print "                         [-max_pins_on_cell <integer value> ]\n";
  print "                         [-pin_floating_in_one_dir <integer value> ]\n";
  print "                         [-do_cluster <0|1> ]\n";
  return ;
}
unlink("controlfile");
my $trim_float_only = 0;
my $AddLinkEdge = 1;
my $basic_mode = 0;
my $phase2_only = 0;
my $very_high_fanout = $GLOBAL->dbfGlobalGetFanoutLimit;
my $max_pins_on_cell = 100 ; 
my $pin_floating_in_one_dir = 0 ; 
my $do_cluster = 1 ; 

for(my $i =0; $i<$noOfArguments; $i++){
  if($_[$i] eq "-trim_float_only"){
    $trim_float_only = $_[$i+1];
  } elsif($_[$i] eq "-AddLinkEdge"){
    $AddLinkEdge = $_[$i+1];
  } elsif($_[$i] eq "-basic_mode"){
    $basic_mode = $_[$i+1];
  } elsif($_[$i] eq "-phase2_only"){
    $phase2_only = $_[$i+1];
  } elsif($_[$i] eq "-very_high_fanout"){
    $very_high_fanout = $_[$i+1];
  } elsif($_[$i] eq "-max_pins_on_cell"){
    $max_pins_on_cell = $_[$i+1];
  } elsif($_[$i] eq "-pin_floating_in_one_dir"){
    $pin_floating_in_one_dir = $_[$i+1];
  } elsif($_[$i] eq "-do_cluster"){
    $do_cluster = $_[$i+1];
  }
}
open(WRITE,">controlfile");
print WRITE "-1 **if 1-st field is -1 then ignores line, i.e., a comment**\n";
print WRITE "0 $trim_float_only trim_float_only\n";
print WRITE "1 $AddLinkEdge AddLinkEdge\n";
print WRITE "2 $basic_mode basic_mode\n";
print WRITE "3 $phase2_only phase2_only\n";
print WRITE "4 $very_high_fanout very_high_fanout\n";
print WRITE "5 $max_pins_on_cell max_pins_on_cell\n";
print WRITE "6 $pin_floating_in_one_dir pin_floating_in_one_dir\n";
print WRITE "10 $do_cluster do_cluster\n";

close(WRITE);


}# sub write_controlFile

sub set_buffer_for_assign {
  my $noOfArguments = @_;
  if( $noOfArguments > 10 || $_[0] eq '-h'){
    if( $noOfArguments > 10 ){
      print "\nError: wrong number of input for control file generation";
    }
    print "Usage : set_buffer_for_assign \n";
    print "                         -cell_name <cell_name>\n";
    print "                         -buf_in <input>\n";
    print "                         -buf_out <output>\n";
    print "                         -power <power>\n";
    print "                         -gnd <gnd>\n";
    return ;
  }

  my $cell_name = "";
  my $buf_in = "";
  my $buf_out = "";
  my $power = "";
  my $gnd = "";

  for(my $i =0; $i<$noOfArguments; $i++){
    if($_[$i] eq "-cell_name"){
      $cell_name = $_[$i+1];
    } elsif($_[$i] eq "-buf_in"){
      $buf_in = $_[$i+1];
    } elsif($_[$i] eq "-buf_out"){
      $buf_out = $_[$i+1];
    } elsif($_[$i] eq "-power"){
      $power = $_[$i+1];
    } elsif($_[$i] eq "-gnd"){
      $gnd = $_[$i+1];
    }
  }
  if(exists $PLDB{$cell_name}){
    if(($buf_in eq "")
    ||($buf_out eq "")
    ||($power eq "")
    ||($gnd eq "")) {
      my @pins = $PLDB{$cell_name}->dbMdbGetPins;
      foreach my $pinName ( @pins ) {
        if ($PLDB{$cell_name}->dbMdbGetPinIsSignal($pinName)){
          if($PLDB{$cell_name}->dbMdbGetPinDir($pinName) ==0) {
            $buf_in = $pinName;
          } elsif($PLDB{$cell_name}->dbMdbGetPinDir($pinName) ==1) {
            $buf_out = $pinName;
          }
        } elsif ($PLDB{$cell_name}->dbMdbGetPinIsPower($pinName)){
          $power = $pinName;
        } elsif ($PLDB{$cell_name}->dbMdbGetPinIsGround($pinName)){
          $gnd = $pinName;
        }
      }
    }
  }
  if($cell_name ne "") {$GLOBAL->dbfGlobalSetBufForAssign($cell_name);}
  if($buf_in ne "") {$GLOBAL->dbfGlobalSetBufForAssignIn($buf_in);}
  if($buf_out ne "") {$GLOBAL->dbfGlobalSetBufForAssignOut($buf_out);}
  if($power ne "") {$GLOBAL->dbfGlobalSetBufForAssignPower($power);}
  if($gnd ne "") {$GLOBAL->dbfGlobalSetBufForAssignGnd($gnd);}
}# sub set_buffer_for_assign


#--------------------------------------------------------------------------------------------------------#
sub get_nodenum_for_given_inst{
my $inst = $_[0];
my $pin = $_[1]; 
my $inst_num = -1;
if(exists $CADB{$inst}){
   my $instance_num = $CADB{$inst}->dbCadbGetNodeNum;
   $inst_num = $instance_num;
   my $cellref = $CADB{$inst}->dbCadbGetCellref;
   my $pin_num = $PLDB{$cellref}->dbMdbGetPinNum($pin);
   if(exists $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_MAP{$instance_num}) {
     if(exists $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_MAP{$instance_num}{$pin_num}) {
       $inst_num = $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_MAP{$instance_num}{$pin_num} ;
     }
   }
 }#if exists
elsif (exists $PORTS_ALREADY{$TOP_MODULE}{$inst} ){
   my $instance_num = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetNodeNum;
   $inst_num = $instance_num;
   }#elsif
elsif ($inst eq "PIN"){
 foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
   my $instance_num = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetNodeNum;
    $inst_num = $instance_num;
                    }#foreach
 }#elsif
return($inst_num);
}#sub get_nodenum_for_given_inst
#------------------------------------------------------------------------------------------------------------#
sub get_nodenum_for_given_pin{
my $inst = $_[0];
my $pin = $_[1]; 
my $pin_num = -1;
if(exists $CADB{$inst}){
   my $cellref = $CADB{$inst}->dbCadbGetCellref;
   $pin_num = $PLDB{$cellref}->dbMdbGetPinNum($pin);
   my $instance_num = $CADB{$inst}->dbCadbGetNodeNum;
   if(exists $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_PIN_MAP{$instance_num}) {
     if(exists $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_PIN_MAP{$instance_num}{$pin_num}) {
       my $temp_pin_num = $TEMP_ORIG_NODE_AND_PIN_VS_DUMMY_NODE_PIN_MAP{$instance_num}{$pin_num} ;
       $pin_num = $temp_pin_num;
     }
   }
 }#if exists
if($pin_num == -1) {
  if(!((exists $PORTS_ALREADY{$TOP_MODULE}{$inst}) && ($pin eq "PIN"))) {
    print "\nINFO-UTS : 001 : Pin no for pin $pin and instance $inst not found\n";
  }else{
    $pin_num = 0;
  }
}
return($pin_num);
}#sub get_nodenum_for_given_pin




sub update_hier_floorplan_loc {
  my $env_proton_home = $GLOBAL->dbfGlobalGetProtonHome;
  my $input_fpdef = $TOP_MODULE.".fpdef";
  my $output_fpdef = $TOP_MODULE."_out".".fpdef";
  my $ARG1 = "-fpdef";
  my $ARG2 = "-output";

    &write_hier_floorplan;
    #system("$env_proton_home/SCRATCH/blockPlacerGui.pl $ARG1 $input_fpdef $ARG2 $output_fpdef");
    &dbPlaceBlockCompactor("-fpdef", $input_fpdef, "-output", $output_fpdef);
    &read_hier_floorplan("-fpdef", $output_fpdef);
}#sub update_hier_floorplan_loc

sub write_connection_in_tcl {

  my $tcl_file = "new.tcl";
  my @macro_name;
  if ( (-e $tcl_file) && (-w $tcl_file) ) {
    print "INFO-UTS-WR_CONN_TCL : 001 : $tcl_file FILE EXISTS AND IS WRITABLE !\n";
my %duplicate_element = ();
foreach $inst(keys %{$PSEUDO_VINST_ALREADY{$TOP_MODULE}}) {
            push (@macro_name, $inst);
}
    print "INFO-WR_CONN_TCL : 002 : Name is @macro_name\n";
    open(WRITE_TCL, ">>$tcl_file");
    print "INFO-WR_CONN_TCL : 003 : writing tcl\n";
    my $no_of_wire = 0;
    my $no_of_bus = 0;
    print WRITE_TCL "createPseudoNet -parentModule mychip -type wire -source PIN -sink $macro_name[0] \n";  
    print WRITE_TCL "createPseudoNet -parentModule mychip -type wire -source $macro_name[-1] -sink PIN \n";  
    for (my $i = 0; $i <= ($#macro_name * 20); $i++) {
      my $macro0 = $macro_name[int(rand($#macro_name+1))];
      my $macro1 = $macro_name[int(rand($#macro_name+1))];
      if ($macro0 ne $macro1)  {
        my $dup0 = $macro0.".".$macro1;
        my $dup1 = $macro1.".".$macro0;
        if ((!exists $duplicate_element{$dup0}) && (!exists $duplicate_element{$dup1})) {
            $duplicate_element{$dup0} = 1;
            $duplicate_element{$dup1} = 1;
            print WRITE_TCL "createPseudoNet -parentModule mychip -type wire -source $macro0 -sink $macro1 \n";  
            #print WRITE_TCL "createPseudoNet -parentModule mychip -type bus -source $macro0 -sink $macro1 -wireWidth 32 \n";  
            $no_of_wire++;
        } else {
          print "WARN-WR_CONN_TCL : 004 : Connection between instance exists\n";
          print WRITE_TCL "createPseudoNet -parentModule mychip -type bus -source $macro0 -sink $macro1 \n";  
          $no_of_bus++;
        }
      } else {
        print "WARN-WR_CONN_TCL : 005 : Connection between same instance does not exists\n";
      }
    }
    print WRITE_TCL "#No of wire $no_of_wire, no of bus $no_of_bus\n";
    close(WRITE_TCL);
  } else {
    print "WARN-WR_CONN_TCL : 006 : $tcl_file DOES NOT FILE EXISTS AND IS WRITABLE !\n";
  }
}#sub write_connection_in_tcl

sub write_lvs_label {
  
  my $noOfArguments = @_;
  my $outputfile = ""; 
  my $debug = 0;

  my $routed = 0;
  my $unrouted = 0;
  my $ports = 0;

  if ( $_[0] eq '-h' || $_[0] eq '-help') {
    print "Usage : write_lvs_label -output <output file name>\n";
    print "                        --routed\n";
    print "                        --unrouted\n";
    print "                        --ports\n";
  } else {
    for (my $i = 0; $i < $noOfArguments; $i++) {
      if ($_[$i] eq "-output") { $outputfile = $_[$i+1];}
      if ($_[$i] eq "-debug") { $debug = 1;}
      if ($_[$i] eq "--routed") { $routed = 1; }
      if ($_[$i] eq "--unrouted") { $unrouted = 1; }
      if ($_[$i] eq "--ports") { $ports = 1; }
    }
    unless ( $routed || $unrouted || $ports ) {
      $routed = $unrouted = $ports = 1;
    }

    my $topFlplan = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}};
    my $dbu = $topFlplan->dbFlplanGetDBUnit;

    open (WRITE, ">$outputfile");
    print WRITE "Report of net TEXT info\n"; 
    print WRITE "-----------------------\n"; 
foreach my $net ( keys %NETS_ALREADY ) {
  print "DBG-UTS-WR_LVS_LABEL : 001 : for netl $net\n" if ($debug) ;
  my $is_net_info_printed = 0 ;
  if (exists $NETS_ROUTING_ALREADY{$net}) {
    my @data = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
          for (my $temp_cnt = 0 ; $temp_cnt <= $#data; $temp_cnt) {
          my @splitArray = (split(/\s+/,$data[0]));
          if($#splitArray >= 4) {
            my ($layer, $a, $b, $c, $d) = @splitArray[0,2,3,6,7];
            $a /= $dbu;  $b /= $dbu;
            print WRITE "LAYOUT TEXT \"$net\" $a $b $layer $TOP_MODULE\n" if ( $routed ) ;
            $is_net_info_printed = 1 ;
            print "DBG-UTS-WR_LVS_LABEL : 002 : $net is routed\n" if ( $debug );
            last ;
          }
          }
  }
  if ($is_net_info_printed ==0) {
    print "DBG-UTS-WR_LVS_LABEL : 003 : $net is not routed\n" if ( $debug );
	foreach $inst ( keys %{$NETS_ALREADY{$net}})  {
        print "DBG-UTS-WR_LVS_LABEL : 004 : for net $net processing connection $inst\n" if ( $debug );
          if(exists $PORTS_ALREADY{$TOP_MODULE}{$inst}) {
             print "DBG-UTS-WR_LVS_LABEL : 005 : $net is connected to PIN $inst\n" if ( $debug ); 
             my ($xcoord, $ycoord) = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetLoc;
             my $layer = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetLayer;
             $xcoord /= $dbu;  $ycoord /= $dbu;
             print WRITE "LAYOUT TEXT \"$net\" $xcoord $ycoord $layer $TOP_MODULE\n" if ( $unrouted );
             $is_net_info_printed = 1 ;
             last ;
          }elsif($inst eq "PIN") {
             my $CURR_TOP_PIN  = $NETS_ALREADY{$net}{$inst};
             print "DBG-UTS-WR_LVS_LABEL : 006 : $net is connected to PIN $CURR_TOP_PIN\n" if ( $debug ); 
             my ($xcoord, $ycoord) = $PORTS_ALREADY{$TOP_MODULE}{$CURR_TOP_PIN}->dbPortGetLoc;
             my $layer = $PORTS_ALREADY{$TOP_MODULE}{$CURR_TOP_PIN}->dbPortGetLayer;
             $xcoord /= $dbu;  $ycoord /= $dbu;
             print WRITE "LAYOUT TEXT \"$net\" $xcoord $ycoord $layer $TOP_MODULE\n" if ( $unrouted );
             $is_net_info_printed = 1 ;
             last ;
          }
        }# foreach $inst
        if ( $is_net_info_printed ) {
          next;
        }
	foreach $inst ( keys %{$NETS_ALREADY{$net}})  {
          if( exists $COMP_ALREADY{$inst} ) {
              print "DBG-UTS-WR_LVS_LABEL : 007 : $net is connected to component $inst\n" if ( $debug ); 
              my $cellref = $CADB{$inst}->dbCadbGetCellref;
              my @instLoc = $CADB{$inst}->dbCadbGetLoc;
              my $orient = $CADB{$inst}->dbCadbGetOrient;
                 if ( exists $PLDB{$cellref} ){
                    print "DBG-UTS-WR_LVS_LABEL : 008 : $net is connected to component $inst cell $cellref which is in PLDB\n" if ( $debug ); 
                    #---- check if the connected pin exists ----#
                      my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
                      my @cellSize = $PLDB{$cellref}->dbMdbGetSize;
                      my $p =  $NETS_ALREADY{$net}{$inst};
                      my @pinRects = $PLDB{$cellref}->dbMdbGetPinRect($p);
                      my $firstrect = shift @pinRects;
                      my ($layer, $llx2, $lly2, $urx2, $ury2)=(split(/\s+/,$firstrect))[0,2,3,4,5];
                      my @pinCoords = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$orient,$cellSize[0],$cellSize[1],$llx2,$lly2,$urx2,$ury2); 
                      my $xcoord = int(($pinCoords[0] + $pinCoords[2])/2);
                      my $ycoord = int(($pinCoords[1] + $pinCoords[3])/2);
                      $xcoord /= $dbu;  $ycoord /= $dbu;
                      print WRITE "LAYOUT TEXT \"$net\" $xcoord $ycoord $layer $TOP_MODULE\n" if ( $ports );
                      last ;
                 }#if exist cellref
       }
     }# foreach $inst
  }
}# foreach $net
close WRITE;
}#else
}#sub write_lvs_label
#write_lvs_label -input news5378.def

#############################################################################################################################
######################################### code to find centroid of Octagon ##################################################
#############################################################################################################################

sub get_centroid {
my $noOfArg = @_;
my $inputfile = "";

if ( $_[0] eq '-h' || $_[0] eq '-help' || $_[0] eq '-HELP') { print "Usage :  get_centroid -inputfile <name of input file>  \n";
}
else {
  for (my $i = 0; $i < $noOfArg; $i++) {
    if ($_[$i] eq "-inputfile") {
      $inputfile = $_[$i+1];
    }
  } # for
open (READ, $inputfile);
  while (<READ>) {
    chomp;
    if ($_ =~ m/^28/) {
      s/^28\s*//;
      my @polygonVertices = split(/\s+/,$_);
      my $no = @polygonVertices;
      if ($no == 18){ 
my @cop = &getPolygonCentroid(@polygonVertices);
      }
    }
  }
  close READ;
return(@temp_coordinates_of_bbox);
}# else
}#sub get_centroid

sub getPolygonCentroid {
  my @polygonVertices = @_;
  my $totalX = 0;
  my $totalY = 0;
  my $centX  = 0;
  my $centY  = 0;

  my $polygonArea = 0;

  if (isPolygonClosed(@polygonVertices) == 1)  {
    print "INFO-UTS : 001 : Corrupt inputs, not a closed polygon\n";
    return;
  }
  $polygonArea = getPolygonArea(@_);
  for (my $i = 0; $i < ($#polygonVertices - 2); $i = $i + 2) {
    $totalX += ($polygonVertices[$i] + $polygonVertices[$i+2]) * ($polygonVertices[$i+2] * $polygonVertices[$i+1] - $polygonVertices[$i] * $polygonVertices[$i+3]);
    $totalY += ($polygonVertices[$i+1] + $polygonVertices[$i+3]) * ($polygonVertices[$i+2] * $polygonVertices[$i+1] - $polygonVertices[$i] * $polygonVertices[$i+3]);
  }
  $centX = $totalX / (6 * $polygonArea);
  $centY = $totalY / (6 * $polygonArea);
  print "INFO-UTS : 002 : $centX,$centY\n";
  return "$centX,$centY";
}#getPolygonCentroid

sub getPolygonArea {
  my $total = 0;
  my @polygonVertices = @_;
  for(my $i = 0; $i < (scalar(@polygonVertices) - 3); $i = $i + 2) {
    $total += ( ($polygonVertices[$i] * $polygonVertices[$i + 3]) - ($polygonVertices[$i + 2] * $polygonVertices[$i + 1]));
  }
  $total *= -0.5;
  return $total;
}#getPolygonArea


sub isPolygonClosed {
  my @polygonVertices = @_;
  if ( ($polygonVertices[0] != $polygonVertices[-2]) || ($polygonVertices[1] != $polygonVertices[-1])) {
    return 1;
  }
  else {
    return 0;
  }
}#isPolygonClosed

#############################################################################################################################
sub min_dis_x_y {
my $noOfArgs = @_;
if( $_[0] eq '-h' || $_[0] eq '-help' ) { 
  print "Usage : ./min_dis_x_y \n";
  print "                  -file1 <file name> \n";
  print "                  -file2 <file name> \n";
}else{
  my $file1 = "";
  my $file2 = ""; 
  my @coordinates_of_bbox = ();
  for(my $i = 0; $i <= $noOfArgs; $i++) {
    if($_[$i] eq "-file1")  { $file1 = $_[$i+1]; }
    if($_[$i] eq "-file2")  { $file2 = $_[$i+1]; }
  }#for correct no of args
  #@coordinates_of_file2 = get_centroid($file2);
  @coordinates_of_file2 = read_file($file2);
  open (WRITE, ">min_dis");
  open (READ, $file1);
  while (<READ>) {
    my $minValue = 0;
    my $count = 1;
    my $X = "";
    my $Y = "";
    chomp;
    my ($signalName,$x,$y) = (split(/\s+/,$_))[0,1,2];
    foreach my $x_y (@coordinates_of_file2){
      my $x_min = abs($x - @$x_y[0]);
      my $y_min = abs($y - @$x_y[1]);
      my $x_y_min = $x_min + $y_min;
      if ($count == 1){
         $minValue = $x_y_min;
        $X = @$x_y[0];
        $Y = @$x_y[1];
         $count = 0;
      }
      if ($minValue < $x_y_min){
      }else{
        $minValue = $x_y_min;
        $X = @$x_y[0];
        $Y = @$x_y[1];
      }
    }
    my $distance = sqrt(($x - $X)*($x - $X) + ($y - $Y)*($y - $Y));
    print WRITE "$signalName $X $Y $distance\n";
    #print "$signalName $minValue, $X, $Y\n";
  }#while read
#min_dis_x_y -file1 file1 -file2 file2
  close READ;
  close WRITE;
}#else
}#sub min_dis_x_y

sub read_file {
  my @temp_coordinates_of_file = (); 
  my $file = $_[0] ;
  open (READ, $file);
  while (<READ>) {
    chomp;
    my @line = split(/\,/,$_);
    my @my_line = ($line[0]/1000, $line[1]/1000);
    push (@temp_coordinates_of_file , [@my_line]);
  }
  return @temp_coordinates_of_file;
  close READ;
 
}#sub read_file

sub return_shift_x_val_for_instance_location_for_mpl_flatDB {
my $instance = $_[0];
my $shift = 0;
     if(exists $CADB{$instance}) {
     my $cellref = $CADB{$instance}->dbCadbGetCellref;
     if(exists $PLDB{$cellref}) {
     my @org_bbox = $PLDB{$cellref}->dbMdbGetSize;
     my $width = $org_bbox[2] - $org_bbox[0];
     my $height = $org_bbox[3] - $org_bbox[1];
     if ($width < $height) {
       $shift = $width/2;
     } else {
       $shift = $height/2;
     } 
     } 
     } 
     return($shift);

}#sub return_shift_x_val_for_instance_location_for_mpl_flatDB

sub return_shift_y_val_for_instance_location_for_mpl_flatDB {
my $instance = $_[0];
my $shift = 0;
     if(exists $CADB{$instance}) {
     my $cellref = $CADB{$instance}->dbCadbGetCellref;
     if(exists $PLDB{$cellref}) {
     my @org_bbox = $PLDB{$cellref}->dbMdbGetSize;
     my $width = $org_bbox[2] - $org_bbox[0];
     my $height = $org_bbox[3] - $org_bbox[1];
     if ($width < $height) {
       $shift = $width/2;
     } else {
       $shift = $height/2;
     } 
     } 
     } 
     return($shift);

}#sub return_shift_y_val_for_instance_location_for_mpl_flatDB


sub set_blocks_as_fixed {
print "INFO-UTS-SET_BLK_FXD : 001 : Marking all blocks as FIXED\n";

  foreach my $inst (keys %{COMP_ALREADY} ) {
    my $cellref = $CADB{$inst}->dbCadbGetCellref;
    my $inst_class = $PLDB{$cellref}->dbMdbGetClass;
    if($inst_class ne "BLOCK") {
      next;
    }
    $CADB{$inst}->dbCadbSetStatus(FIXED);
    print "INFO-UTS-SET_BLK_FXD : 002 : Marking $inst as FIXED\n";
  }

}#sub set_blocks_as_fixed



sub write_tcl_for_plan {

my $tclfile_name = "gui.tcl";
open(WRITE_TCL, ">$tclfile_name");
  print WRITE_TCL "read_graph -f gui.out\n";
  print WRITE_TCL "display_graph\n";
close(WRITE_TCl);

}#sub write_tcl_for_plan

sub fix_mpl_output 
{

my $count = 0;
my $minx;
my $miny;
my $maxx;
my $maxy;
my $n1_name;
my $n2_name;
my $n3_name;
my $n4_name;
my $n1_width;
my $n1_mid;
my $n2_height;
my $n2_mid;
my $n3_width;
my $n3_mid;
my $n4_height;
my $n4_mid;
my $width;
my $height;

foreach my $instance ( keys %{$PSEUDO_VINST_ALREADY{$TOP_MODULE}} ) {
       if($instance eq "PIN"){ 
       }else{ 
         my $cellref = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstCellref;
         my $status = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstStatus;
         if(exists $PLDB{$cellref}){
           next;
         }
         if($status ne "PLACED"){
           print "\nStatus is $status returning!!!";
           next;
         }
         my @loc = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstRelBbox;
         if($count == 0){
           $minx = $loc[0];
           $n1_name = $instance;
           $n1_width = abs($loc[2] - $loc[0]);
           $n1_mid = $loc[0]+($n1_width/2);

           $miny = $loc[1];
           $n2_name = $instance;
           $n2_height = abs($loc[3] - $loc[1]);
           $n2_mid = $loc[1]+($n2_height/2);

           $maxx = $loc[2];
           $n3_name = $instance;
           $n3_width = abs($loc[2] - $loc[0]);
           $n3_mid = $loc[0]+($n3_width/2);

           $maxy = $loc[3];
           $n4_name = $instance;
           $n4_height = abs($loc[3] - $loc[1]);
           $n4_mid = $loc[1]+($n4_height/2);

           $count = $count+1;
           next;
         }
         if($loc[0] < $minx){ 
           $minx = $loc[0];
           $n1_name = $instance;
           $n1_width = abs($loc[2] - $loc[0]);
           $n1_mid = $loc[0]+($n1_width/2);
         }
         if($loc[1] < $miny){
           $miny = $loc[1];
           $n2_name = $instance;
           $n2_height = abs($loc[3] - $loc[1]);
           $n2_mid = $loc[1]+($n2_height/2);
         }
         if($loc[2] > $maxx){ 
           $maxx = $loc[2];
           $n3_name = $instance;
           $n3_width = abs($loc[2] - $loc[0]);
           $n3_mid = $loc[0]+($n3_width/2);
         }
         if($loc[3] > $maxy){
           $maxy = $loc[3];
           $n4_name = $instance;
           $n4_height = abs($loc[3] - $loc[1]);
           $n4_mid = $loc[1]+($n4_height/2);
         }
         
       }#else
}#foreach
if(exists $PSEUDO_MODULE_ALREADY{$TOP_MODULE} ) {
   my @size = $PSEUDO_MODULE_ALREADY{$TOP_MODULE}->dbaTstgenGetSize;   
   $width = abs($size[2] - $size[0]);
   $height = abs($size[3] - $size[1]);
}else{
  print "returning as size not set for $TOP_MODULE\n";
  return;
}
my $new_width = (($n3_mid - $n1_mid)*2*$width)/(2*$width - ($n3_width + $n1_width));
my $new_height = (($n4_mid - $n2_mid)*2*$height)/(2*$height - ($n4_height + $n2_height));
if ($width > $new_width) {$new_width = $width;}
if ($height > $new_height) {$new_height = $height;}

my $new_minx = $n1_mid - (($n1_width*$new_width)/(2*$width));
my $new_miny = $n2_mid - (($n2_height*$new_height)/(2*$height));
foreach my $instance ( keys %{$PSEUDO_VINST_ALREADY{$TOP_MODULE}} ) {
       if($instance eq "PIN"){ 
       }else{ 
         my @loc = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstRelBbox;
         my $vinst_width = abs($loc[2] - $loc[0]);
         my $vinst_height = abs($loc[3] - $loc[1]);
         my $x_mid = $loc[0]+($vinst_width/2);
         my $y_mid = $loc[1]+($vinst_height/2);
         my $new_x_mid = abs($x_mid-$new_minx)*($width/$new_width);
         my $new_y_mid = abs($y_mid-$new_miny)*($height/$new_height);    
         my $x1 = $new_x_mid-($vinst_width/2);
         my $x2 = $new_x_mid+($vinst_width/2);
         my $y1 = $new_y_mid-($vinst_height/2);    
         my $y2 = $new_y_mid+($vinst_height/2);    
         $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBSetInstRelBbox($x1,$y1,$x2,$y2);
       }
}
}#sub fix_mpl_output
#---------------------------------------------------------------------------------------------------------------------------------------#
sub dump_placement{
my $OUTPUT = "INST_LOC_DATA_2";
open(WRITE_1,">$OUTPUT");
foreach my $instance (keys %CADB){
        my @location = $CADB{$instance}->dbCadbGetLoc;
        #if(@location == ""){print "Not given loc for $instance\n";}
        my $loc_x = $location[0];
        my $loc_y = $location[1];
        print WRITE_1 "$instance\t$loc_x $loc_y\n";
 }#foreach inst
foreach my $ports (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @port_loc = $PORTS_ALREADY{$TOP_MODULE}{$ports}->dbPortGetLoc;
        my $port_loc_x = $port_loc[0];
        my $port_loc_y = $port_loc[1];
        print WRITE_1 "$ports\t$port_loc_x $port_loc_y\n";
}#foreach ports
}#sub dump_placement

#############################################################################################
############################# Adding logical info in VNOM db ################################
#############################################################################################
sub flat2VNOM {
  my $numOfArg = @_;
  if($_[0] eq "-h" || $_[0] eq "-H" || $_[0] eq "-help" || $_[0] eq "-HELP"){
     print "Usage: flat2VNOM  --logical (to add logical info)\n";
     print "                  --physical (to add physical info)\n";
     print "Note: If not given any switch it will add both info\n"; 
     return;
  }else{
     my ($add_logical_info, $add_physical_info) = (0, 0);
     my $moduleName = $TOP_MODULE;
     for(my $i=0; $i<$numOfArg; $i++){
         if($_[$i] eq "--logical"){$add_logical_info = 1;}
         if($_[$i] eq "--physical"){$add_physical_info = 1;}
     }
     if($add_logical_info == 0 && $add_physical_info == 0){
        $add_logical_info = 1;
        $add_physical_info = 1;
     }

     if($add_logical_info == 1){
        if(%MODULE_ALREADY){
          print "ERR-GUI-PROTO-FLT2VNOM : 001 : VNOM database already exists\n"; 
          return;
        }else {
          %MODULE_ALREADY = ();
          $MODULE_ALREADY{$moduleName} = VNOM::new();
          foreach my $instance (keys %COMP_ALREADY){
            my $cellref = $CADB{$instance}->dbCadbGetCellref; 
            my $area = $MODULE_ALREADY{$moduleName}->dbVNOMGetArea;
            my @size = $PLDB{$cellref}->dbMdbGetSize;
            my $delA = $size[0]*$size[1];
            $area = $area + $delA;
            $MODULE_ALREADY{$moduleName}->dbVNOMSetArea($area);
            $MODULE_ALREADY{$moduleName}->dbVNOMAddLeafInst($instance);
            $MODULE_ALREADY{$moduleName}->dbVNOMSetLeafInstCell($instance,$cellref);
          }#foreach instance
          foreach my $portName (keys %{$PORTS_ALREADY{$moduleName}}){
            my $dir = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetDir;
            my $signal = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetSignal;
            if ($dir =~ /input/i ){
              $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($portName); 
            }elsif($dir =~ /output/i){
              $MODULE_ALREADY{$moduleName}->dbVNOMAddOutput($portName); 
            }elsif($dir =~ /inout/i){
              $MODULE_ALREADY{$moduleName}->dbVNOMAddBidi($portName); 
            }
          }#foreach ports
          foreach my $netName (keys %NETS_ALREADY){
            my $netType = 0;
            if (exists $NADB{$netName}) {$netType = $NADB{$netName}->dbNadbGetNetType;}
            if($netType == 0){
              foreach my $instance (keys %{$NETS_ALREADY{$netName}}){ 
                if(exists $COMP_ALREADY{$instance}){
                  my $cellref = $CADB{$instance}->dbCadbGetCellref;
                  my @temp_conn = ();
                  my @pins = $PLDB{$cellref}->dbMdbGetPins;
                  foreach my $pinName (@pins){
                    if($pinName =~ /(vdd|vss)/i){
                    }else {
                      my $conn_net = $COMP_ALREADY{$instance}{$pinName};
                      if($conn_net eq $netName){
                        my $inst_data = ".".$pinName."(".$netName.")"; 
                        push(@temp_conn,$inst_data);
                      }else {
                        my $inst_data = ".".$pinName."("." ".")";
                        push(@temp_conn,$inst_data);
                      }
                    }#else
                  }#foreach pinName           
                  my $temp_conn_line = join", ",@temp_conn;
                  my $connLine = $cellref." ".$instance." (".$temp_conn_line.");"; 
                  $MODULE_ALREADY{$moduleName}->dbVNOMAddConn($connLine);
                }elsif($instance eq "PIN"){}
              }#foreach instance     
            }#if netType == 0
          }#foreach nets
        }#else
     }#if add logical info
     if($add_physical_info == 1){
       &flatdb2Floorplan($moduleName);
     }
  }#else correct num of arg
}#sub flat2VNOM

#############################################################################################
##################### Add phisical info from flat to FLOORPLAN_ALREADY ######################
#############################################################################################
sub flatdb2Floorplan{
  my $moduleName = $_[0];
  my $flplanID;

  if(exists $FLOORPLAN_LOOKUP{"$moduleName/_self_"}){
     $flplanID = $FLOORPLAN_LOOKUP{"$moduleName/_self_"};
  }else{
     $flplanID = $GLOBAL->dbfGlobalGetNextFlplanID;
     $FLOORPLAN_LOOKUP{"$moduleName/_self_"} = $flplanID;
  }

  if(!exists $FLOORPLAN_ALREADY{$flplanID}){
     my $dbu = $GLOBAL->dbfGlobalGetDBU;
     $FLOORPLAN_ALREADY{$flplanID} = Floorplan::new();
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetID($flplanID);
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetCellref($moduleName);
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetDBUnit($dbu);
  }

  my $dbu = $FLOORPLAN_ALREADY{$flplanID}->dbFlplanGetDBUnit;

  ######################### Adding PINS physical info ##########################
  foreach my $portName (keys %{$PORTS_ALREADY{$moduleName}}){
     my $portStatus = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetStatus;
     my $portLayer = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetLayer;
     my @portLoc = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetLoc;
     my @portSize = $PORTS_ALREADY{$moduleName}{$portName}->dbPortGetSize;
     my $port_llx = $portLoc[0]-$portSize[0]/2;
     my $port_lly = $portLoc[1]-$portSize[1]/2;
     my $port_urx = $portLoc[0]+$portSize[0]/2;
     my $port_ury = $portLoc[1]+$portSize[1]/2;
     my $shape = $portLayer." ".$port_llx." ".$port_lly." ".$port_urx." ".$port_ury;
     
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanAddPin($portName);
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetPinStatus($portName, $portStatus);
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanAddPinRect($portName, $shape);
  }#foreach ports

  ####################### Adding COMPONENTS physical info ######################
  foreach my $instName (keys %COMP_ALREADY){
     my ($width, $height) = (0, 0);
     my $cellref = $CADB{$instName}->dbCadbGetCellref; 
     my @instLoc = $CADB{$instName}->dbCadbGetLoc; 
     my $instStatus = $CADB{$instName}->dbCadbGetStatus; 
     my $instOrient = $CADB{$instName}->dbCadbGetOrient;
     if(exists $PLDB{$cellref}){
        ($width, $height) = $PLDB{$cellref}->dbMdbGetSize;
     }

     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanAddLeafInst($instName,$instLoc[0],$instLoc[1],$instOrient);
     $FLOORPLAN_ALREADY{$flplanID}->dbFlplanUpdateLeafInstBbox($instName,$width*$dbu, $height*$dbu);
  }#foreach instance

  ################### Adding NETS/SPECIALNETS physical info ####################
  my $netID = 0;
  foreach my $netName (keys %NETS_ROUTING_ALREADY){
     if(exists $NADB{$netName}) {
        my $netType = $NADB{$netName}->dbNadbGetNetType;#return 0/1/2 (regular/fixed/special)
        if($netType == 0){
           #my $signalType = $NETS_ROUTING_ALREADY{$netName}->dbNetGetType; #return POWER/GROUND/SIGNAL
           #my $netType = $NETS_ROUTING_ALREADY{$netName}->dbRegularNetGetType; #return 0/1/2 (regular/fixed/special)
           if($NETS_ROUTING_ALREADY{$netName}->dbNetGetId){
              $netID = $NETS_ROUTING_ALREADY{$netName}->dbNetGetId;
           }
           my @regularRoutes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetRegularRoute;

           $FLOORPLAN_ALREADY{$flplanID}->dbFlplanAddNets($netName); 
           $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetNetId($netName, $netID); 
           #$FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetNetType($netName, $signalType); 
           $FLOORPLAN_ALREADY{$flplanID}->dbFlplanSetNetType($netName, $netType); 
           foreach my $route (@regularRoutes){
              $FLOORPLAN_ALREADY{$flplanID}->dbFlplanAddNetRoutingData($netName, $route); 
           }
           $netID++;
        }#if netType == 0
     }
  }#foreach nets
}#sub flatdb2Floorplan

#############################################################################################
#################### adding logical & physical infor from VNOM to flat ######################
#############################################################################################
sub hier2flat{
  my $numOfArg = @_;
  if($_[0] eq "-h" || $_[0] eq "-H" || $_[0] eq "-help" || $_[0] eq "-HELP"){
     print "Usage: hier2flat  --logical (to add logical info)\n";
     print "                  --physical (to add physical info)\n";
     print "Note: If not given any switch it will add physical info\n"; 
     return;
  }else{
     my ($add_logical_info, $add_physical_info) = (0, 0);
     for(my $i=0; $i<$numOfArg; $i++){
         if($_[$i] eq "--logical"){$add_logical_info = 1;}
         if($_[$i] eq "--physical"){$add_physical_info = 1;}
     }
     if($add_logical_info == 0 && $add_physical_info == 0){
        $add_physical_info = 1;
     }

     if($add_logical_info == 1){
        &elaborate;
     }

     if($add_physical_info == 1){
        my $global_top_module = $GLOBAL->dbfGlobalGetTOP;
        print "Current top module is $global_top_module\n";
        my $top_module_fplanID = &get_floorplanID_of_module($global_top_module);
        if($top_module_fplanID == -1){
          return;
        }
       
        @{$DIE_ALREADY{dieArea}} = $FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanGetSize;
        ############################## Adding PINS ##################################
        foreach my $port ( keys %{$PORTS_ALREADY{$global_top_module}}) {
           if($FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanHasPin($port)) {
              my @shapes = $FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanGetPinRect($port);
              my ($layer, $pinllx, $pinlly,$pinurx,$pinury) = (split(/\s+/,$shapes[0])) [0,1,2,3,4];
              my $locx = int(($pinllx+$pinurx)/2);
              my $locy = int(($pinlly+$pinury)/2);
              my $width = $pinurx - $pinllx;
              my $height = $pinury - $pinlly;
              $PORTS_ALREADY{$global_top_module}{$port}->dbPortSetLoc($locx,$locy);
              $PORTS_ALREADY{$global_top_module}{$port}->dbPortSetStatus(PLACED);
              $PORTS_ALREADY{$global_top_module}{$port}->dbPortSetLayer($layer);
              #$PORTS_ALREADY{$global_top_module}{$port}->dbPortSetSide("W");
              $PORTS_ALREADY{$global_top_module}{$port}->dbPortSetSize($width, $height);
           }
        }

        ############################## Adding COMPONENTS ##################################
        %hier_inst_abs_location = ();
        foreach my $inst (keys %CADB){
            #my $orient = &get_orien_of_flat_inst_from_pseudo_db($inst);
            my ($x1, $y1, $orient) = &get_location_of_flat_inst_from_pseudo_db($inst);
            $CADB{$inst}->dbCadbSetLoc($x1, $y1);
            $CADB{$inst}->dbCadbSetStatus(PLACED);
            $CADB{$inst}->dbCadbSetOrient($orient);
        }
        %hier_inst_abs_location = ();
        &set_inst_box;

        ################################# Adding NETS ####################################
        #my @nets = $FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanGetNets;
        #foreach my $net (@nets){
        %NADB = ();
        %NETS_ROUTING_ALREADY = ();
        foreach my $net (keys %NETS_ALREADY){
           $NADB{$net} = NetsAttrDB::new();
           $NETS_ROUTING_ALREADY{$net} = NetRoutingDB::new();
          
           my @hier_nets_connected = ();
           if($FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanIsNet($net)){
              push(@hier_nets_connected, $net);#storing top net first
           }#if net is top net 
           
           push(@hier_nets_connected, &getListOfConnectedNets($net));#storing left2right connectivity

           foreach my $connected_net (@hier_nets_connected){
              #my $parentInst = $connected_net;
              #my $parentInst =~ s/\/[^\/]*$//; #substitute last slash & netName 
              my @net_path_arr = split(/\//,$connected_net);
              my $local_net_name = pop @net_path_arr;
              my $parent_local_inst = $net_path_arr[-1];
              my $parent_hier_inst = join "/",@net_path_arr;
              
              my ($locX, $locY, $orient, $temp_parent_floorplanID) = (0, 0, "UND", $top_module_fplanID);

              if(@net_path_arr > 0){ #we have already pop the net name from array
                 ($locX, $locY, $orient) = &get_location_of_flat_inst_from_pseudo_db($parent_hier_inst);
                 my $top_module = &get_parent_module($parent_hier_inst);
                 my $cellref = $MODULE_ALREADY{$top_module}->dbVNOMGetHierInstCell($parent_local_inst);
                 $temp_parent_floorplanID = &get_floorplanID_of_module($cellref);
              }

              if(exists $FLOORPLAN_ALREADY{$temp_parent_floorplanID}){
                 if($FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanIsNet($local_net_name)){
                    my $netId = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetNetId($local_net_name);
                    my $netType = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetNetType($local_net_name);
                    my @rData = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetNetRoutingData($local_net_name);

                    $NADB{$net}->dbNadbSetNetType($netType);
                    $NETS_ROUTING_ALREADY{$net}->dbNetSetId($netId);
                    $NETS_ROUTING_ALREADY{$net}->dbRegularNetSetType($netType);
                    foreach my $r (@rData){
                      if($r =~ m/(\w+) \( (\d+) (\d+) .*?\) \( (\d+|\*) (\d+|\*) .*?\)/ ){ 
                         my $x1 = $2 + $locX;
                         my $y1 = $3 + $locY;
                         my $x2 = $4 + $locX;
                         my $y2 = $5 + $locY; 
                         $r =~ s/(\w+) \( (\d+) (\d+)/$1 \( $x1 $y1/;
                         $r =~ s/\) \( (\d+)/\) \( $x2/;
                         $r =~ s/\) \( \* (\d+)/\) \( \* $y2/;    
                      }
                      $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBSetRegularRoute($r);
                    }#foreach route 
                 }#if net exists in floorplan db
              }#if floorplan exists
           }#foreach intenal net
        }#foreach net
        ##################################################################################
     }#add phisical info
  }
}#sub hier2flat

sub getListOfConnectedNets {
  my $net = $_[0];
  my $global_top_module = $GLOBAL->dbfGlobalGetTOP;
  my %temp_net_hash = ();
  my $netId = 0;
  foreach my $inst (keys %{$NETS_ALREADY{$net}} ){
     if(exists $PORTS_ALREADY{$global_top_module}{$inst}){next;}
     my $pin = $NETS_ALREADY{$net}{$inst};
     HIERLOOP:while(($inst =~ /\//)){
        my @inst_hier_path = (split(/\//,$inst));
        my $inst_local_name = pop (@inst_hier_path); 
        my $temp_parent_module_name = &get_parent_module($inst);
        $inst =~ s/\/[^\/]*$//; #parent instance
        if(exists $MODULE_ALREADY{$temp_parent_module_name}){
           my @conns = $MODULE_ALREADY{$temp_parent_module_name}->dbVNOMGetConn;
           CONNLINE:foreach my $connLine (@conns){
              $connLine =~ s/\(/\)\,/;
              $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
              my ($cell,$inst1) = ( split(/\s+/, $connLine ))[0,1];
              my @nets = split(/\s*\)\s*\,\s*/, $connLine);
              foreach my $netLine (@nets){
                 $netLine =~ s/\s*\(\s*/\|/;
                 $netLine =~ s/\s*\)\s*//;
                 my ($pin1,$net1)=(split(/\s*\|\s*/, $netLine))[0,1];
                 $pin1 =~ s/\.//;
                 if($inst_local_name eq $inst1 && $pin eq $pin1){
                    my $hier_net_name  = $inst."/".$net1;
                    if(!exists $temp_net_hash{$hier_net_name}){
                       $temp_net_hash{$hier_net_name} = $netId++;
                    }
                    if((($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasInput($net1)) == 1)
                         ||(($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasOutput($net1)) == 1)
                         ||(($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasBidi($net1)) == 1)){
                       $pin = $net1;
                    }else{
                       last HIERLOOP;
                    }
                    last CONNLINE;
                 }
              }#for
           }#foreach
        }#if module exists
     }#while
  }#foreach instance
  return (sort {$temp_net_hash{$b}<=>$temp_net_hash{$a}} keys %temp_net_hash);
}#sub getListOfConnectedNets

#############################################################################################
#############################################################################################
#############################################################################################
sub get_location_of_flat_inst_from_pseudo_db
{
  my $curr_inst_hier_name = $_[0];
  ################### Added by aditya if top inst has / in it's name ############
  #if($curr_inst_hier_name =~ /^\s*$/){
  my $global_top_module = $GLOBAL->dbfGlobalGetTOP;
  my $top_module_fplanID = &get_floorplanID_of_module($global_top_module);
  if($FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanHasLeafInst($curr_inst_hier_name)){
     return($FLOORPLAN_ALREADY{$top_module_fplanID}->dbFlplanGetLeafInstLoc($curr_inst_hier_name));
  }elsif($curr_inst_hier_name =~ /^\s*$/){
  ###############################################################################
    return (0,0,"UND");
  }elsif(exists $hier_inst_abs_location{$curr_inst_hier_name}){
    return @{$hier_inst_abs_location{$curr_inst_hier_name}};
  }else {
    my $temp_parent_inst_name = $curr_inst_hier_name;
    my @temp_location_and_orient_of_parent_inst = (0,0, "UND");
    if($curr_inst_hier_name =~ /\//){
      $temp_parent_inst_name =~ s/\/[^\/]*$// ;
      @temp_location_and_orient_of_parent_inst = &get_location_of_flat_inst_from_pseudo_db($temp_parent_inst_name);
    }else{
      @temp_location_and_orient_of_parent_inst = (0,0,"UND");
    }
    my $temp_parent_module_name = &get_parent_module($curr_inst_hier_name);
    my $temp_parent_floorplanID = &get_floorplanID_of_module($temp_parent_module_name);
    if($temp_parent_floorplanID == -1){
      @{$hier_inst_abs_location{$curr_inst_hier_name}} = @temp_location_and_orient_of_parent_inst[0];
      return @{$hier_inst_abs_location{$curr_inst_hier_name}};
    }else {
      my $curr_inst_name = $curr_inst_hier_name ;
      $curr_inst_name =~ s/$temp_parent_inst_name\/// ;
      my $curr_inst_x_val = 0;
      my $curr_inst_y_val = 0;
      my @curr_inst_rel_loc_and_orient = (0,0,"UND");
      if($FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanHasHierInst($curr_inst_name)){
        my @hierBbox = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetHierInstBbox($curr_inst_name);
        my @orient = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetHierInstOrient($curr_inst_name);
        @curr_inst_rel_loc_and_orient = ($hierBbox[0], $hierBbox[1], $orient);
      }elsif($FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanHasLeafInst($curr_inst_name)){
        @curr_inst_rel_loc_and_orient = $FLOORPLAN_ALREADY{$temp_parent_floorplanID}->dbFlplanGetLeafInstLoc($curr_inst_name);
      }else{
        @curr_inst_rel_loc_and_orient = (0,0,"UND");
      }
      $curr_inst_x_val = $curr_inst_rel_loc_and_orient[0] + $temp_location_and_orient_of_parent_inst[0] ;
      $curr_inst_y_val = $curr_inst_rel_loc_and_orient[1] + $temp_location_and_orient_of_parent_inst[1] ;
      @{$hier_inst_abs_location{$curr_inst_hier_name}} = ($curr_inst_x_val,$curr_inst_y_val, $curr_inst_rel_loc_and_orient[2]);
      return @{$hier_inst_abs_location{$curr_inst_hier_name}};
    }
  }
}#sub get_location_of_flat_inst_from_pseudo_db

sub get_floorplanID_of_module
{
  my $curr_module = $_[0];
  my $curr_floorplanID = -1;
  if(exists $FLOORPLAN_LOOKUP{$curr_module}){
    $curr_floorplanID = $FLOORPLAN_LOOKUP{$curr_module};
    return $curr_floorplanID;
  }elsif(exists $FLOORPLAN_LOOKUP{$curr_module."/_self_"}){
    $curr_floorplanID = $FLOORPLAN_LOOKUP{$curr_module."/_self_"};
    return $curr_floorplanID;
  }else{
    foreach my $temp_fplan_name (keys %FLOORPLAN_LOOKUP) {
      if($temp_fplan_name =~ /$curr_module/){
        $curr_floorplanID = $FLOORPLAN_LOOKUP{$temp_fplan_name};
        return $curr_floorplanID;
      }
    }
  }
  print("\nCould not find floorplan ID for module $curr_module");
  return $curr_floorplanID;
}#sub get_floorplanID_of_module
#----------------------------------------------------------------------------------------------------------------------------------------#
#sub hier2flatroutingdata {
#  my $global_top_module = $GLOBAL->dbfGlobalGetTOP;
#  print "Current top module is $global_top_module\n" ;
#  my $top_module_fplanID = &get_floorplanID_of_module($global_top_module);
#  if($top_module_fplanID == -1){
#    return;
#  }
#  foreach my $net (keys %NETS_ALREADY){
#    $NETS_ROUTING_ALREADY{$net} = NetRoutingDB::new();
#    my @routing_data_hier = ();
#    my %TEMP_CHECK_ROUTING = ();
#    foreach my $inst ( keys %{$NETS_ALREADY{$net}} ){
#      if ( exists $PORTS_ALREADY{$TOP_MODULE}{$inst} ) {next;}
#      my $pin = $NETS_ALREADY{$net}{$inst};
#      my @get_net_list = &get_conn_arr_net_hier_from_instance_port($inst,$pin);
#      foreach my $get_net (@get_net_list){
#        #my $get_net = &get_conn_net_hier_from_instance_port($inst,$pin);
#        my @routing_data_hier_inst = &transform_routing($get_net)if($get_net ne "");
#        @{$TEMP_CHECK_ROUTING{$get_net}} = @routing_data_hier_inst;
#      }
#    }#foreach instance
#    my @routing_data = $PSEUDO_FLOORPLAN_ALREADY{"$global_top_module/_self_"}->dbFlplanGetNetRoutingData($net) if($net !~ /\//); 
#    foreach my $data (@routing_data){
#      my $new_data = &get_coord_with_bracket($data);
#      $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBSetRegularRoute($new_data);
#    }#foreach 
#    foreach my $temp_net (keys %TEMP_CHECK_ROUTING){
#      my @data = @{$TEMP_CHECK_ROUTING{$temp_net}};
#      foreach my $data (@data){
#        my ($layer,$x1,$y1,$x2,$y2) = (split(/\s+/,$data))[0,1,2,3,4];
#        my $new_data = ""; 
#        if($x1 eq $x2) { $new_data = "$layer ( $x1 $y1 ) ( * $y2 )";}
#        if($y1 eq $y2) { $new_data = "$layer ( $x1 $y1 ) ( $x2 * )";}
#        $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBSetRegularRoute($new_data);
#      }#foreach net
#    }#foreach
#  }
#}#sub hier2flatroutingdata
##----------------------------------------------------------------------------------------------------------------------------------------#
#sub transform_routing {
#my $curr_inst_hier_name_with_net = $_[0];
#my @data_new = ();
#my @inst_list = (split(/\//,$curr_inst_hier_name_with_net));
#my $number = @inst_list;
#my $netName = pop (@inst_list); 
#my @temp_list = @inst_list; 
#my $connected_inst = pop (@temp_list); 
#if($connected_inst eq ""){next;}
##my $curr_flat_inst_location_x = 0;
##my $curr_flat_inst_location_y = 0;
#my $inst_list_str = join"/",@inst_list;
#my ($curr_flat_inst_location_x,$curr_flat_inst_location_y) = &get_location_of_flat_inst_from_pseudo_db($inst_list_str);
##foreach my $inst (@inst_list){
##my @temp_flat_inst_location = &get_location_of_flat_inst_from_pseudo_db($inst);
##$curr_flat_inst_location_x  = $temp_flat_inst_location[0] + $curr_flat_inst_location_x; 
##$curr_flat_inst_location_y  = $temp_flat_inst_location[1] + $curr_flat_inst_location_y; 
##}
#my $temp_parent_module_name = &get_parent_module($connected_inst);
#my $cellref = $MODULE_ALREADY{$temp_parent_module_name}->dbVNOMGetHierInstCell($connected_inst);
#if($cellref eq "UND"){
#   my @data = $PSEUDO_FLOORPLAN_ALREADY{"$temp_parent_module_name/_self_"}->dbFlplanGetNetRoutingData($netName);
#  foreach my $l (@data) {
#    my $layerName = (split(/\s+/,$l))[0];
#    my @routeBox = &xformNetSegToPathSeg($l);
#    my $curr_route_box_x1 = $routeBox[0] + $curr_flat_inst_location_x;
#    my $curr_route_box_y1 = $routeBox[1] + $curr_flat_inst_location_y;
#    my $curr_route_box_x2 = $routeBox[2] + $curr_flat_inst_location_x;
#    my $curr_route_box_y2 = $routeBox[3] + $curr_flat_inst_location_y;
#    my $curr_net_data = $layerName." ".$curr_route_box_x1." ".$curr_route_box_y1." ".$curr_route_box_x2." ".$curr_route_box_y2;
#    push (@data_new,$curr_net_data); 
#  }#foreach
#}else {
#  my @data = $PSEUDO_FLOORPLAN_ALREADY{"$cellref/_self_"}->dbFlplanGetNetRoutingData($netName);
#  foreach my $l (@data) {
#    my $layerName = (split(/\s+/,$l))[0];
#    my @routeBox = &xformNetSegToPathSeg($l);
#    my $curr_route_box_x1 = $routeBox[0] + $curr_flat_inst_location_x;
#    my $curr_route_box_y1 = $routeBox[1] + $curr_flat_inst_location_y;
#    my $curr_route_box_x2 = $routeBox[2] + $curr_flat_inst_location_x;
#    my $curr_route_box_y2 = $routeBox[3] + $curr_flat_inst_location_y;
#    my $curr_net_data = $layerName." ".$curr_route_box_x1." ".$curr_route_box_y1." ".$curr_route_box_x2." ".$curr_route_box_y2;
#    push (@data_new,$curr_net_data); 
#  }#foreach
#}
#return(@data_new);
#}#sub transform_routing
##----------------------------------------------------------------------------------------------------------------------------------------#
#sub get_conn_net_hier_from_instance_port {
#my $curr_inst = $_[0];
#my $curr_port = $_[1];
#my $netName_with_path = "";
#my $temp_parent_inst_name = $curr_inst;
#$temp_parent_inst_name =~ s/\/[^\/]*$// ;
##if($MODULE_ALREADY{$TOP_MODULE}->dbVNOMHasHierInst($temp_parent_inst_name)){
#  my $temp_parent_module_name = &get_parent_module($curr_inst);
#  my @inst_list = (split(/\//,$curr_inst));
#  my $leaf_inst = pop (@inst_list); 
#  if(exists $MODULE_ALREADY{$temp_parent_module_name}){
#    my @conns = $MODULE_ALREADY{$temp_parent_module_name}->dbVNOMGetConn;
#    foreach my $connLine (@conns){
#      $connLine =~ s/\(/\)\,/;
#      $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
#      my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
#      my @nets = split(/\s*\)\s*\,\s*/, $connLine);
#      my  $noOfPins = @nets;
#      for(my $i = 1 ; $i < $noOfPins ; $i++){
#        $nets[$i] =~ s/\s*\(\s*/\|/;
#        $nets[$i] =~ s/\s*\)\s*//;
#        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
#        $pin =~ s/\.//;
#        if($leaf_inst eq $inst && $pin eq $curr_port){
#        my $new_inst_str  = join"/",@inst_list;
#        $netName_with_path  = $new_inst_str."/".$net;
#        }
#      }#for
#    }#foreach
#  }
##}
#return($netName_with_path);
#}#sub get_conn_net_hier_from_instance_port
##----------------------------------------------------------------------------------------------------------------------------------------#
#sub get_conn_arr_net_hier_from_instance_port {
#my $inst = $_[0];
#my $port = $_[1];
#my @arr_net_list = ();
#my $inst1 = $inst;
#my $port1 = $port; 
#while (($inst1 =~ /\//)){
#  my $get_net = &get_conn_net_hier_from_instance_port($inst1,$port1); 
#  push(@arr_net_list,$get_net);
#  $inst1 =~ s/\/[^\/]*$//; 
#  my @temp_net_list = split(/\//,$get_net);
#  my $temp_net = pop (@temp_net_list);
#  my $temp_parent_module_name = &get_parent_module($inst1);
#  if ((($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasInput($temp_net)) == 0)
#     ||(($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasOutput($temp_net)) == 0)
#     ||(($MODULE_ALREADY{$temp_parent_module_name}->dbVNOMHasBidi($temp_net)) == 0)){
#    $port1 = $temp_net;
#    next;
#  }else{
#    last;
#  }
#}#while
#return (@arr_net_list);
#}#sub get_conn_arr_net_hier_from_instance_port
#----------------------------------------------------------------------------------------------------------------------------------------#
#sub test_pseudo_small 
#{
#use Benchmark;
#my $t0 = new Benchmark;
#my $curr_module = $_[0];
#if(!defined($curr_module)){
#  $curr_module = $TOP_MODULE ;
#}
#my %PORT_HASH = ();
#my @output_pins = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetOutput;
#foreach my $out (@output_pins) {
#  if ( $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetOutputType($out) == 0 ) {
#    $PORT_HASH{$out} = $nodeCnt++;
#  } else {
#    my $bits = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetOutputBits($out);
#    my $pin = $out . $bits;
#    my @portList = utilSplitBusBits($pin);
#    foreach my $port ( @portList ) {
#      $PORT_HASH{$port} = $nodeCnt++;
#    }
#  }
#}
#
#my @input_pins = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetInput;
#foreach my $in (@input_pins) {
#  if ( $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetInputType($in) == 0 ) {
#    $PORT_HASH{$in} = $nodeCnt++;
#  } else {
#    my $bits = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetInputBits($in);
#    my $pin = $in . $bits;
#    my @portList = utilSplitBusBits($pin);
#    foreach my $port ( @portList ) {
#      $PORT_HASH{$port} = $nodeCnt++;
#    }
#  }
#}
#
#my @bidi_pins = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetBidi;
#foreach my $bidi (@bidi_pins){
#  $PORT_HASH{$bidi} = $nodeCnt++;
#}
#
#my $curr_floor_plan = $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenGetFloorplan;
#my $count = 0;
#foreach $instance(keys %{$PSEUDO_VINST_ALREADY{$curr_module}}) {
#  if($instance eq "PIN"){ 
#    next;
#  }
#  my @org_bbox = &return_pseudo_vinst_size($curr_module,$instance);
#  my $width = $org_bbox[2] - $org_bbox[0];
#  my $height = $org_bbox[3] - $org_bbox[1];
#  $cur_bbox[0] = $count; 
#  $cur_bbox[1] = $count; 
#  $cur_bbox[2] = $count + $width; 
#  $cur_bbox[3] = $count + $height; 
#  $PSEUDO_VINST_ALREADY{$curr_module}{$instance}->dbPimDBSetInstRelBbox(@cur_bbox);
#  $PSEUDO_VINST_ALREADY{$curr_module}{$instance}->dbPimDBSetInstStatus(PLACED);
#  $PSEUDO_VINST_ALREADY{$curr_module}{$instance}->dbPimDBSetInstOrient(N);
#  $count++;
#}
#$count = 0;
#foreach $instance(keys %PORT_HASH) {
#  $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenWipePinRect($instance);
#  my @bbox = ($count, $count, $count, $count);
#  my $shape = join(" ", "metal1", @bbox);
#  $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenAddPinRect($instance, $shape);
#  $PSEUDO_MODULE_ALREADY{$curr_module}->dbaTstgenSetPinStatus($instance, "PLACED");
#  $count++;
#}
#print "\nINFO-TST-READ_HR_PL_GRPH : 004 : Reading location of pins of the instances in the module" ;
#if ( -e $MPL_NODE_PIN_LOCATION) {
#  print "\nINFO-TST-READ_HR_PL_GRPH : 005 : mp_pins.out file exists" ;
#}
#print "subroutine read_hier_place_graph took:",timestr($td),"\n";
#}#sub test_pseudo_small

sub reset_dirty_bit_hier_module {
my $hier_module = $_[0];
  if(exists $PSEUDO_MODULE_ALREADY{$hier_module}){
    $PSEUDO_MODULE_ALREADY{$hier_module}->dbaTstgenSetPhysicalDirty(0);
    print "Dirty bit for $hier_module reset\n";
  }else{
    print "Module $hier_module not being edit\n";
  }
}#sub reset_dirty_bit_hier_module

sub set_dirty_bit_hier_module {
my $hier_module = $_[0];
  if(exists $PSEUDO_MODULE_ALREADY{$hier_module}){
    $PSEUDO_MODULE_ALREADY{$hier_module}->dbaTstgenSetPhysicalDirty(1);
    print "Dirty bit for $hier_module set\n";
  }else{
    print "Module $hier_module not being edit\n";
  }
}#sub set_dirty_bit_hier_module

sub print_dirty_bit_hier_module {
my $hier_module = $_[0];
  if(exists $PSEUDO_MODULE_ALREADY{$hier_module}){
    if($PSEUDO_MODULE_ALREADY{$hier_module}->dbaTstgenGetPhysicalDirty() ==1){
      print "Dirty bit for $hier_module 1\n";
      return 1;
    }else{
      print "Dirty bit for $hier_module 0\n";
      return 0;
    }
  }else{
    print "Module $hier_module not being edit\n";
    return "";
  }
}#sub print_dirty_bit_hier_module

sub pseudo_inst_status {
foreach my $instance ( keys %{$PSEUDO_VINST_ALREADY{$TOP_MODULE}} ) {
       if($instance eq "PIN"){ 
       }else{ 
         my $cellref = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstCellref;
         my $status = $PSEUDO_VINST_ALREADY{$TOP_MODULE}{$instance}->dbPimDBGetInstStatus;
           print "\nStatus of $instance is $status returning!!!";
#         if(exists $PLDB{$cellref}){
#           next;
#         }
         if($status ne "PLACED"){
           print "\nStatus of $instance is $status returning!!!";
         }
       }
}
}#sub pseudo_inst_status

sub generate_LVS_data_for_given_module
{
  my $noOfArguments = @_;
  my $module_name = "";
  my $def_file_name = "";
  my $vlog_file_name = "";
  my $no_of_level_in_hierarchy = -1;
  my $overwrite_files = 0;
  my $lvs_strategy = "bottom_up";
  if( $_[0] eq '-h' || $_[0] eq '-help' ) { 
    print "Usage : generate_LVS_data_for_given_module -module <module_name> \n";
    print "                  -def_file <def_file_name> \n";
    print "                  -vlog_file <vlog_file_name> \n";
    print "                  -port_map_file <port_map_file_name> \n";
    print "                  -no_of_level_in_hierarchy <no_of_level_in_hierarchy> \n";
    print "                  --overwrite\n";
    print "                  -lvs_strategy <top_down|bottom_up>\n";
    return;
  }else{
    for(my $i = 0; $i <= $noOfArguments; $i++) {
      if($_[$i] eq "-module")  { $module_name = $_[$i+1]; }
      if($_[$i] eq "-def_file")  { $def_file_name = $_[$i+1]; }
      if($_[$i] eq "-vlog_file")  { $vlog_file_name = $_[$i+1]; }
      if($_[$i] eq "-port_map_file")  { $port_map_file_name = $_[$i+1]; }
      if($_[$i] eq "-no_of_level_in_hierarchy")  { $no_of_level_in_hierarchy = $_[$i+1]; }
      if($_[$i] eq "--overwrite")  { $overwrite_files = 1; }
      if($_[$i] eq "-lvs_strategy")  { $lvs_strategy = $_[$i+1]; }
    }
  }
  if($module_name eq ""){
    print "Usage : generate_LVS_data_for_given_module -module <module_name> \n";
    print "                  -def_file <def_file_name> \n";
    print "                  -vlog_file <vlog_file_name> \n";
    print "                  -port_map_file <port_map_file_name> \n";
    print "                  -no_of_level_in_hierarchy <no_of_level_in_hierarchy> \n";
    print "                  --overwrite\n";
    print "                  -lvs_strategy <top_down|bottom_up>\n";
    return;
  }
  if($def_file_name eq ""){
    $def_file_name = "$module_name.def" ;
  }
  if($vlog_file_name eq ""){
    $vlog_file_name = "$module_name.v" ;
  }
  if($port_map_file_name eq ""){
    $port_map_file_name = "${module_name}_port_map.txt" ;
  }
  if ( -e $def_file_name ) {
    if ( $overwrite_files == 1 ) {
      if (!(-w $def_file_name)) {
        print "ERR-GN_LVS_DATA_FILE : 001 : $def_file_name is not writable. Please change the output/permission of the file and try again\n";
        return;
      }
      print "WARN-GN_LVS_DATA_FILE : 002 : $def_file_name exists, overwriting existing file as instructed\n";
    } else {
      print "ERR-GN_LVS_DATA_FILE : 003 : $def_file_name exists, Please change the output file name or remove the existing file and try again\n";
      return;
    }
  }
  if ( -e $vlog_file_name ) {
    if ( $overwrite_files == 1 ) {
      if (!(-w $vlog_file_name)) {
        print "ERR-GN_LVS_DATA_FILE : 001 : $vlog_file_name is not writable. Please change the output/permission of the file and try again\n";
        return;
      }
      print "WARN-GN_LVS_DATA_FILE : 002 : $vlog_file_name exists, overwriting existing file as instructed\n";
    } else {
      print "ERR-GN_LVS_DATA_FILE : 003 : $vlog_file_name exists, Please change the output file name or remove the existing file and try again\n";
      return;
    }
  }
  if ( -e $port_map_file_name ) {
    if ( $overwrite_files == 1 ) {
      if (!(-w $port_map_file_name)) {
        print "ERR-GN_LVS_DATA_FILE : 001 : $port_map_file_name is not writable. Please change the output/permission of the file and try again\n";
        return;
      }
      print "WARN-GN_LVS_DATA_FILE : 002 : $port_map_file_name exists, overwriting existing file as instructed\n";
    } else {
      print "ERR-GN_LVS_DATA_FILE : 003 : $port_map_file_name exists, Please change the output file name or remove the existing file and try again\n";
      return;
    }
  }
  if( !exists $MODULE_ALREADY{$module_name} ) {
    return "" ;
  }
  my $start_module =  $GLOBAL->dbfGlobalGetTOP();
  if($module_name eq $start_module){
    print "\n Info : You have selected top module";
    print "\n      : Use complete design file for LVS";
    return ;
  }
  my $instance_path_name = &get_hier_instance_full_path_name_given_module($module_name,$start_module,"");
  if(length($instance_path_name) ==0){
    print "\n Error: No instance of given module found";
    print "\n      : Cannot generate module data for LVS";
    return;
  }
  my $parent_module = &get_parent_module($instance_path_name);
  my $bottom_inst_name = $instance_path_name;
  if($instance_path_name =~ /.*\/.*/){
    $bottom_inst_name = (split(/\//, $instance_path_name ))[-1];
  }
  if ($MODULE_ALREADY{$parent_module}->dbVNOMHasLeafInst($bottom_inst_name)) {
    print "\n Error: module given is a leaf level instance";
    print "\n      : Cannot generate module data for LVS";
    return;
  }
  #&write_def();
  if($overwrite_files ==1){
    &write_verilog("-output",$vlog_file_name,"-start_module",$module_name,"-no_of_level",$no_of_level_in_hierarchy,"--hier","--overwrite");
  }else{
    &write_verilog("-output",$vlog_file_name,"-start_module",$module_name,"-no_of_level",$no_of_level_in_hierarchy,"--hier");
  }
  &generate_port_data_file_for_module_inst($instance_path_name,$port_map_file_name,$lvs_strategy);
}#sub generate_LVS_data_for_given_module

sub get_hier_instance_full_path_name_given_module 
{
  my $module_name = $_[0];
  my $parent_module_name = $_[1];
  my $parent_instance_full_path_name = $_[2];
  my @hier_insts =  $MODULE_ALREADY{$parent_module_name}->dbVNOMGetHierInst;
  foreach my $inst ( @hier_insts) {
    my $cell_ref = $MODULE_ALREADY{$parent_module_name}->dbVNOMGetHierInstCell($inst);
    if($cell_ref eq $module_name){
      if($parent_instance_full_path_name ne "") {
        return $parent_instance_full_path_name."/".$inst;
      }else{
        return $inst;
      }
    }
  }
  my @leaf_insts =  $MODULE_ALREADY{$parent_module_name}->dbVNOMGetLeafInst;
  foreach my $inst ( @leaf_insts) {
    my $cell_ref = $MODULE_ALREADY{$parent_module_name}->dbVNOMGetLeafInstCell($inst);
    if($cell_ref eq $module_name){
      if($parent_instance_full_path_name ne "") {
        return $parent_instance_full_path_name."/".$inst;
      }else{
        return $inst;
      }
    }
  }
  foreach my $inst ( @hier_insts) {
    my $cell_ref = $MODULE_ALREADY{$parent_module_name}->dbVNOMGetHierInstCell($inst);
    if($parent_instance_full_path_name ne "") {
      $parent_instance_full_path_name = $parent_instance_full_path_name."/".$inst;
    }else{
      $parent_instance_full_path_name = $inst;
    }
    my $temp_full_path_name = &get_hier_instance_full_path_name_given_module($module_name,$cell_ref,$parent_instance_full_path_name);
    if(length($temp_full_path_name) >0){
      return $temp_full_path_name;
    }
    $parent_instance_full_path_name =~ s/$inst$//g;
    $parent_instance_full_path_name =~ s/\/$//g;
  }
  return "";
}#sub get_hier_instance_full_path_name_given_module

sub populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module
{
  my $module_name = $_[0];
  my $max_no_of_level = $_[1];
  if(!defined($module_name)) {
    print "Error: Module $module_name not defined\n";
    return ;
  }
  if(!exists $MODULE_ALREADY{$module_name}) {
    print "Error: Module $module_name not found\n";
    return ;
  }
  my $start_module =  $GLOBAL->dbfGlobalGetTOP();
  if($module_name ne $start_module){
    my $instance_path_name = &get_hier_instance_full_path_name_given_module($module_name,$start_module,"");
    if(length($instance_path_name) ==0){
      print "Error: No instance of given module \"$module_name\" found\n";
      return;
    }
  }
  if($max_no_of_level == 0){
    return;
  }
  my $curr_no_of_level = 0;
  if($max_no_of_level != 0) {
    $TEMP_MODULE_ALREADY{$module_name} = $curr_no_of_level; 
  }
  $curr_no_of_level++;
  if($curr_no_of_level == $max_no_of_level){
    return;
  }
  &sub_populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($module_name,$curr_no_of_level,$max_no_of_level);
}#sub populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module

sub sub_populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module
{
  my $module_name = $_[0];
  my $curr_no_of_level = $_[1];
  my $max_no_of_level = $_[2];
  if($curr_no_of_level == $max_no_of_level){
    return;
  }
  my @hier_insts =  $MODULE_ALREADY{$module_name}->dbVNOMGetHierInst;
  foreach my $inst ( @hier_insts) {
    my $cell_ref = $MODULE_ALREADY{$module_name}->dbVNOMGetHierInstCell($inst);
    $TEMP_MODULE_ALREADY{$cell_ref} = $curr_no_of_level; 
  }
  $curr_no_of_level++;
  if($curr_no_of_level == $max_no_of_level){
    return;
  }
  foreach my $inst ( @hier_insts) {
    my $cell_ref = $MODULE_ALREADY{$module_name}->dbVNOMGetHierInstCell($inst);
    &sub_populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($cell_ref,$curr_no_of_level,$max_no_of_level);
  }
}#sub sub_populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module

sub generate_port_data_file_for_module_inst
{
  my $instance_path_name = $_[0];
  my $port_map_file_name = $_[1];
  my $lvs_strategy = $_[2];
  %TEMP_PATH_LVS = ();
  %TEMP_HIER_PORT_NET_MAP_LVS = ();
  my $dbu = $GLOBAL->dbfGlobalGetDBU;
  my $defaul_metalLayer = "";
  foreach my $metalLayer (keys %PTDB) {
    my $type = $PTDB{$metalLayer}->dbTechGetLayerType;
    if ($type eq "ROUTING") {
      $defaul_metalLayer = $metalLayer;
      last;
    }
  }
  my $start_module =  $GLOBAL->dbfGlobalGetTOP();
  &populate_hier_inst_port_net_map($start_module,$instance_path_name); 
  open(LVS_PORT_MAP_FILE,">$port_map_file_name");
  my $bottom_inst_name = $instance_path_name;
  if($instance_path_name =~ /.*\/.*/){
    $bottom_inst_name = (split(/\//, $instance_path_name ))[-1];
  }
  my $cellref = $MODULE_ALREADY{$start_module}->dbVNOMGetHierInstCell($bottom_inst_name);
  my $depth = @TEMP_PATH_LVS;
  my $depth_minus_one = $depth -1;
  my $temp_bottom_inst_name_key = $bottom_inst_name."_".$depth_minus_one;
  foreach my $portName (keys %{$TEMP_HIER_PORT_NET_MAP_LVS{$temp_bottom_inst_name_key}}){
    my $netName = $TEMP_HIER_PORT_NET_MAP_LVS{$temp_bottom_inst_name_key}{$portName};
    for(my $xx = $depth -2 ; $xx >= 0 ; $xx--) {
      my $parent = $TEMP_PATH_LVS[$xx];
      if ($parent eq $TOP_MODULE ) { 
        last; 
      }else { 
        my $temp_inst_hash_key = $TEMP_PATH_LVS[$xx] ;
        $temp_inst_hash_key = $temp_inst_hash_key."_".$xx;
        if ( exists $TEMP_HIER_PORT_NET_MAP_LVS{$temp_inst_hash_key}{$netName} ) {
          $netName = $TEMP_HIER_PORT_NET_MAP_LVS{$temp_inst_hash_key}{$netName};
        }else {
          my $temp_hier_name = "" ;
          for(my $yy = $xx ; $yy >= 0 ; $yy--) {
            if($temp_hier_name eq "") {
              $temp_hier_name = $TEMP_PATH_LVS[$yy];
            }else {
              $temp_hier_name = $TEMP_PATH_LVS[$yy]."/".$temp_hier_name;
            }
          }
          $netName = $temp_hier_name."/".$netName;
          last;
        }
      }
    }
    my $lvs_info_written= 0;
    if ( exists $NETS_ROUTING_ALREADY{$netName} ) {
      my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetRegularRoute;
      if ( @routes > 0 ) {
        my $l = shift @routes;
        my @routeBox = &xformNetSegToPathSeg($l);
        my $layerName = (split(/\s+/,$l))[0];
        my $mid_x = ($routeBox[0] + $routeBox[2])/(2*$dbu);
        my $mid_y = ($routeBox[1] + $routeBox[3])/(2*$dbu);
        if($lvs_strategy eq "top_down"){
          print LVS_PORT_MAP_FILE "\nLAYOUT TEXT \"$netName\" $mid_x $mid_y $layerName";
        }else{
          print LVS_PORT_MAP_FILE "\nLAYOUT TEXT \"$portName\" $mid_x $mid_y $layerName";
        }
        $lvs_info_written= 1;
      }
    }
    if($lvs_info_written ==0){
      my $temp_lvs_string = "";
      if($lvs_strategy eq "top_down"){
        $temp_lvs_string = "\nLAYOUT TEXT \"$netName\"";
      }else{
        $temp_lvs_string = "\nLAYOUT TEXT \"$portName\"";
      }
      my @driverInst = &getNetDriver($netName);
      my @sinkInst = &getNetSink($netName);
      my @tmp_instList = ();
      my @tmp_instPinList = ();
      if (( $driverInst[0] ne "UND") && ($driverInst[0] ne "")){
        push(@tmp_instList,$driverInst[0]);
        push(@tmp_instPinList,$driverInst[1]);
      }
      for(my $i = 0;$i<=$#sinkInst;$i=$i+2){
        push(@tmp_instList,$sinkInst[$i]);
        push(@tmp_instPinList,$sinkInst[$i+1]);
      }
      foreach my $inst (@tmp_instList){
        my $instPin = shift(@tmp_instPinList) ;
        if(exists $PORTS_ALREADY{$TOP_MODULE}{$inst} ) {
          my $status = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetStatus;
          if($status >1){
            my @portLoc = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetLoc;
            my $portLayer = $PORTS_ALREADY{$TOP_MODULE}{$inst}->dbPortGetLayer;
            if($portLayer !=0){
              $portLoc[0] /= $dbu;
              $portLoc[1] /= $dbu;
              $temp_lvs_string = $temp_lvs_string." ".$portLoc[0]." ".$portLoc[1]." ".$portLayer;
            }
          }
        }elsif(exists $COMP_ALREADY{$inst}){
          my $status = $CADB{$inst}->dbCadbGetStatus;
          if ( $status eq "PLACED" || $status eq "FIXED" ) {
            my $cellref = $CADB{$inst}->dbCadbGetCellref;
            my @instLoc = $CADB{$inst}->dbCadbGetLoc;
            my $instOrient = $CADB{$inst}->dbCadbGetOrient;
            if (exists $PLDB{$cellref}){
              my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
              my @cellsize = $PLDB{$cellref}->dbMdbGetSize;
              my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($instPin);
              my ($pinLayer,$pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[0,2,3,4,5];
              my @absolute_pin_rect = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],$pinllx,$pinlly,$pinurx,$pinury);
              my $xmiddle_pin_rect = ($absolute_pin_rect[0]+$absolute_pin_rect[2])/2;
              my $ymiddle_pin_rect = ($absolute_pin_rect[1]+$absolute_pin_rect[3])/2; 
              $xmiddle_pin_rect /= $dbu;
              $ymiddle_pin_rect /= $dbu;
              $temp_lvs_string = $temp_lvs_string." ".$xmiddle_pin_rect." ".$ymiddle_pin_rect." ".$pinLayer;
            }
          }else{
          }
        }else{
        }
      }
      print LVS_PORT_MAP_FILE $temp_lvs_string;
    }
  }
  close (LVS_PORT_MAP_FILE);
}#sub generate_port_data_file_for_module_inst

sub populate_hier_inst_port_net_map 
{
my $current_module_name = $_[0];
my $instance_path_name = $_[1];
if($instance_path_name =~ /^\s*$/){
  return;
}
my $instance_current = $instance_path_name;
if($instance_path_name =~ /.*\/.*/) {
  $instance_current = (split(/\//, $instance_path_name ))[0];
}
$instance_path_name =~ s/^$instance_current//g;
$instance_path_name =~ s/^\///g;
my @conns = $MODULE_ALREADY{$current_module_name}->dbVNOMGetConn;
my $depth = @TEMP_PATH_LVS;
foreach $connLine ( @conns ) {
$connLine =~ s/\(/\)\,/;
$connLine =~ s/\)\s*\;//;
my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
if ( $MODULE_ALREADY{$current_module_name}->dbVNOMHasHierInst($inst) ) {
if ( $inst eq $instance_current) {
print "DBG-PAR-LVS : 011 : $inst in $current_module_name is a hierachical instance\n" if($DEBUG == 300);
print "DBG-PAR-LVS : 012 : Add outside port conn of $inst\n" if($DEBUG == 300);
   #--- recursively create the COMP db  for hierarchical instances ---#
   #print "$inst is hierarchcal cell of module $cell .. elaborating it now\n";
   my $inst_hash_key = $inst."_".$depth;
   push(@TEMP_PATH_LVS,$inst);
               @nets = split(/\s*\)\s*\,\s*/, $connLine);
               my  $noOfPins = @nets;
               for(my $i = 1 ; $i < $noOfPins ; $i++){
               $nets[$i] =~ s/\s*\(\s*/\|/;
               $nets[$i] =~ s/\s*\)\s*//;
               my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
               $pin =~ s/\.//;
               $netName = $net;
# check if the hier pin for this coneection is  bus
               print "DBG-PAR-LVS : 013 : checking type of $pin\n" if($DEBUG == 300);
               my $pinType = 0 ; # signal by default
               my $pinDir = 0 ; # signal by default
               if ( exists $MODULE_ALREADY{$cell}->{ins}{$pin} ) {
               $pinType = $MODULE_ALREADY{$cell}->dbVNOMGetInputType($pin);
               $pinDir = 1;
                                                                 }
               elsif ( exists $MODULE_ALREADY{$cell}->{outs}{$pin} ) {
               $pinType = $MODULE_ALREADY{$cell}->dbVNOMGetOutputType($pin);
               $pinDir = 2;
                                                                    }
               elsif ( exists $MODULE_ALREADY{$cell}->{bidis}{$pin} ) {
               $pinType = $MODULE_ALREADY{$cell}->dbVNOMGetBidiType($pin);
               $pinDir = 3;
                                                                    }
               else {
               print "DBG-ERR-PAR-LVS : 014 : $pin on $cell for instance $inst is neither input nor output\n" if($DEBUG == 300);
                    }
               if ( $pinType == 1 ) { print "DBG-PAR-LVS : 015 : it is a bus\n" if($DEBUG == 300); } else { print "DBG-PAR-LVS : 016 : it is a single\n" if($DEBUG == 300); }
#---------------------------------------- if bus is explictly connected to the hier module ports -----------------#
               if ( $net =~ /\{/ ) { 
                    print "DBG-PAR-LVS : 017 :\t$pin \=\> $net\n" if ($DEBUG == 300); 
                    $net =~ s/\{//; $net =~ s/\}//;
                    $net =~ s/\s+//g;
                    print "DBG-PAR-LVS : 018 : After subs $net\n" if($DEBUG == 300);
                    my @allnets = split(/\s*\,\s*/, $net);
                    my $len = @allnets;
                    print "DBG-PAR-LVS : 019 : $len nets connect to this bus\n" if($DEBUG == 300);
                    if ( exists $MODULE_ALREADY{$cell}->{ins}{$pin} ) {
                    print "DBG-PAR-LVS : 020 : $pin is an input bus\n" if($DEBUG == 300);
                    my $type = $MODULE_ALREADY{$cell}->dbVNOMGetInputType($pin);
                    if ( $type == 0 ) {
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pin} = $net;
                               print "DBG-PAR-LVS : 021 : $pin connects $netName on $cell\n" if($DEBUG == 300);
                               
                                      }
                    else {
                    my $width = $MODULE_ALREADY{$cell}->dbVNOMGetInputBits($pin);
                    $width =~ s/\[//; $width =~ s/\]//;
                    my @W = split(/\s*\:\s*/,$width);
                    print "DBG-PAR-LVS : 022 : MSB is $W[0]\n" if($DEBUG == 300);
                    my $busWidth = abs($W[1] - $W[0])+1;
                    print "DBG-PAR-LVS : 023 : Bus $pin it connects to is of $busWidth width\n" if($DEBUG == 300);
                    if ( $busWidth == $len ) {
                         if ( $W[0] <= $W[1] ) {
                              my $cnt = 0;
                              for (my $xx = $W[0] ; $xx <=$W[1]; $xx++ ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 024 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                 $cnt++;
                                                                         }
                                              }
                         elsif ( $W[0] > $W[1] ) {
                               my $cnt = 0;
                              for (my $xx = $W[0] ; $xx >=$W[1]; $xx-- ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 025 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                  $cnt++;
                                                                          }
                                                 }
          
                                             }
                    else { print "WARN-PAR-LVS : 026 : the bus width $busWidth of $pin does not match with $len connections\n";
                         #Needs to handle this, connect from LHS bit till minimum of two busWidth and expression length
                         }
                         }#if pin is of type '1' or bus
                                                                      }# if pin is an input
                    elsif (exists $MODULE_ALREADY{$cell}->{outs}{$pin} ) {
                    print "DBG-PAR-LVS : 027 : $pin is an output bus\n" if($DEBUG == 300);
                    my $type = $MODULE_ALREADY{$cell}->dbVNOMGetOutputType($pin);
                    if ( $type == 0 ) {
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pin} = $net;
                               print "DBG-PAR-LVS : 028 : $pin connects $netName on $cell\n" if($DEBUG == 300);
                               
                                      }
                    else {
                    my $width = $MODULE_ALREADY{$cell}->dbVNOMGetOutputBits($pin);
                    $width =~ s/\[//; $width =~ s/\]//;
                    my @W = split(/\s*\:\s*/,$width);
                    print "DBG-PAR-LVS : 029 : MSB is $W[0]\n" if($DEBUG == 300);
                    my $busWidth = abs($W[1] - $W[0])+1;
                    print "DBG-PAR-LVS : 030 : Bus $pin it connects to is of $busWidth width\n" if($DEBUG == 300);
                    if ( $busWidth == $len ) {
                         if ( $W[0] <= $W[1] ) {
                              my $cnt = 0;
                              for (my $xx = $W[0] ; $xx <=$W[1]; $xx++ ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 031 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                 $cnt++;
                                                                         }
                                              }
                         elsif ( $W[0] > $W[1] ) {
                               my $cnt = 0;
                              for (my $xx = $W[0] ; $xx >=$W[1]; $xx-- ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 032 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                  $cnt++;
                                                                          }
                                                 }

                                             }
                    else { print "WARN-PAR-LVS : 033 : the bus width $busWidth of $pin does not match with $len connections\n";
                         #Needs to handle this, connect from LHS bit till minimum of two busWidth and expression length
                         }
                         }#if pin is of type '1' or bus

                                                                      }# if pin is an output
                    elsif (exists $MODULE_ALREADY{$cell}->{bidis}{$pin} ) {
                    print "DBG-PAR-LVS : 027 : $pin is an bidi bus\n" if($DEBUG == 300);
                    my $type = $MODULE_ALREADY{$cell}->dbVNOMGetBidiType($pin);
                    if ( $type == 0 ) {
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pin} = $net;
                               print "DBG-PAR-LVS : 028 : $pin connects $netName on $cell\n" if($DEBUG == 300);
                               
                                      }
                    else {
                    my $width = $MODULE_ALREADY{$cell}->dbVNOMGetBidiBits($pin);
                    $width =~ s/\[//; $width =~ s/\]//;
                    my @W = split(/\s*\:\s*/,$width);
                    print "DBG-PAR-LVS : 029 : MSB is $W[0]\n" if($DEBUG == 300);
                    my $busWidth = abs($W[1] - $W[0])+1;
                    print "DBG-PAR-LVS : 030 : Bus $pin it connects to is of $busWidth width\n" if($DEBUG == 300);
                    if ( $busWidth == $len ) {
                         if ( $W[0] <= $W[1] ) {
                              my $cnt = 0;
                              for (my $xx = $W[0] ; $xx <=$W[1]; $xx++ ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 031 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                 $cnt++;
                                                                         }
                                              }
                         elsif ( $W[0] > $W[1] ) {
                               my $cnt = 0;
                              for (my $xx = $W[0] ; $xx >=$W[1]; $xx-- ) {
                               my $pinName = $pin."[".$xx."]";
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $allnets[$cnt];
                               print "DBG-PAR-LVS : 032 : $pinName connects $allnets[$cnt]\n" if($DEBUG == 300);
                                  $cnt++;
                                                                          }
                                                 }

                                             }
                    else { print "WARN-PAR-LVS : 033 : the bus width $busWidth of $pin does not match with $len connections\n";
                         #Needs to handle this, connect from LHS bit till minimum of two busWidth and expression length
                         }
                         }#if pin is of type '1' or bus

                                                                      }# if pin is an bidi
                                                   }
                #{} to match the pattern closing for debugging purposes
#---------------------------------------- if no connection to the hier module ports -----------------#
                               elsif ( $net eq "" || $net eq "+" ) { next ; } 
#---------------------------------------- if simple connection to the hier module ports -----------------#
                               else {
                                    if ( $net =~ /\s+/ ) {
                                                         print "DBG-PAR-LVS : 034 : substituting space in netname $net\n" if($DEBUG == 300);
                                                         $net =~ s/\s+//;
                                                         }
                                    if ( $pinType == 1 ) {
#---------------------------------------- if bus is implictly connected to the hier module ports -----------------#
                               print "INFO-PAR-LVS : 035 : implicit connection between $pin and $net\n" if($DEBUG == 300);
                    my $width = 0;
                    if ($pinDir == 1){$width = $MODULE_ALREADY{$cell}->dbVNOMGetInputBits($pin);}
                    elsif ($pinDir == 2){$width = $MODULE_ALREADY{$cell}->dbVNOMGetOutputBits($pin);}
                    elsif ($pinDir == 3){$width = $MODULE_ALREADY{$cell}->dbVNOMGetBidiBits($pin);}
                    $width =~ s/\[//; $width =~ s/\]//;
                    my @W = split(/\s*\:\s*/,$width);
                    print "DBG-PAR-LVS : 036 : MSB is $W[0]\n" if($DEBUG == 300);
                    my $busWidth = abs($W[1] - $W[0])+1;
                    print "DBG-PAR-LVS : 037 : Bus $pin it connects to is of $busWidth width\n" if($DEBUG == 300);
                      if ( $net =~ /\[\s*[0-9]+\s*\:\s*[0-9]+\s*\]/ ) {# partial bus connection
                           $net =~ s/\[/ /; $net =~ s/\]//; $net =~ s/\:/ /;
                          my ($name,$from,$to) = (split(/\s+/,$net))[0,1,2];
                           my @allnets = (); 
                           print "\nINFO-PAR-LVS : 038 : In part select net is  $name and from is $from and to $to\n" ;
                           if ( $from <= $to ) {
                           for ( my $xx = $from ; $xx <= $to ; $xx++ ){
                                 my $newNetName = $name."[".$xx."]";
                                 push(@allnets,$newNetName);
                                                                      }#for
                                              }#if ( $from < $to )
                           else {
                           for ( my $xx = $from ; $xx >= $to ; $xx-- ){
                                 my $newNetName = $name."[".$xx."]";
                                 push(@allnets,$newNetName);
                                                                      }#for
                                              }#if ( $from > $to )
                           if ( $W[0] <= $W[1] ) {
                              my $cnt = 0;
                              for (my $xx = $W[0] ; $xx <=$W[1]; $xx++ ) {
                               my $pinName = $pin."[".$xx."]";
                               $netName = $allnets[$cnt];
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $netName;
                               print "DBG-PAR-LVS : 039 : $pinName on $cell connected to $netName $current_module_name\n" if($DEBUG == 300);
                                 $cnt++;
                                                                         }
                                              }
                         elsif ( $W[0] > $W[1] ) {
                               my $cnt = 0;
                              for (my $xx = $W[0] ; $xx >=$W[1]; $xx-- ) {
                               my $pinName = $pin."[".$xx."]";
                               my $netName = $allnets[$cnt];
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $netName;
                               print "DBG-PAR-LVS : 040 : $pinName on $cell connected to $netName $current_module_name\n" if($DEBUG == 300);
                                  $cnt++;
                                                                          }
                                                 }
                                                          }# partial bus connection
                      else { # full bus to bus connection
                         if ( $W[0] <= $W[1] ) {
                               if($W[0] == $W[1]) {
                                 my $xx = $W[0] ;
                                 my $pinName = $pin."[".$xx."]";
                                 my $netName = $net."[".$xx."]";
                                 if (($MODULE_ALREADY{$current_module_name}->dbVNOMHasInput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     my $temp_index = $B[0] ;
                                     $netName = $net."[".$temp_index."]";
                                   }else{
                                     $netName = $net;
                                   }
                                 }elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasOutput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     my $temp_index = $B[0] ;
                                     $netName = $net."[".$temp_index."]";
                                   }else{
                                     $netName = $net;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasBidi($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     my $temp_index = $B[0] ;
                                     $netName = $net."[".$temp_index."]";
                                   }else{
                                     $netName = $net;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasNet($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     my $temp_index = $B[0] ;
                                     $netName = $net."[".$temp_index."]";
                                   }else{
                                     $netName = $net;
                                   }
                                 }else {
                                   $netName = $net;
                                 }
                                 $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $netName;
                               }else {
                                 my $start_index = -100000;
                                 my $end_index = -100000;
                                 if (($MODULE_ALREADY{$current_module_name}->dbVNOMHasInput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasOutput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasBidi($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasNet($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 }
                              my $net_step = -100000 ;
                              if($start_index != -100000) {
                                $net_step = 1 ;
                                if($start_index > $end_index) {
                                  $net_step = -1 ;
                                }elsif($start_index == $end_index) {
                                  $net_step = 0 ;
                                }
                              }
                              my $cnt = 0;
                              for (my $xx = $W[0] ; $xx <=$W[1]; $xx++ ) {
                               my $pinName = $pin."[".$xx."]";
                               my $netName = $net."[".$xx."]";
                               if($net_step != -100000){
                                 my $net_index = $start_index + $cnt * $net_step ;
                                 $netName = $net."[".$net_index."]";
                               }else {
                                 $netName = $net;
                               }
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $netName;
                               print "DBG-PAR-LVS : 041 : $pinName on $cell connected to $netName $current_module_name\n" if($DEBUG == 300);
                                 $cnt++;
                                                                         }
                               }
                                              }
                         elsif ( $W[0] > $W[1] ) {
                                 my $start_index = -100000;
                                 my $end_index = -100000;
                                 if (($MODULE_ALREADY{$current_module_name}->dbVNOMHasInput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetInputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasOutput($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetOutputBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasBidi($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetBidiBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 } elsif (($MODULE_ALREADY{$current_module_name}->dbVNOMHasNet($net)) ==1) {
                                   my $type = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetType($net);
                                   if($type == 1) {
                                     my $busWidth = $MODULE_ALREADY{$current_module_name}->dbVNOMGetNetBits($net);
                                     $busWidth =~ s/\[\s*//;
                                     $busWidth =~ s/\s*\]//;
                                     my @B = split(/\s*\:\s*/, $busWidth );
                                     $start_index = $B[0] ;
                                     $end_index = $B[1] ;
                                   }
                                 }
                              my $net_step = -100000 ;
                              if($start_index != -100000) {
                                $net_step = 1 ;
                                if($start_index > $end_index) {
                                  $net_step = -1 ;
                                }elsif($start_index == $end_index) {
                                  $net_step = 0 ;
                                }
                              }
                               my $cnt = 0;
                              for (my $xx = $W[0] ; $xx >=$W[1]; $xx-- ) {
                               my $pinName = $pin."[".$xx."]";
                               my $netName = $net."[".$xx."]";
                               if($net_step != -100000){
                                 my $net_index = $start_index + $cnt * $net_step ;
                                 $netName = $net."[".$net_index."]";
                               }else{
                                 $netName = $net;
                               }
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pinName} = $netName;
                               print "DBG-PAR-LVS : 042 : $pinName on $cell connected to $netName $current_module_name\n" if($DEBUG == 300);
                                  $cnt++;
                                                                          }
                                                 }
                             }# full bus to bus connection
                                                         }# if implicit connection to a bus
                                    else {
                               $TEMP_HIER_PORT_NET_MAP_LVS{$inst_hash_key}{$pin} = $net;
                               print "DBG-PAR-LVS : 043 : $pin in $cell connects to $netName from $current_module_name\n" if($DEBUG == 300);
                                         }# if implicit connection to a single pin
                                     }
                                                                     }#for
   my $class = $MODULE_ALREADY{$cell}->dbVNOMGetClass;
   print "DBG-PAR-LVS : 044 : checking if $cell is a blackbox hierarchical instance, it is class : $class\n" if ( $DEBUG == 300 );
   &populate_hier_inst_port_net_map($cell,$instance_path_name);
   last;
        }
                               }
                                  }#foreach connection line
}#sub populate_hier_inst_port_net_map

sub set_top_module
{
  if ( $_[0] eq '-h' || $_[0] eq '-help') {
    print "Usage : set_top_module <top module name>\n";
    return;
  }
  my $module_name = $_[0];
  if(!defined($module_name)) {
    print "Error: Module not defined\n";
    return ;
  }
  if(!exists $MODULE_ALREADY{$module_name}) {
    print "Error: Module $module_name not found\n";
    return ;
  }
  $GLOBAL->dbfGlobalSetTOP($module_name);
  $TOP_MODULE = $module_name;
}
#-------------------------------------------------------------------------------------------------------------------#
sub set_write_assign_as_buffer {
  $GLOBAL->dbfGlobalSetWriteAssignAsBuffer(1);
}#sub set_write_assign_as_buffer
#-------------------------------------------------------------------------------------------------------------------#
sub set_write_assign_as_assign {
  $GLOBAL->dbfGlobalSetWriteAssignAsBuffer(0);
}#sub set_write_assign_as_assign
#-------------------------------------------------------------------------------------------------------------------#
sub get_coord_with_bracket {
my $data = $_[0];
my $new_data = ""; 
my $dbu = $GLOBAL->dbfGlobalGetDBU;
if($data =~ /\(/){
$new_data = $data;
}else {
    my ($layer,$x1,$y1,$x2,$y2) = (split(/\s+/,$data))[0,1,2,3,4];
    my $x_1 = $x1*$dbu;
    my $y_1 = $y1*$dbu;
    my $x_2 = $x2*$dbu;
    my $y_2 = $y2*$dbu;
    #$new_data = "$layer ( $x_1 $y_1 ) ( $x_2 $y_2 )";
    if($x_1 eq $x_2) { $new_data = "$layer ( $x_1 $y_1 ) ( * $y_2 )";}
    if($y_1 eq $y_2) { $new_data = "$layer ( $x_1 $y_1 ) ( $x_2 * )";}
}
return($new_data);
}#sub get_coord_with_bracket
#-------------------------------------------------------------------------------------------------------------------#
#################################################################################################
######################## setting input/output ports using VNOM only #############################
#################################################################################################
sub get_input_output_port_frm_spice_vnom_old {
  my $noOfArguments = @_;
  if($noOfArguments < 0 || $_[0] eq "-h"){
    print "Usage : get_input_output_port_frm_spice_vnom\n";
    return;
  }
  my $start_module = $TOP_MODULE;
  my $no_of_level = -1;
  %TEMP_MODULE_ALREADY = ();
  &populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($start_module,$no_of_level);
  my @temp_module_list = sort { $TEMP_MODULE_ALREADY{$a} <=> $TEMP_MODULE_ALREADY{$b} } keys %TEMP_MODULE_ALREADY;
  foreach my $moduleName (@temp_module_list){
  #foreach my $moduleName (keys %MODULE_ALREADY){
      my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
      foreach my $connLine (@conns){
         $connLine =~ s/\(/\)\,/;
         $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
         my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
         my @nets = split(/\s*\)\s*\,\s*/, $connLine);
         my $noOfPins = @nets;
         for(my $i = 1 ; $i < $noOfPins ; $i++){
           $nets[$i] =~ s/\s*\(\s*/\|/;
           $nets[$i] =~ s/\s*\)\s*//;
           my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
           $pin =~ s/\.//;
           my $get_port_status = &get_pin_status_old($cell,$pin);
           if(($get_port_status =~ /^\d+_tmpslvr_gate/)||($get_port_status =~ /^\d+_tmpslvr_input/)){
             if($MODULE_ALREADY{$moduleName}->dbVNOMHasBidi($net)){
               my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($net);
               my $busWidth;
               if($type == 1){
                 $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($net);
               }
               $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
               $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
               $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
               $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
             }
           }elsif(($get_port_status =~ /^\d+_tmpslvr_drain/) || ($get_port_status =~ /^\d+_tmpslvr_source/)||($get_port_status =~ /^\d+_tmpslvr_output/)){
             if($MODULE_ALREADY{$moduleName}->dbVNOMHasBidi($net)){
               my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($net);
               my $busWidth;
               if($type == 1){
                 $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($net);
               }
               $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
               $MODULE_ALREADY{$moduleName}->dbVNOMAddOutput($net); 
               $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputType($net,$type);
               $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputBits($net,$busWidth);
             }
           } 
         }#for
      }#foreach
  }#foreach
}#sub get_input_output_port_frm_spice_vnom_old
#-----------------------------------------------------------------------------------------------------------#
sub get_pin_status_old {
my $cellref = $_[0];
my $port = $_[1];
my $class = $MODULE_ALREADY{$cellref}->dbVNOMGetClass;
if($class == 11){
  return $port;
}else{
  if($MODULE_ALREADY{$cellref}->dbVNOMHasBidi($port)){ 
    my @conns = $MODULE_ALREADY{$cellref}->dbVNOMGetConn;
    foreach my $connLine (@conns){
      $connLine =~ s/\(/\)\,/;
      $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
      my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
      my @nets = split(/\s*\)\s*\,\s*/, $connLine);
      my $noOfPins = @nets;
      for(my $i = 1 ; $i < $noOfPins ; $i++){
        $nets[$i] =~ s/\s*\(\s*/\|/;
        $nets[$i] =~ s/\s*\)\s*//;
        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
        $pin =~ s/\.//;
        if($net !~ /^\d+_tmpslvr_param_/){ 
          if($net eq $port){
            return get_pin_status_old($cell, $pin);
          } 
        } 
      }#for
    }#foreach
 }#if
}
}#sub get_pin_status_old

#################################################################################################
######################## setting input/output ports using VNOM & PLDB ###########################
#################################################################################################
#sub add_spice_input_output_in_VNOM {
#  my $noOfArguments = @_;
#  if($noOfArguments < 0 || $_[0] eq "-h"){
#    print "Usage : get_input_output_port_frm_spice_vnom\n";
#    return;
#  }
#  my $start_module = $TOP_MODULE;
#  my $no_of_level = -1;
#  my %TEMP_PIN_NET_HASH = ();
#  %TEMP_MODULE_ALREADY = ();
#  &populate_list_of_modules_in_hierachy_stop_at_given_level_from_start_module($start_module,$no_of_level);
#  my @temp_module_list = sort { $TEMP_MODULE_ALREADY{$a} <=> $TEMP_MODULE_ALREADY{$b} } keys %TEMP_MODULE_ALREADY;
#  foreach my $moduleName (@temp_module_list){
#    my @conns = $MODULE_ALREADY{$moduleName}->dbVNOMGetConn;
#    foreach my $connLine (@conns){
#      $connLine =~ s/\(/\)\,/;
#      $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
#      my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
#      my @nets = split(/\s*\)\s*\,\s*/, $connLine);
#      my $noOfPins = @nets;
#      for(my $i = 1 ; $i < $noOfPins ; $i++){
#        $nets[$i] =~ s/\s*\(\s*/\|/;
#        $nets[$i] =~ s/\s*\)\s*//;
#        my ($pin,$net)=(split(/\s*\|\s*/, $nets[$i]))[0,1];
#        $pin =~ s/\.//;
#        if(($MODULE_ALREADY{$moduleName}->dbVNOMHasBidi($net)) && ($net !~ /^\d+_tmpslvr_param_/)){
#          my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiType($net);
#          my $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetBidiBits($net);
#          my $dir = &get_spice_pin_direction($cell,$pin);
#          if($dir ne "" ){
#            if($dir == 0){
#              $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
#              $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
#              $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
#              $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
#            }elsif($dir == 1){
#              $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
#              if(($net =~ (/^\d+_tmpslvr_vss/i)) || ($net =~ (/^\d+_tmpslvr_vdd/i))){
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
#              }else {
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddOutput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputBits($net,$busWidth);
#              }
#            }
#          }else {
#            push(@{$TEMP_PIN_NET_HASH{$cell}},"$pin $net"); 
#          }
#        }elsif(($MODULE_ALREADY{$moduleName}->dbVNOMHasInput($net)) && ($net !~ /^\d+_tmpslvr_param_/)){
#          my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputType($net);
#          my $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetInputBits($net);
#          my $dir = &get_spice_pin_direction($cell,$pin);
#          if($dir ne ""){
#            if($dir == 1){
#              $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
#              if(($net =~ (/^\d+_tmpslvr_vss/i)) || ($net =~ (/^\d+_tmpslvr_vdd/i))){
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
#              }else {
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddOutput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetOutputBits($net,$busWidth);
#              }
#            }
#          }
#        }elsif(($MODULE_ALREADY{$moduleName}->dbVNOMHasOutput($net)) && ($net !~ /^\d+_tmpslvr_param_/)){
#          my $type = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputType($net);
#          my $busWidth = $MODULE_ALREADY{$moduleName}->dbVNOMGetOutputBits($net);
#          my $dir = &get_spice_pin_direction($cell,$pin);
#          if($dir ne ""){
#            if($dir == 0){
#              $MODULE_ALREADY{$moduleName}->dbVNOMRemovePin($net);
#              if(($net =~ (/^\d+_tmpslvr_vss/i)) || ($net =~ (/^\d+_tmpslvr_vdd/i))){
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
#              }else {
#                $MODULE_ALREADY{$moduleName}->dbVNOMAddInput($net); 
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputType($net,$type);
#                $MODULE_ALREADY{$moduleName}->dbVNOMSetInputBits($net,$busWidth);
#              }
#            }
#          }
#        }
#      }#for
#    }#foreach
#    if(%TEMP_PIN_NET_HASH){
#      foreach my $cellref (keys %TEMP_PIN_NET_HASH){
#        my @pin_net = @{$TEMP_PIN_NET_HASH{$cellref}};
#        foreach my $pin_net_str (@pin_net){
#          my($pin,$net) = (split(/\s+/,$pin_net_str))[0,1];
#          if($MODULE_ALREADY{$cellref}->dbVNOMHasInput($pin)){
#            my $type = $MODULE_ALREADY{$cellref}->dbVNOMGetInputType($pin);
#            my $busWidth = $MODULE_ALREADY{$cellref}->dbVNOMGetInputBits($pin);
#            $MODULE_ALREADY{$TOP_MODULE}->dbVNOMRemovePin($net);
#            $MODULE_ALREADY{$TOP_MODULE}->dbVNOMAddInput($net); 
#            $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetInputType($net,$type);
#            $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetInputBits($net,$busWidth);
#          }elsif($MODULE_ALREADY{$cellref}->dbVNOMHasOutput($pin)){
#            my $type = $MODULE_ALREADY{$cellref}->dbVNOMGetOutputType($pin);
#            my $busWidth = $MODULE_ALREADY{$cellref}->dbVNOMGetOutputBits($pin);
#            $MODULE_ALREADY{$TOP_MODULE}->dbVNOMRemovePin($net);
#            if(($net =~ (/^\d+_tmpslvr_vss/i)) || ($net =~ (/^\d+_tmpslvr_vdd/i))){
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMAddInput($net); 
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetInputType($net,$type);
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetInputBits($net,$busWidth);
#            }else {
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMAddOutput($net); 
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetOutputType($net,$type);
#              $MODULE_ALREADY{$TOP_MODULE}->dbVNOMSetOutputBits($net,$busWidth);
#            }
#          }
#        }
#      }
#    }
#  }#foreach
#}#sub add_spice_input_output_in_VNOM
##-----------------------------------------------------------------------------------------------------------#
#sub get_spice_pin_direction {
#  my $cellref = $_[0];
#  my $port = $_[1];
#  if(exists $PLDB{$cellref}){
#    my $dir = $PLDB{$cellref}->dbMdbGetPinDir($port);
#    return $dir;
#  }else{
#    my @conns = $MODULE_ALREADY{$cellref}->dbVNOMGetConn;
#    foreach my $connLine (@conns){
#      $connLine =~ s/\(/\)\,/;
#      $connLine =~ s/\s*\)\s*\)\s*\;?.*$/\)/;
#      my ($cell,$inst) = ( split(/\s+/, $connLine ))[0,1];
#      my @nets = split(/\s*\)\s*\,\s*/, $connLine);
#      my $noOfPins = @nets;
#      for(my $i = 1 ; $i < $noOfPins ; $i++){
#        $nets[$i] =~ s/\s*\(\s*/\|/;
#        $nets[$i] =~ s/\s*\)\s*//;
#        my ($pin,$net)=(split(/\s*\|\s*/,$nets[$i]))[0,1];
#        $pin =~ s/\.//;
#        if($net !~ /^\d+_tmpslvr_param_/){ 
#          if($net eq $port){
#            get_spice_pin_direction($cell,$pin);
#          } 
#        } 
#      }#for
#    }#foreach
#  }
#}#sub get_spice_pin_direction
#-------------------------------------------------------------------------------------------------------------------#
sub create_black_box_frm_pldb {
  foreach my $cellref (keys %PLDB){
    $MODULE_ALREADY{$cellref}= VNOM::new();
    $MODULE_ALREADY{$cellref}->dbVNOMSetClass(11);
  }#foreach
}#sub create_black_box_frm_pldb
#-------------------------------------------------------------------------------------------------------------------#
sub set_first_non_empty_top_module
{
  if ( $_[0] eq '-h' || $_[0] eq '-help') {
    print "Usage : set_first_non_empty_top_module\n";
    return;
  }
  foreach my $mod (keys %MODULE_ALREADY) {
    my @parents =  $MODULE_ALREADY{$mod}->dbVNOMGetParent;
    my $np = @parents;
    if ($np == 0) {
      my @cell_conns = $MODULE_ALREADY{$mod}->dbVNOMGetConn();
      if($#cell_conns >= 0){
        $GLOBAL->dbfGlobalSetTOP($mod);
        $TOP_MODULE = $mod;
      }
    }
  }
}#sub set_first_non_empty_top_module
#-------------------------------------------------------------------------------------------------------------------#
sub check_routing_coord {
use Benchmark;
my $t0 = new Benchmark;

my %EACH_ROUTE_COORD = ();
my %PIN_DATA = ();
my $routed_net = 0;
my $total_net = 0;
foreach my $net (keys %NETS_ALREADY){
  if(exists $NETS_ROUTING_ALREADY{$net}){
    my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
    my $cnt_routes = @routes;
    if($cnt_routes != 0){$routed_net++;}
      foreach my $instance ( keys %{$NETS_ALREADY{$net}}){
        if(exists $COMP_ALREADY{$instance}){
          my $cellref = $CADB{$instance}->dbCadbGetCellref;
          my @instLoc = $CADB{$instance}->dbCadbGetLoc;
          my $orient = $CADB{$instance}->dbCadbGetOrient;
          if (exists $PLDB{$cellref}){
            my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
            my @cellSize = $PLDB{$cellref}->dbMdbGetSize;
            my @pins = $PLDB{$cellref}->dbMdbGetPins;
            foreach my $p (@pins) {
              my $conn_net = $COMP_ALREADY{$instance}{$p};
              if($conn_net eq $net){ 
                my @pinRects = $PLDB{$cellref}->dbMdbGetPinRect($p);
                foreach my $pin_rect(@pinRects){
                  my $pinDire = $PLDB{$cellref}->dbMdbGetPinDir($p);
                  my ($layer, $llx2, $lly2, $urx2, $ury2)=(split(/\s+/,$pin_rect))[0,2,3,4,5];
                  my @pinCoords = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0],$cellOrigin[1],$orient,$cellSize[0],$cellSize[1],$llx2,$lly2,$urx2,$ury2); 
                  foreach my $rl (@routes){
                    my @routeBox = &xformNetSegToRouteBox($rl);
                    #print "$instance => $p => @pinCoords\n";
                    my $pinRouteOverlap = &dbAnlsDrouteShapeOverlap(@routeBox,@pinCoords);
                    my $routeBox_str = join " ",@routeBox;
                    #if($pinRouteOverlap == 0){
                      push(@{$EACH_ROUTE_COORD{$net}{$routeBox_str}},$instance,$p,$pinRouteOverlap); 
                      push(@{$PIN_DATA{$net}{$instance}{$p}},$pinRouteOverlap);
                    #}else {
                    #}
                  }
                }
              }
            }
          }
        }
      }
    }
  $total_net++;
}#foreach
my $t1 = new Benchmark;
my $td = timediff($t1,$t0);
print "check_routing_coord :",timestr($td),"\n";
my $no_routed_net = $total_net - $routed_net;
open (WRITE,">report.txt");
print WRITE "routed_net = $routed_net\n";
print WRITE "not routed_net = $no_routed_net\n";
print WRITE "total_net = $total_net\n";

foreach my $net (keys %EACH_ROUTE_COORD){
  #print "$net\n";
  my %get_pin_hash = ();
  foreach my $route (keys %{$EACH_ROUTE_COORD{$net}}){
    my @value =  @{$EACH_ROUTE_COORD{$net}{$route}};
    #print "$route = @value\n";  
    for(my $i=0;$i<=$#value;$i=$i+3){
      my $instance = $value[$i];
      my $pin = $value[$i+1];
      if(exists $PIN_DATA{$net}{$instance}{$pin}){
        my $pin_value = join"",@{$PIN_DATA{$net}{$instance}{$pin}};
        #print "$pin => $pin_value\n"; 
        if($pin_value =~ /1/){
        }else {
          #print "$pin => $pin_value\n"; 
          if(!exists $get_pin_hash{$net}{$instance}{$pin}){
            push(@{$get_pin_hash{$net}{$instance}{$pin}},$instance." ".$pin);
          }
        }
      } 
    }#for
  }#foreach
  foreach my $inst (keys %{$get_pin_hash{$net}}){
    foreach my $pin (keys %{$get_pin_hash{$net}{$inst}}){
      print WRITE " $net => @{$get_pin_hash{$net}{$inst}{$pin}}";
    }
    print WRITE "\n";
  }
}
close(WRITE);
my $t1 = new Benchmark;
my $td = timediff($t1,$t0);
print "check_routing_coord :",timestr($td),"\n";

}#sub check_routing_coord
#-------------------------------------------------------------------------------------------------------------------#

1;
