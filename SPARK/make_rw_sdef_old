
sub write_sdef {
use Benchmark;
my $t0 = new Benchmark;
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){ print "Usage : write_sdef\n";
                                         print "      : --comp\n";
                                         print "      : --net\n";
                                         print "      : --via\n";
                        
}
else {
my $write_comp = 0;
my $write_net = 0;
my $write_via = 0;
for(my $i=0;$i<$noOfArguments;$i++){
  if($_[$i] =~ /--net/){$write_net = 1;}
  if($_[$i] =~ /--via/){$write_via = 1;}
}#for
print "Writing sdef for $TOP_MODULE\n";
open(WRITE,">${TOP_MODULE}.sdef");

# ---- setting the instance box for all instances ----#
if(($write_net == 0) && ($write_via == 0)){
&set_inst_box("--all") ; 
  foreach $instance ( keys %COMP_ALREADY ) {
    if( exists $CADB{$instance} ){
      my $cellref =  $CADB{$instance}->dbCadbGetCellref;
      print WRITE "INST $instance $cellref ";
      if( exists $CADB{$instance} ){
        my @loc = $CADB{$instance}->dbCadbGetLoc;
        my $status = $CADB{$instance}->dbCadbGetStatus;
        my $orient = $CADB{$instance}->dbCadbGetOrient;
        my @box = $CADB{$instance}->dbCadbGetbBox;
        if ( $status eq "PLACED" || $status eq "FIXED" ) {
          print WRITE "@box $status "; 
        }
      }
      print WRITE " \;\n";
    }
  }#foreach component db
}
if($write_net == 1){
  foreach my $net (keys %NETS_ALREADY){
    my $netType = 0;
    if ( exists $NADB{$net} ) {$netType = $NADB{$net}->dbNadbGetNetType;}
    if ( $netType == 0 ) { 
      if(exists $NETS_ROUTING_ALREADY{$net}){
        my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
        if ( @fixed_routes > 0 ) {
          print WRITE "NETS ROUTED $net\n"; 
          foreach my $l ( @fixed_routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            print WRITE "    $layer "; 
            my @fixed_routeBox = &xformNetSegToPathSeg($l);
            print WRITE "@fixed_routeBox\n";
          }
        }# if routing information exists
        if ( @routes > 0 ) {
          print WRITE "NETS ROUTED $net\n"; 
          foreach my $l ( @routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            print WRITE "    $layer "; 
            my @routeBox = &xformNetSegToPathSeg($l);
            print WRITE "@routeBox\n";
          }
        }# if routing information exists
        if(($#routes < 0) && ($#fixed_routes < 0)){
           my @bbox = &return_bbox_for_unrouted_given_net($net);
           if ($#bbox > 0){
             print WRITE "NETS UNROUTED $net\n";
             print WRITE "    @bbox\n"; 
           }
        }
      }#if 
    }#if 
  }#foreach net
}
if($write_via == 1){
  foreach my $net (keys %NETS_ALREADY){
    my $netType = 0;
    if ( exists $NADB{$net} ) {$netType = $NADB{$net}->dbNadbGetNetType;}
    if ( $netType == 0 ) { 
      if(exists $NETS_ROUTING_ALREADY{$net}){
        my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
        if ( @routes > 0 ) {
          print WRITE "VIAS $net\n";
          foreach my $l ( @routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            if($via =~ /\)/){next;}
            print WRITE "    $via\n";
          }
        }
        if ( @fixed_routes > 0 ) {
          print WRITE "VIAS $net\n";
          foreach my $l ( @fixed_routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            if($via =~ /\)/){next;}
            print WRITE "    $via\n";
          }
        }
      }#if exists routing already
    }#if netType
  }#foreach net
}
close(WRITE);
}#else 
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_sdef took:",timestr($td),"\n";
}#write_sdef 
#------------------------------------------------------------------------------------#
sub return_bbox_for_unrouted_given_net {
my $nets = $_[0];
if(exists $NETS_ALREADY{$nets}){
  my @new_inst_data = ();
  my @nodex = ();
  my @nodey = ();
  my @pinlayer_list = ();
  my @driverInst = &getNetDriver($nets);
  my @sinkInst = &getNetSink($nets);
  if($#driverInst >= 1 && $#sinkInst >= 1){
      push(@new_inst_data,@driverInst,@sinkInst);
  }
  for (my $i=0;$i<=$#new_inst_data;$i= $i+2){
    my $inst_tmp = $new_inst_data[$i];
    my $pinName = $new_inst_data[$i+1];
    if($inst_tmp eq "\*"){
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp} ) {
      my $status = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetStatus;
      if($status >1){
        my @portLoc = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetLoc;
        push(@nodex,$portLoc[0]);
        push(@nodey,$portLoc[1]);
      }#if status 
    }elsif(exists $COMP_ALREADY{$inst_tmp}){
      my $status = $CADB{$inst_tmp}->dbCadbGetStatus;
      if ( $status eq "PLACED" || $status eq "FIXED" ) {
        my $cellref = $CADB{$inst_tmp}->dbCadbGetCellref;
        my @instLoc = $CADB{$inst_tmp}->dbCadbGetLoc;
        my $instOrient = $CADB{$inst_tmp}->dbCadbGetOrient;
        if (exists $PLDB{$cellref}){
          my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
          my @cellsize = $PLDB{$cellref}->dbMdbGetSize;
          my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
          my ($pinlayer,$pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[0,2,3,4,5];
          my @absolute_pin_rect = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],$pinllx,$pinlly,$pinurx,$pinury);
          my $xmiddle_pin_rect = ($absolute_pin_rect[0]+$absolute_pin_rect[2])/2;
          my $ymiddle_pin_rect = ($absolute_pin_rect[1]+$absolute_pin_rect[3])/2; 
          push(@nodex,$xmiddle_pin_rect);
          push(@nodey,$ymiddle_pin_rect); 
          push(@pinlayer_list,$pinlayer);
        }# if exists cellref
      }
    }else {
      print "001 : $inst_tmp not exists in PORTS_ALREADY and COMP_ALREADY\n";
    }
  }
  if($#nodex >= 0){
    @nodex = sort{$a<=>$b}@nodex;
    @nodey = sort{$a<=>$b}@nodey;
    my $xmin = int($nodex[0]);
    my $ymin = int($nodey[0]);
    my $xmax = int($nodex[-1]);
    my $ymax = int($nodey[-1]);
    my $pinlayer = shift (@pinlayer_list);
    my @bbox = ($pinlayer,$xmin,$ymin,$xmax,$ymax);
    return (@bbox);
  }
}
}#sub return_bbox_for_unrouted_given_net

1;

