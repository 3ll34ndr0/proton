
sub write_sdef {
use Benchmark;
my $t0 = new Benchmark;
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){ print "Usage : write_sdef\n";
                                         print "      : --comp\n";
                                         print "      : --net\n";
                                         print "      : --via\n";
                        
}
else {
my $write_comp = 0;
my $write_net = 0;
my $write_via = 0;
for(my $i=0;$i<$noOfArguments;$i++){
  if($_[$i] =~ /--net/){$write_net = 1;}
  if($_[$i] =~ /--via/){$write_via = 1;}
}#for
print "Writing sdef for $TOP_MODULE\n";
open(WRITE,">${TOP_MODULE}.sdef");

# ---- setting the instance box for all instances ----#
if(($write_net == 0) && ($write_via == 0)){
&set_inst_box("--all") ; 
  my $dbu = $GLOBAL->dbfGlobalGetDBU;
  print WRITE "DBU $dbu \n";
  if(exists $DIE_ALREADY{dieArea} ) {
     my @die_coords = @{$DIE_ALREADY{dieArea}};
     print WRITE "DIEAREA @die_coords \n";
  }
  foreach $instance ( keys %COMP_ALREADY ) {
    if( exists $CADB{$instance} ){
      my $cellref =  $CADB{$instance}->dbCadbGetCellref;
      print WRITE "INST $instance $cellref ";
      if( exists $CADB{$instance} ){
        my @loc = $CADB{$instance}->dbCadbGetLoc;
        my $status = $CADB{$instance}->dbCadbGetStatus;
        my $orient = $CADB{$instance}->dbCadbGetOrient;
        my @box = $CADB{$instance}->dbCadbGetbBox;
        if ( $status eq "PLACED" || $status eq "FIXED" ) {
          print WRITE "@box $status "; 
        }
      }
      print WRITE "\n";
    }
  }#foreach component db
}
if($write_net == 1){
  foreach my $net (keys %NETS_ALREADY){
    my $netType = 0;
    if ( exists $NADB{$net} ) {$netType = $NADB{$net}->dbNadbGetNetType;}
    if ( $netType == 0 ) { 
      if(exists $NETS_ROUTING_ALREADY{$net}){
        my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
        if ( @fixed_routes > 0 ) {
          #print WRITE "-NETS ROUTED $net\n"; 
          foreach my $l ( @fixed_routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            my @fixed_routeBox = &xformNetSegToPathSeg($l);
            if($#fixed_routeBox > 0){
              print WRITE "NETS ROUTED $net $layer "; 
              print WRITE "@fixed_routeBox\n";
            }else {
              print WRITE "NETS ROUTED $net NA\n"; 
            }
          }
        }# if routing information exists
        if ( @routes > 0 ) {
          #print WRITE "-NETS ROUTED $net\n"; 
          foreach my $l ( @routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            my @routeBox = &xformNetSegToPathSeg($l);
            if($#routeBox > 0){
              print WRITE "NETS ROUTED $net $layer "; 
              print WRITE "@routeBox\n";
            }else {
              print WRITE "NETS ROUTED $net NA\n"; 
            }
          }
        }# if routing information exists
        if(($#routes < 0) && ($#fixed_routes < 0)){
           my @bbox = &return_bbox_for_unrouted_given_net($net);
           if ($#bbox > 0){
             #print WRITE "-NETS UNROUTED $net\n";
             print WRITE "NETS UNROUTED $net @bbox\n"; 
           }else {
              print WRITE "NETS UNROUTED $net NA\n"; 
           }
        }
      }#if 
    }else {
      if(exists $NETS_ROUTING_ALREADY{$net}){
        my @routes = ();
        push(@routes, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetSpecialRoute); 
        push(@routes, $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute); 
        if ( @routes > 0 ) {
          #print WRITE "-NETS ROUTED $net\n"; 
          foreach my $l ( @routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            my @special_routeBox = &xformNetSegToPathSeg($l);
            if($#special_routeBox > 0){
              print WRITE "NETS ROUTED $net $layer "; 
              print WRITE "@special_routeBox\n";
            }else {
              print WRITE "NETS ROUTED $net NA\n"; 
            }
          }
        }# if routing information exists
      }
    }
  }#foreach net
}
if($write_via == 1){
  foreach my $net (keys %NETS_ALREADY){
    my $netType = 0;
    if ( exists $NADB{$net} ) {$netType = $NADB{$net}->dbNadbGetNetType;}
    if ( $netType == 0 ) { 
      if(exists $NETS_ROUTING_ALREADY{$net}){
        my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
        if ( @routes > 0 ) {
          print WRITE "VIAS $net\n";
          foreach my $l ( @routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            if($via =~ /\)/){next;}
            print WRITE "    $via\n";
          }
        }
        if ( @fixed_routes > 0 ) {
          print WRITE "VIAS $net\n";
          foreach my $l ( @fixed_routes ) {
            my ($layer,$via) = (split(/\s+/,$l))[0,-1];
            if($via =~ /\)/){next;}
            print WRITE "    $via\n";
          }
        }
      }#if exists routing already
    }#if netType
  }#foreach net
}
close(WRITE);
}#else 
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_sdef took:",timestr($td),"\n";
}#write_sdef 
#------------------------------------------------------------------------------------#
sub return_bbox_for_unrouted_given_net {
my $nets = $_[0];
if(exists $NETS_ALREADY{$nets}){
  my @new_inst_data = ();
  my @nodex = ();
  my @nodey = ();
  my @pinlayer_list = ();
  my (@new_inst_data) = &return_inst_list($nets);
  for (my $i=0;$i<=$#new_inst_data;$i= $i+2){
    my $inst_tmp = $new_inst_data[$i];
    my $pinName = $new_inst_data[$i+1];
    if($inst_tmp eq "\*"){
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp} ) {
      my $status = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetStatus;
      if($status >=1){
        my @portLoc = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetLoc;
        push(@nodex,$portLoc[0]);
        push(@nodey,$portLoc[1]);
      }#if status 
    }elsif(exists $COMP_ALREADY{$inst_tmp}){
      my $status = $CADB{$inst_tmp}->dbCadbGetStatus;
      if ( $status eq "PLACED" || $status eq "FIXED" ) {
        my $cellref = $CADB{$inst_tmp}->dbCadbGetCellref;
        my @instLoc = $CADB{$inst_tmp}->dbCadbGetLoc;
        my $instOrient = $CADB{$inst_tmp}->dbCadbGetOrient;
        if (exists $PLDB{$cellref}){
          my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
          my @cellsize = $PLDB{$cellref}->dbMdbGetSize;
          my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
          my @POLY = $PLDB{$cellref}->dbMdbGetPinPolygon($pinName);
          if(@pinRect > 0){
            my ($pinlayer,$pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[0,2,3,4,5];
            if($pinlayer !~ /^v/i){
              my @absolute_pin_rect = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],$pinllx,$pinlly,$pinurx,$pinury);
              my $xmiddle_pin_rect = ($absolute_pin_rect[0]+$absolute_pin_rect[2])/2;
              my $ymiddle_pin_rect = ($absolute_pin_rect[1]+$absolute_pin_rect[3])/2; 
              push(@nodex,$xmiddle_pin_rect);
              push(@nodey,$ymiddle_pin_rect); 
              push(@pinlayer_list,$pinlayer);
            }else {
              my @rect_or_polygon = (split(/\s+/,$POLY[0]));
              my $pinlayer = shift @rect_or_polygon;
              shift @rect_or_polygon;
              my @poly = &xformCellPinPolyToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],@rect_or_polygon);
              my $xmiddle_pin_rect = $poly[0]; 
              my $ymiddle_pin_rect = $poly[1];
              push(@nodex,$xmiddle_pin_rect);
              push(@nodey,$ymiddle_pin_rect); 
              push(@pinlayer_list,$pinlayer);
            }
          }elsif(@POLY > 0) {
            my @rect_or_polygon = (split(/\s+/,$POLY[0]));
            my $pinlayer = shift @rect_or_polygon;
            shift @rect_or_polygon;
            my @poly = &xformCellPinPolyToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],@rect_or_polygon);
            my $xmiddle_pin_rect = $poly[0]; 
            my $ymiddle_pin_rect = $poly[1];
            push(@nodex,$xmiddle_pin_rect);
            push(@nodey,$ymiddle_pin_rect); 
            push(@pinlayer_list,$pinlayer);
          }
        }# if exists cellref
      }
    }else {
      print "001 : $inst_tmp not exists in PORTS_ALREADY and COMP_ALREADY\n";
    }
  }
  if($#nodex >= 1){
    @nodex = sort{$a<=>$b}@nodex;
    @nodey = sort{$a<=>$b}@nodey;
    my $xmin = int($nodex[0]);
    my $ymin = int($nodey[0]);
    my $xmax = int($nodex[-1]);
    my $ymax = int($nodey[-1]);
    my $pinlayer = shift (@pinlayer_list);
    my @bbox = ($pinlayer,$xmin,$ymin,$xmax,$ymax);
    return (@bbox);
  }
}
}#sub return_bbox_for_unrouted_given_net
#----------------------------------------------------------------------------------#
sub return_inst_list {
my $net = $_[0];
my @inst_list = ();
if ( exists $NETS_ALREADY{$net} ) {
  foreach my $instance ( keys %{$NETS_ALREADY{$net}} ) {
    if ( exists $COMP_ALREADY{$instance} ) {
      my $cellref = $CADB{$instance}->dbCadbGetCellref;
      if(exists $PLDB{$cellref}){
        my @pins = $PLDB{$cellref}->dbMdbGetPins;
        foreach my $pinName ( @pins ) {
          my $conn_net = $COMP_ALREADY{$instance}{$pinName};
          if ($conn_net eq $net) {
            push(@inst_list,$instance,$pinName);
          }
        }
      }
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
      foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
   	my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if ($net eq $port_nets[0]){
          push(@inst_list,$port,"PIN");
        }
      }
    }elsif($instance eq "PIN"){
      foreach my $port ( keys %{$PORTS_ALREADY{$TOP_MODULE}} ) {
   	my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if ($net eq $port_nets[0]){
          push(@inst_list,$port,"PIN");
        }
      }
    }
  }
}
return(@inst_list);
}#sub return_inst_list
#------------------------------------------------------------------------------------------------#
sub write_mid_x_and_mid_y_of_inst_pin {
use Benchmark;
my $t0 = new Benchmark;
my $noOfArguments = @_;

if($noOfArguments < 0 || $_[0] eq "-h"){ print "Usage : write_mid_x_and_mid_y_of_inst_pin\n";
                                         print "      : -output<fileName>\n";
}else {
  my $write_output = "";
  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] =~ /-output/){$write_output = $_[$i+1];}
  }#for
  open(WRITE,">$write_output");
  foreach my $nets (keys %NETS_ALREADY){
    my @new_inst_data = ();
    my (@new_inst_data) = &return_inst_list($nets);
    for (my $i=0;$i<=$#new_inst_data;$i= $i+2){
      my $inst_tmp = $new_inst_data[$i];
      my $pinName = $new_inst_data[$i+1];
      if($inst_tmp eq "\*"){
      }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp} ) {
        my @portLoc = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetLoc;
        print WRITE "$inst_tmp $portLoc[0] $portLoc[1]\n";
      }elsif(exists $COMP_ALREADY{$inst_tmp}){
        my $status = $CADB{$inst_tmp}->dbCadbGetStatus;
        if ( $status eq "PLACED" || $status eq "FIXED" ) {
          my $cellref = $CADB{$inst_tmp}->dbCadbGetCellref;
          my @instLoc = $CADB{$inst_tmp}->dbCadbGetLoc;
          my $instOrient = $CADB{$inst_tmp}->dbCadbGetOrient;
          if (exists $PLDB{$cellref}){
            my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
            my @cellsize = $PLDB{$cellref}->dbMdbGetSize;
            my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
            my @POLY = $PLDB{$cellref}->dbMdbGetPinPolygon($pinName);
            if(@pinRect > 0){
              my ($pinlayer,$pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[0,2,3,4,5];
              if($pinlayer !~ /^v/i){
                my @absolute_pin_rect = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],$pinllx,$pinlly,$pinurx,$pinury);
                my $xmiddle_pin_rect = int (($absolute_pin_rect[0]+$absolute_pin_rect[2])/2);
                my $ymiddle_pin_rect = int (($absolute_pin_rect[1]+$absolute_pin_rect[3])/2); 
                print WRITE "$inst_tmp/$pinName $xmiddle_pin_rect $ymiddle_pin_rect\n";
              }else {
                my @rect_or_polygon = (split(/\s+/,$POLY[0]));
                my $pinlayer = shift @rect_or_polygon;
                shift @rect_or_polygon;
                print "@rect_or_polygon\n";
                my @poly = &xformCellPinPolyToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],@rect_or_polygon);
                my $xmiddle_pin_rect = int ($poly[0]); 
                my $ymiddle_pin_rect = int ($poly[1]);
                print WRITE "$inst_tmp/$pinName $xmiddle_pin_rect $ymiddle_pin_rect\n";
              }
            }elsif(@POLY > 0){
              my @rect_or_polygon = (split(/\s+/,$POLY[0]));
              my $pinlayer = shift @rect_or_polygon;
              shift @rect_or_polygon;
              my @poly = &xformCellPinPolyToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],@rect_or_polygon);
              my $xmiddle_pin_rect = int ($poly[0]); 
              my $ymiddle_pin_rect = int ($poly[1]);
              print WRITE "$inst_tmp/$pinName $xmiddle_pin_rect $ymiddle_pin_rect\n";
            }
          }# if exists cellref
        }else {
          print WRITE "$inst_tmp/$pinName 0 0\n";
        }
      }else {
        print "001 : $inst_tmp not exists in PORTS_ALREADY and COMP_ALREADY\n";
      }
    }
  }#foreach
close(WRITE);
}#else
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_mid_x_and_mid_y_of_inst_pin took:",timestr($td),"\n";
}#sub write_mid_x_and_mid_y_of_inst_pin
#------------------------------------------------------------------------------------------------#
sub write_cell_pin_loc_frm_lef {
use Benchmark;
my $t0 = new Benchmark;
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq "-h"){ print "Usage : write_cell_pin_loc_frm_lef\n";
                                         print "      : -output<fileName>\n";
}else {
  my $write_output = "";
  for(my $i=0;$i<$noOfArguments;$i++){
    if($_[$i] =~ /-output/){$write_output = $_[$i+1];}
  }#for
  open(WRITE,">$write_output");
  my $dbu = $GLOBAL->dbfGlobalGetDBU;
  foreach my $cell (keys %PLDB){
    my @pins = $PLDB{$cell}->dbMdbGetPins;
    if(@pins > 0){
      print WRITE "$cell ";
      foreach my $pinName (@pins){
        my @pinRect = $PLDB{$cell}->dbMdbGetPinRect($pinName);
        my @POLY = $PLDB{$cell}->dbMdbGetPinPolygon($pinName);
        if(@pinRect > 0){
          my ($pinlayer,$pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[0,2,3,4,5];
          if($pinlayer !~ /^v/i){
            my $xmiddle_pin_rect = int ((($pinllx+$pinurx)/2)*$dbu);
            my $ymiddle_pin_rect = int ((($pinlly+$pinury)/2)*$dbu); 
            print WRITE "$pinName $xmiddle_pin_rect $ymiddle_pin_rect "; 
          }else {
            my @rect_or_polygon = (split(/\s+/,$POLY[0]));
            shift @rect_or_polygon;
            shift @rect_or_polygon;
            my $xmiddle_pin_rect = int (($rect_or_polygon[0])*$dbu);
            my $ymiddle_pin_rect = int (($rect_or_polygon[1])*$dbu);
            print WRITE "$pinName $xmiddle_pin_rect $ymiddle_pin_rect "; 
          }
        }elsif(@POLY > 0){
          my @rect_or_polygon = (split(/\s+/,$POLY[0]));
          shift @rect_or_polygon;
          shift @rect_or_polygon;
          my $xmiddle_pin_rect = int (($rect_or_polygon[0])*$dbu);
          my $ymiddle_pin_rect = int (($rect_or_polygon[1])*$dbu);
          print WRITE "$pinName $xmiddle_pin_rect $ymiddle_pin_rect "; 
        }else {
          print WRITE "$pinName 0 0 ";
        }
      }#foreach pin
      print WRITE "\n";
    }#if pin
  }#foreach 
  close(WRITE);
}
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "Command write_cell_pin_loc_frm_lef took:",timestr($td),"\n";
}#sub write_cell_pin_loc_frm_lef
#------------------------------------------------------------------------------------------------#
1;
