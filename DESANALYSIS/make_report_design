
#sub hashValueAscendingNum {
#   $get_num_of_pins{$a} <=> $get_num_of_pins{$b};
#}
#--------------------------------------------------------------#
sub report_design_new {
my $no_of_Arguments = @_;
if ($no_of_Arguments < 0 || $_[0] eq "-h"){ print "Usage : report_design_new\n";
                                            print "                 --summary\n";
                                          } 
else {
my $DEFAULT = 1;
my $NUM_OF_MACRO =0;
my $NUM_OF_MODULE = 0;
my $NUM_OF_INST = 0;
my $NUM_OF_FXD_INST = 0;
my $NUM_OF_NETS = 0;
my $NUM_OF_PORTS = 0;
my $NUM_OF_ROWS = 0;
my $MACRO_AREA = 0;
my $STD_CELL_AREA = 0;
my $CORE_SIZE = 0;
my $STD_UTIL = 0;
my $CHIP_UTIL = 0;
my $CELL_VS_INST = 0;
my $NET_DATA = 0;
my $WRITE_XML = 0;
my $PRINT_XML = 0;
my $WRITE_PDF = 0;
my $WRITE_REPORT = 0;
my $WRITE_LAYER_DATA = 0;
my $DIEAREA = 0;
my $PHYSICAL_CELL_AREA = 0;

  for (my $i = 0; $i < $no_of_Arguments; $i++){
    if($_[$i] eq "--num_of_macro"){$NUM_OF_MACRO = 1; $DEFAULT =0;}
    if($_[$i] eq "--num_of_module"){$NUM_OF_MODULE = 1; $DEFAULT = 0;}
    if($_[$i] eq "--num_of_inst"){$NUM_OF_INST = 1; $DEFAULT = 0;}
    if($_[$i] eq "--num_of_nets"){$NUM_OF_NETS = 1; $DEFAULT = 0;}
    if($_[$i] eq "--num_of_ports"){$NUM_OF_PORTS = 1; $DEFAULT = 0;}
    if($_[$i] eq "--num_of_rows"){$NUM_OF_ROWS = 1; $DEFAULT = 0;}
    if($_[$i] eq "--macro_area"){$MACRO_AREA = 1;$DEFAULT = 0;}
    if($_[$i] eq "--std_cell_area"){$STD_CELL_AREA = 1; $DEFAULT = 0;}
    if($_[$i] eq "--core_size"){$CORE_SIZE = 1; $DEFAULT = 0;}
    if($_[$i] eq "--std_util"){$STD_UTIL = 1; $DEFAULT = 0;}
    if($_[$i] eq "--chip_util"){$CHIP_UTIL = 1; $DEFAULT = 0;}   
    if($_[$i] eq "--cell_vs_inst"){$CELL_VS_INST = 1;$DEFAULT = 0;}
    if($_[$i] eq "--netdata"){$NET_DATA = 1;$DEFAULT=0;}
    if($_[$i] eq "--xml"){$WRITE_XML = 1;$DEFAULT = 0;}
    if($_[$i] eq "--print_xml"){$PRINT_XML = 1;$DEFAULT = 0;} 
    if($_[$i] eq "--pdf"){$WRITE_PDF = 1;$DEFAULT = 0;}
    if($_[$i] eq "--rpt"){$WRITE_REPORT = 1;}
    if($_[$i] eq "--layer"){$WRITE_LAYER_DATA = 1;$DEFAULT = 0;}
    if($_[$i] eq "--fixed_inst"){$NUM_OF_FXD_INST = 1;$DEFAULT = 0;}
    if($_[$i] eq "--diearea"){$DIEAREA = 1;$DEFAULT = 0;}
    if($_[$i] eq "--physical_cell_area"){$PHYSICAL_CELL_AREA = 1;$DEFAULT = 0;}
  }
my $TOP_MODULE =  $GLOBAL->dbfGlobalGetTOP();
my $dbu = $GLOBAL-dbfGlobalGetDBU;
if($WRITE_REPORT == 1){
open(WRITE_RPT,">design.rpt");
}
if($DIEAREA == 1 || $DEFAULT == 1){
my $diearea = &get_diearea;
print WRITE_RPT "Die area = $diearea dbu sq \n";
}#
if($NUM_OF_MACRO == 1 || $DEFAULT == 1){
my $num_of_macros = &no_of_macro_instances;
print WRITE_RPT "Total Number of Macro  = $num_of_macros\n";
}
if($NUM_OF_MODULE == 1 || $DEFAULT == 1){
my $num_of_mod = &no_of_modules;
print WRITE_RPT "Total Number of modules = $num_of_mod\n";
}
if($NUM_OF_INST == 1 || $DEFAULT == 1){
my $num_of_instance = &no_of_instances;
print WRITE_RPT "Total Number of Instance = $num_of_instance\n"; 
}
if($NUM_OF_NETS == 1 || $DEFAULT == 1){
my $total_num_of_nets = &no_of_nets;
print WRITE_RPT "Total Number of Nets = $total_num_of_nets\n"; 
}
if($NUM_OF_PORTS == 1 || $DEFAULT == 1){
my $total_num_of_ports = &no_of_ports;
print WRITE_RPT "Total Number of Ports = $total_num_of_ports\n";
}
if($NUM_OF_ROWS == 1 || $DEFAULT == 1){
my $total_rows = &no_of_rows;
print WRITE_RPT "Total Number of rows = $total_rows\n";
}
if($NUM_OF_FXD_INST == 1 || $DEFAULT == 1){
my $num_of_fixed_instance = &no_of_fixed_instance; 
print WRITE_RPT "Total Number of fixed instances = $num_of_fixed_instance\n";
}
if($MACRO_AREA == 1 || $DEFAULT == 1){
my $total_macroarea = &macro_area;
print WRITE_RPT "Total macro area = $total_macroarea micron sq\n";
}
if($STD_CELL_AREA == 1 || $DEFAULT == 1){
my $total_stdcellarea = &std_cell_area;
print WRITE_RPT "Total std cell area = $total_stdcellarea micron sq \n";
}
if($PHYSICAL_CELL_AREA == 1 || $DEFAULT == 1){
my $total_physical_inst_area = &get_area_for_physical_inst;
print WRITE_RPT "Total physical cell area = $total_physical_inst_area micron sq \n";
}
if($CORE_SIZE == 1 || $DEFAULT == 1){
my $total_corearea = &core_size;
print WRITE_RPT"Core Area = $total_corearea micron sq \n";
}
if($STD_UTIL == 1 || $DEFAULT == 1){
my $get_stdcell_util = &std_cell_utilization;
print WRITE_RPT"Toal std cell utilization = $get_stdcell_util\n";
}
if($CHIP_UTIL == 1 || $DEFAULT ==1 ){
my $get_chiputilization = &chip_utilization;
print WRITE_RPT"Chip Utilization = $get_chiputilization\n";
}
if($CELL_VS_INST == 1 || $DEFAULT == 1){
my %cellname_vs_inst_cnt = &cellref_vs_inst_cnt;
print WRITE_RPT"CellName\t\t\t\t\t\tCellName Vs InstCnt\n";
  foreach my $cellName (keys %cellname_vs_inst_cnt){
    my $new_cellName = sprintf("%-40s",$cellName);
    print WRITE_RPT"$new_cellName";
    print WRITE_RPT"\t\t $cellname_vs_inst_cnt{$cellName}\n";
  }
print WRITE_RPT"\n";
}
if($NET_DATA == 1 || $DEFAULT == 1){
my $net_cnt = 1;
#print WRITE_RPT"NetName\t\t\t\t\t\tNum of Pins\t\tWL\n";
print WRITE_RPT"NetNumber\t\tNum of Pins\t\tWL in dbu\n";
  foreach my $netName(keys %NETS_ALREADY){
    my %get_pins_foreach_net = &get_num_of_pins_foreach_net($netName);
    my $Wirelength = &get_net_length_by_manhattan($netName);
    my $newwl = sprintf("%.2f",$Wirelength);
    my $wl_micron = $Wirelength/$dbu;
    $TOTAL_WIRE_LENGTH = $TOTAL_WIRE_LENGTH + $wl_micron; 
    my $new_netName = sprintf("%-50s",$netName);
    print WRITE_RPT"$net_cnt\t\t\t\t";
    #print WRITE_RPT"$new_netName";
    foreach my $netName_new (keys %get_pins_foreach_net){
      print WRITE_RPT"$get_pins_foreach_net{$netName}\t\t";
    }
    print WRITE_RPT"$newwl\n";
  $net_cnt++;
  }
}
#-------------------------------------------------------------------------------------#
if($WRITE_XML == 1){
#&report_design_xml;
my $xmloutput = &report_design_xml_new;
print "\n$xmloutput\n"if($PRINT_XML == 1);
return $xmloutput;
}
#------------------------------------------------------------------------------------#
if($WRITE_PDF == 1){
&report_design_pdf;
}
#------------------------------------------------------------------------------------#
if($WRITE_LAYER_DATA == 1){
  &report_design_pdf("--layer");
  print WRITE_RPT"NetName\t\t\t\t\t\t\tLayerName Vs Length\n";
  print WRITE_RPT"\n";
  foreach my $netName (keys %NETS_ROUTING_ALREADY){
    my $new_netName = sprintf("%-50s",$netName);
    print WRITE_RPT"$new_netName";
    my %layerName_vs_length = &get_net_length_by_layer($netName);
    foreach my $layer (keys %layerName_vs_length){
        print WRITE_RPT"\t$layer $layerName_vs_length{$layer}\n";
        print WRITE_RPT"\t\t\t\t\t\t";
    }
    print WRITE_RPT"\n";
  }
}
#------------------------------------------------------------------------------------#
}
}#sub report_design_new 
#---------------------------------------------------------------------------------------------------------------------------#
sub no_of_macro_instances {
my $no_of_macro = 0;
foreach my $instance (keys %COMP_ALREADY){
  my $cellref = $CADB{$instance}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my $class = $PLDB{$cellref}->dbMdbGetClass;
    if($class eq "BLOCK"){
      $no_of_macro++;
    }
  }
}
return($no_of_macro);
}#sub no_of_macro_instances
#---------------------------------------------------------------------------------------------------------------------------#
sub no_of_modules {
my $no_of_mod = 0;
foreach my $moduleName (keys %MODULE_ALREADY){
$no_of_mod++;
}
if($no_of_mod == 0){
$no_of_mod = 1;
}
return($no_of_mod);
}#sub no_of_modules
###---------------------------------------------------------------------------------------------------------------------------#
sub no_of_instances {
my $total_inst = 0;
foreach my $instance (keys %COMP_ALREADY){
$total_inst++;
}
return($total_inst);
}#sub no_of_instances
##---------------------------------------------------------------------------------------------------------------------------#
sub no_of_fixed_instance {
my $total_fixed = 0;
foreach my $instance (keys %COMP_ALREADY){
  if(exists $CADB{$instance}){
    my $status = $CADB{$instance}->dbCadbGetStatus;
    if($status eq "FIXED"){
       $total_fixed++;
    }
  } 
}
return($total_fixed);
}#sub no_of_fixed_instance



#----------------------------------------------------------------------------------------------------------------------------#
sub no_of_ports {
my $total_port = 0;
foreach my $portName (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
     $total_port++;
} 
return($total_port);
}#sub no_of_ports
###---------------------------------------------------------------------------------------------------------------------------#
sub no_of_nets {
my $num_of_nets = 0;
foreach my $nets (keys %NETS_ALREADY){
  $num_of_nets++ ;
}
return($num_of_nets);
}#sub no_of_nets
##---------------------------------------------------------------------------------------------------------------------------#
#sub pin_distribution {
#}#sub pin_distribution
###---------------------------------------------------------------------------------------------------------------------------#
sub macro_area {
my $total_macro_area = 0;
foreach my $instance (keys %COMP_ALREADY){
my $macroName = $CADB{$instance}->dbCadbGetCellref; 
  if(exists $PLDB{$macroName}){
    my $class = $PLDB{$macroName}->dbMdbGetClass;
    if($class eq "BLOCK"){
    my @size = $PLDB{$macroName}->dbMdbGetSize;
    my $width = $size[0];
    my $height = $size[1];
    my $macroarea = $width*$height;
    $total_macro_area = $total_macro_area + $macroarea;
    }
  }
}
return($total_macro_area);
}#sub macro_area
##---------------------------------------------------------------------------------------------------------------------------#
sub std_cell_area {
my $total_std_cell_area = 0;
foreach my $instance (keys %COMP_ALREADY){
my $cellref = $CADB{$instance}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my $class = $PLDB{$cellref}->dbMdbGetClass;
    if($class eq "CORE"){
      my @size = $PLDB{$cellref}->dbMdbGetSize;
      my $width = $size[0];
      my $height = $size[1];
      my $std_cellarea = $width*$height;
      $total_std_cell_area = $total_std_cell_area + $std_cellarea;
    }
  }
}
return ($total_std_cell_area);
}#sub std_cell_area
##---------------------------------------------------------------------------------------------------------------------------#
sub core_size {
my $dbu = $GLOBAL->dbfGlobalGetDBU;
my @get_size = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}->dbFlplanGetSize;
my $llx = $get_size[0];
my $lly = $get_size[1];
my $urx = $get_size[2];
my $ury = $get_size[3];

my $new_llx = $get_size[0]/$dbu;
my $new_lly = $get_size[1]/$dbu;
my $new_urx = $get_size[2]/$dbu;
my $new_ury = $get_size[3]/$dbu;

my $core_width = $new_urx - $new_llx;
my $core_height = $new_ury - $new_lly;
my $core_area = $core_width*$core_height;
#print WRITE_RPT"Core Width = $core_width micron ,Core Height = $core_height micron\n";
return($core_area);
}#sub core_size
##---------------------------------------------------------------------------------------------------------------------------#
sub no_of_rows {
my @rows = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}->dbFlplanGetRows;
my $number_of_rows = @rows;
return($number_of_rows);
}#sub no_of_rows
##---------------------------------------------------------------------------------------------------------------------------#
#sub dirty_area {
#}#sub dirty_area
##---------------------------------------------------------------------------------------------------------------------------#
sub chip_utilization {
my $get_macro_area = &macro_area;
my $get_core_area = &core_size;
my $get_macro_utilization =  ($get_macro_area*100)/$get_core_area;
my $get_std_cell_utilization = &std_cell_utilization;
my $get_chip_utilization =  ($get_std_cell_utilization + $get_macro_utilization);
return($get_chip_utilization);
}#sub chip_utilization
##---------------------------------------------------------------------------------------------------------------------------#
sub std_cell_utilization {
my $getcorearea = &core_size;
my $get_stdcell_area = &std_cell_area; 
my $std_cellutilization = ($get_stdcell_area*100)/$getcorearea;
return($std_cellutilization);
}#sub std_cell_utilization 
##---------------------------------------------------------------------------------------------------------------------------#
sub cellref_vs_inst_cnt {
my %cell_vs_instance = ();
foreach my $instance (keys %COMP_ALREADY){
my $cellref = $CADB{$instance}->dbCadbGetCellref;
$cell_vs_instance{$cellref} += 1 ;
}
return(%cell_vs_instance);
}#sub cellref_vs_inst_cnt
#---------------------------------------------------------------------------------------------------------------------------#
sub cellref_vs_area {
my %cell_vs_area = ();
foreach my $instance (keys %COMP_ALREADY){
my $cellref = $CADB{$instance}->dbCadbGetCellref;
  if (exists $PLDB{$cellref} ) { 
    my @size = $PLDB{$cellref}->dbMdbGetSize;
    my $area = ($size[0]*$size[1]); 
    $cell_vs_area{$cellref} += $area;
  }
}
return(%cell_vs_area);
}#cellref_vs_area
#---------------------------------------------------------------------------------------------------------------------------#
sub get_net_length_by_manhattan{
my $netName = $_[0];
my $wire_length = "";
if(exists $NETS_ALREADY{$netName}){
my @new_inst_data = ();
my @nodex = ();
my @nodey = ();
my @driverInst = &getNetDriver($netName);
my @sinkInst = &getNetSink($netName);
if($#driverInst >= 1){
push(@new_inst_data,@driverInst);
}
if($#sinkInst >= 1){
push(@new_inst_data,@sinkInst);
}
  for(my $i =0; $i <=$#new_inst_data;$i=$i+2){
    my $inst_tmp = $new_inst_data[$i];
    my $pinName = $new_inst_data[$i+1];
    if($inst_tmp eq "\*"){
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}){
      my $status = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetStatus;
      if($status > 1){
        my @portLoc = $PORTS_ALREADY{$TOP_MODULE}{$inst_tmp}->dbPortGetLoc;
        push(@nodex,$portLoc[0]);
        push(@nodey,$portLoc[1]);
      }
    }elsif(exists $COMP_ALREADY{$inst_tmp}){
      my $status = $CADB{$inst_tmp}->dbCadbGetStatus;
      if ( $status eq "PLACED" || $status eq "FIXED" ) { 
        my $cellref = $CADB{$inst_tmp}->dbCadbGetCellref;
        my @instLoc = $CADB{$inst_tmp}->dbCadbGetLoc;
        my $instOrient = $CADB{$inst_tmp}->dbCadbGetOrient;
        if(exists $PLDB{$cellref}){
          my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
          my @cellsize = $PLDB{$cellref}->dbMdbGetSize;
          my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
          my ($pinllx,$pinlly,$pinurx,$pinury) = (split(/\s+/,$pinRect[0]))[2,3,4,5];
          my @absolute_pin_rect = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0], $cellOrigin[1],$instOrient,$cellsize[0],$cellsize[1],$pinllx,$pinlly,$pinurx,$pinury);
          my $xmiddle_pin_rect = ($absolute_pin_rect[0]+$absolute_pin_rect[2])/2;
          my $ymiddle_pin_rect = ($absolute_pin_rect[1]+$absolute_pin_rect[3])/2;
          push(@nodex,$xmiddle_pin_rect);
          push(@nodey,$ymiddle_pin_rect);
        }
     }#if status
    }else {print "WARN-DES : 001 : $inst_tmp not exists in PORTS_ALREADY and COMP_ALREADY\n";}
  }
if($#nodex >= 0) {
  @nodex = sort{$a<=>$b}@nodex;
  @nodey = sort{$a<=>$b}@nodey;
  my $xmin = $nodex[0];
  my $ymin = $nodey[0];
  my $xmax = $nodex[-1];
  my $ymax = $nodey[-1];
  my $Y_length = $ymax - $ymin;
  my $X_length = $xmax - $xmin;
     $wire_length = $X_length + $Y_length;
  }else {print "WARN-DES-GET_NET_LEN_BY_MH : 002 : Not getting the wire length of this net $netName \n";}
}
return ($wire_length);
}#sub get_net_length_by_manhattan
#----------------------------------------------------------------------------------------------------------------------------#
sub get_net_length_by_layer {
my $nets = $_[0];
my %layer_vs_length = ();
my $total_distance = 0;
if(exists $NETS_ROUTING_ALREADY{$nets}){
  my @routes = $NETS_ROUTING_ALREADY{$nets}->dbNetRoutingDBGetRegularRoute;
  foreach my $l (@routes){
    my $routelayer = (split(/\s+/,$l))[0];
    my @routebbox = &xformNetSegToPathSeg($l);
    my $X_distance = $routebbox[2] - $routebbox[0];
    my $Y_distance = $routebbox[3] -$routebbox[1];
    $total_distance = $X_distance + $Y_distance;
    $layer_vs_length{$routelayer} +=  $total_distance;
  }
}
return(%layer_vs_length);
}#sub get_net_length_by_layer
#---------------------------------------------------------------------------------------------------------------------------#
sub get_num_of_pins_foreach_net {
my $netName = $_[0];
my %Num_of_pins = ();
if(exists $NETS_ALREADY{$netName}){
  foreach my $instname (keys %{$NETS_ALREADY{$netName}}){
    my $pinName = $NETS_ALREADY{$netName}{$instname};
    $Num_of_pins{$netName} += 1 ;
  }
}
return(%Num_of_pins); 
}#sub get_num_of_pins_foreach_net
#-----------------------------------------------------------------------------------------------------------------------------#
sub report_net_new {
my %WL = ();
foreach my $netName ( keys %{NETS_ALREADY} ) {
  my $noOfKeys = keys %{$NETS_ALREADY{$netName}}  ;
  my $netWl = &get_net_length_by_manhattan($netName);
  $WL{$noOfKeys} += $netWl;  
}#foreach all nets in the design
return (%WL);
}#sub report_net_new
#-----------------------------------------------------------------------------------------------------------------------------#
sub report_design_xml {
use XML::Writer;
use IO::File;
my $output = new IO::File(">design_rpt.xml");
my $writer = new XML::Writer(OUTPUT => $output,DATA_MODE => 1);
my $moduleName = $GLOBAL->dbfGlobalGetTOP;
$writer->startTag("report_design");
$writer->startTag("design",
                   name => $moduleName);
my $no_of_macros = &no_of_macro_instances;
$writer->startTag("total_macro_instance");
$writer->characters($no_of_macros);
$writer->endTag();
#-------------------------------------------------------------------#
my $no_of_mod = &no_of_modules;
$writer->startTag("total_module");
$writer->characters($no_of_mod);
$writer->endTag();
#-------------------------------------------------------------------#
my $total_inst = &no_of_instances;
$writer->startTag("total_instance");
$writer->characters($total_inst);
$writer->endTag();
#-------------------------------------------------------------------#
my $num_of_fixed_instance = &no_of_fixed_instance;
$writer->startTag("total_fixed_instance");
$writer->characters($num_of_fixed_instance);
$writer->endTag();
#-------------------------------------------------------------------#
my $total_port =&no_of_ports;
$writer->startTag("total_Ports");
$writer->characters($total_port);
$writer->endTag("total_Ports");
#-------------------------------------------------------------------#
my $total_nets = &no_of_nets;
$writer->startTag("total_Nets");
$writer->characters($total_nets);
$writer->endTag("total_Nets");
#--------------------------------------------------------------------#
my $get_macro_area = &macro_area;
$writer->startTag("macro_area");
$writer->characters("$get_macro_area");
$writer->endTag("macro_area");
#--------------------------------------------------------------------#
my $get_std_cell_area = &std_cell_area;
$writer->startTag("std_cell_area");
$writer->characters("$get_std_cell_area");
$writer->endTag("std_cell_area");
#--------------------------------------------------------------------#
my $get_corearea = &core_size;
$writer->startTag("core_area");
$writer->characters("$get_corearea");
$writer->endTag("core_area");
#--------------------------------------------------------------------#
my $get_num_of_rows = &no_of_rows;
$writer->startTag("total_rows");
$writer->characters($get_num_of_rows);
$writer->endTag("total_rows");
#--------------------------------------------------------------------#
my $get_chip_util = &chip_utilization;
$writer->startTag("chip_utilization");
$writer->characters($get_chip_util);
$writer->endTag("chip_utilization");
#--------------------------------------------------------------------#
my $std_cellutil = &std_cell_utilization;
$writer->startTag("std_cell_utilization");
$writer->characters($std_cellutil);
$writer->endTag("std_cell_utilization");
#---------------------------------------------------------------------#
my %cellref_vs_inst = &cellref_vs_inst_cnt;
foreach my $cell (keys %cellref_vs_inst){
$writer->startTag("cell_vs_inst_cnt" => ("name",$cell));
$writer->dataElement(cnt => $cellref_vs_inst{$cell});
$writer->endTag();
}
#----------------------------------------------------------------------#
foreach my $netName (keys %NETS_ALREADY){
$writer->startTag("net_data" => ("name",$netName));
my %get_num_of_pins = &get_num_of_pins_foreach_net($netName);
$writer->dataElement(num_of_pins => $get_num_of_pins{$netName});
my $get_manhattan_wl = &get_net_length_by_manhattan($netName);
my $new_wl = sprintf("%.2f",$get_manhattan_wl);
$writer->dataElement(mhd_wl => $new_wl);
  if(exists $NETS_ROUTING_ALREADY{$netName}){
  my %get_layer_vs_wl = &get_net_length_by_layer($netName);
    if(%get_layer_vs_wl){
      foreach my $layerName (keys %get_layer_vs_wl){
      $writer->startTag("layer",
                        name => $layerName);
      $writer->dataElement(layer_vs_wl => $get_layer_vs_wl{$layerName});
      $writer->endTag();
      }
    }
  }
$writer->endTag();
}
#----------------------------------------------------------------------#
$writer->endTag("design");
$writer->endTag("report_design");
$writer->end();
}#sub report_design_xml
#-----------------------------------------------------------------------#
sub report_design_pdf {
use PDF::Create;
my $noOfArguments = @_;
if($noOfArguments < 0 || $_[0] eq '-h'){print "Usage : report_design_pdf\n";
                                        print "      : --layer\n";
                                       }#if
else {
my $get_layer_data  = 0;
      for(my $i =0 ; $i <$noOfArguments; $i++){
          if( $_[$i] eq "--layer"){$get_layer_data = 1;}
                                              }#for

my $moduleName = $GLOBAL->dbfGlobalGetTOP;
my $pdf = new PDF::Create('filename' => "$moduleName.pdf",
                          'Version'  => 1.2,
                          'PageMode' => 'UseOutlines',
                          'Author'   => 'Fabien Tassin',
                          'Title'    => 'Report Design',
                     );
my $root = $pdf->new_page('MediaBox' => [ 0, 0, 500, 700 ]);
my $page1 = $root->new_page;

my $f1 = $pdf->font('Subtype'  => 'Type1',
                    'Encoding' => 'WinAnsiEncoding',
                    'BaseFont' => 'Times-Roman');
my $f2 = $pdf->font('Subtype'  => 'Type1',
                    'Encoding' => 'WinAnsiEncoding',
                    'BaseFont' => 'Times-Bold');
$page1->stringc($f2, 40,250, 650, "Design");
$page1->stringc($f1, 20,250, 600, "$moduleName");

my $total_module = &no_of_modules;
$page1->stringl($f1,11,25,550,"Total Modules    =    $total_module");

my $no_of_macros = &no_of_macro_instances;
$page1->stringl($f1, 11, 25,510,"Total Macros    =   $no_of_macros");

my $total_inst = &no_of_instances;
$page1->stringl($f1, 11, 25, 470,"Total Instance    =    $total_inst");

my $total_port =&no_of_ports;
$page1->stringl($f1, 11, 25, 430, "Total Ports    =    $total_port");

my $total_nets = &no_of_nets;
$page1->stringl($f1, 11, 25, 390, "Total Nets    =    $total_nets");

my $get_macro_area = &macro_area;
$page1->stringl($f1, 11, 25, 350, "Macro Area    =    $get_macro_area");

my $get_std_cell_area = &std_cell_area;
$page1->stringl($f1, 11, 25, 310, "Std Cell Area    =    $get_std_cell_area");

my $get_corearea = &core_size;
$page1->stringl($f1, 11, 25, 270, "Core Area    =    $get_corearea");

my $get_num_of_rows = &no_of_rows;
$page1->stringl($f1, 11, 25, 230, "Total Rows    =    $get_num_of_rows");

my $get_chip_util = &chip_utilization;
$page1->stringl($f1, 11, 25, 190, "Chip Utilization    =    $get_chip_util");

my $std_cellutil = &std_cell_utilization;
$page1->stringl($f1, 11, 25, 150, "Std Cell Utilization    =    $std_cellutil");

my $get_fixed = &no_of_fixed_instance;
$page1->stringl($f1,11,25,110, "Total Fixed Instance     =     $get_fixed");

my $TOTAL_WL = 0;
foreach my $nets (keys %NETS_ALREADY){
my $get_wl = &get_net_length_by_manhattan($nets);
$TOTAL_WL = $TOTAL_WL + $get_wl;
}
$page1->stringl($f1,11,25,70,"Total Wire Length = $TOTAL_WL"); 

my $page2;
my $count = 0;
my %cellref_vs_inst = &cellref_vs_inst_cnt;
my @cell = keys(%cellref_vs_inst);
for(my $i = 0;$i<=$#cell;$i++){
my $cell_name = $cell[$i];
my $inst_cnt = $cellref_vs_inst{$cell_name};
if(($i/25) == (int($i/25))){
$page2 = $root->new_page;
$count = 0;
}
my $llx = 50;
my $lly = 625-25*$count;
my $urx = 400;
$page2->stringl($f2, 14, 50, 650, "CellName");
$page2->stringr($f2,14,450,650,"Instance Cnt");
$page2->stringl($f1,11,$llx,$lly,$cell_name);
$page2->stringr($f1,11,$urx,$lly,$inst_cnt);
$count++;
}
#-----------------------------------------------------------------#
my %NET_HASH= &dbaReportNetWithNPins("--summary");
my @sorted = sort {$a <=> $b} keys %NET_HASH;
my @numnets = ();
foreach my $srt (@sorted){
my $nl = $NET_HASH{$srt};
push (@numnets,$nl);
}
my %wl = &report_net_new;
my $page_next;
my $Count = 0;
for (my $k =0; $k<@sorted;$k++){
my $num_pin = $sorted[$k];
my $total_wr_l = $wl{$num_pin};
my $new_wl = sprintf("%.2f",$total_wr_l);
if(($k/25) == (int($k/25))){
$page_next = $root->new_page;
$page_next->stringc($f2,18,250,675,"Summary of WL by NetType");
$Count = 0 ;
}
my $LLx = 50;
my $LLy = 625-25*$Count;
my $URX1 = 250;
my $URX2 = 450;
$page_next->stringl($f2,11,$LLx,650,"Num of Pins");
$page_next->stringc($f2,11,$URX1,650,"Total Nets");
$page_next->stringr($f2,11,$URX2,650,"Total WL");
$page_next->stringl($f1,11,$LLx,$LLy,$num_pin);
$page_next->stringc($f1,11,$URX1,$LLy,$numnets[$k]);
$page_next->stringr($f1,11,$URX2,$LLy,$new_wl);
$Count++;
}
#-----------------------------------------------------------------#
my $page;
my $cnt = 0;
my @netName = (keys %NETS_ALREADY);
for(my $i = 0;$i <=$#netName;$i++){
my $net = $netName[$i];
my $new_netname = sprintf("%.34s",$net);
my %get_num_of_pins = &get_num_of_pins_foreach_net($net);
my $get_manhattan_wl = &get_net_length_by_manhattan($net);
$TOTAL_WL = $TOTAL_WL + $get_manhattan_wl;
my $new_wl = sprintf("%.2f",$get_manhattan_wl);
my $pin_cnt = $get_num_of_pins{$net};
if(($i/25) == (int($i/25))){
$page = $root->new_page;
$page->stringc($f2,18,250,675,"NetData");
$cnt = 0;
}
my $llx = 50;
my $lly = 625-25*$cnt;
my $urx1 = 250;
my $urx2 = 450;
$page->stringl($f2,11,$llx,650,"NetName");
$page->stringc($f2,11,$urx1,650,"Total Pins");
$page->stringr($f2,11,$urx2,650,"Wire Length");
$page->stringl($f1,11,$llx,$lly,$new_netname);
$page->stringc($f1,11,$urx1,$lly,$pin_cnt);
$page->stringr($f1,11,$urx2,$lly,$new_wl);
$cnt++;
}
#------------------------------------------------------------------#
if($get_layer_data == 1){
my $page_new;
my $Cnt = 0;
my @netName = (keys %NETS_ROUTING_ALREADY);
for(my $i =0;$i<=$#netName;$i++){
my $net = $netName[$i];
if(($i/12) == (int($i/12))){
$page_new = $root->new_page;
$Cnt = 0;
}
my $lly1 = 650-50*$Cnt;
my $lly2 = 625-50*$Cnt;
$page_new->stringl($f1,11,50,675,"NetName");
$page_new->stringr($f1,11,450,675,"Layer_Vs_Length");
$page_new->stringl($f1,11,50,$lly1,$net);
my %layer_Vs_length = &get_net_length_by_layer($net);
my @layer = sort {$a cmp $b} keys %layer_Vs_length;
my @total_wire_length = ();
foreach my $lyr (@layer){
  my $layer_wl = $layer_Vs_length{$lyr};
  push(@total_wire_length,$layer_wl);
}
my $layer_data = join",",@layer;
my $data_total = join", ",@total_wire_length;
$page_new->stringr($f1,11,450,$lly1,$layer_data);
$page_new->stringr($f1,11,450,$lly2,$data_total);
$Cnt++;
}
}
$pdf->close;
}
}#sub report_design_pdf
#--------------------------------------------------------------#
sub report_design_xml_new {
  my $xml_output = "";
  my $xml = new XML::Writer(OUTPUT => \$xml_output);
  my $moduleName = $GLOBAL->dbfGlobalGetTOP;
  $xml->startTag("root");
  $xml_output .= "\n";
  $xml_output .= " ";
  $xml->startTag("report_design");
  $xml_output .= "\n";
  $xml_output .= "  ";
  $xml->startTag("design");
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("name");
  $xml->characters($moduleName);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("total");
  $xml_output .= "\n";
  $xml_output .= "    ";
#-------------------------------------------------#
  my $no_of_macros = &no_of_macro_instances;
  $xml->startTag("macro_instance");
  $xml->characters($no_of_macros);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $no_of_mod = &no_of_modules;
  $xml->startTag("module");
  $xml->characters($no_of_mod);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $total_inst = &no_of_instances;
  $xml->startTag("inst");
  $xml->characters($total_inst);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $num_of_fixed_instance = &no_of_fixed_instance;
  $xml->startTag("fixed_instance");
  $xml->characters($num_of_fixed_instance);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $total_port =&no_of_ports;
  $xml->startTag("ports");
  $xml->characters($total_port);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $total_nets = &no_of_nets;
  $xml->startTag("nets");
  $xml->characters($total_nets);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $get_num_of_rows = &no_of_rows;
  $xml->startTag("rows");
  $xml->characters($get_num_of_rows);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("area");
  $xml_output .= "\n";
  $xml_output .= "    ";
#-------------------------------------------------#
  my $get_macro_area = &macro_area;
  my $get_macro_area_new = sprintf("%.2f",$get_macro_area);
  $xml->startTag("macro_area");
  $xml->characters($get_macro_area_new);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "    ";
#-------------------------------------------------#
  my $get_std_cell_area = &std_cell_area;
  my $get_std_cell_area_new = sprintf("%.2f",$get_std_cell_area);
  $xml->startTag("std_cell_area");
  $xml->characters($get_std_cell_area_new);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "    ";
#-------------------------------------------------#
  my $get_corearea = &core_size;
  my $get_corearea_new = sprintf("%.2f",$get_corearea);
  $xml->startTag("core_area");
  $xml->characters($get_corearea_new);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("utilization");
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $get_chip_util = &chip_utilization;
  my $get_chip_util_new = sprintf("%.2f",$get_chip_util);
  $xml->startTag("chip_utilization");
  $xml->characters($get_chip_util_new);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "    ";
#-------------------------------------------------#
  my $std_cellutil = &std_cell_utilization;
  my $std_cellutil_new = sprintf("%.2f",$std_cellutil);
  $xml->startTag("std_cell_utilization");
  $xml->characters($std_cellutil_new);
  $xml->endTag();
#-------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  $xml->endTag();
  my %cellref_vs_inst = &cellref_vs_inst_cnt;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('cell_vs_inst_cnt');
  foreach my $cell (keys %cellref_vs_inst){
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('cell','name' => $cell,'inst_cnt' => $cellref_vs_inst{$cell});
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
#------------------------------------------------------------------------#
  my %cell_vs_area = &cellref_vs_area;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('cell_vs_area');
  foreach my $cell (keys %cell_vs_area){
    my $new_cell_area = sprintf("%.2f",$cell_vs_area{$cell});
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('cell','name' => $cell,'area' => $new_cell_area);
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  #----------------------------------------------------------------------#
  #$xml_output .= "\n";
  #$xml_output .= "   ";
  #$xml->startTag('net_data');
  #%get_num_of_pins = &get_pins_data;
  #foreach my $netName (sort hashValueAscendingNum (keys(%get_num_of_pins))) {
  #  my $get_manhattan_wl = &get_net_length_by_manhattan($netName);
  #  my $new_wl = sprintf("%.2f",$get_manhattan_wl);
  #  $xml_output .= "\n";
  #  $xml_output .= "    ";
  #  $xml->startTag('net','name' => $netName,'num_of_pins' => $get_num_of_pins{$netName},'mhd_wl' => $new_wl);
  #    if(exists $NETS_ROUTING_ALREADY{$netName}){
  #    my %get_layer_vs_wl = &get_net_length_by_layer($netName);
  #      if(%get_layer_vs_wl){
  #        foreach my $layerName (keys %get_layer_vs_wl){
  #        $xml_output .= "\n";
  #        $xml_output .= "    ";
  #        $xml->startTag('layer','name' => $layerName,'layer_vs_wl' => $get_layer_vs_wl{$layerName});
  #        $xml->endTag();
  #        $xml_output .= "\n";
  #        $xml_output .= "    ";
  #        }
  #      }
  #    }
  #  $xml->endTag();
  #}
  #$xml_output .= "\n";
  #$xml_output .= "   ";
  #$xml->endTag();
#------------------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('net_vs_type');
  my %NET_HASH= &dbaReportNetWithNPins("--summary");
  my @sorted = sort {$a <=> $b} keys %NET_HASH;
  my @numnets = ();
  foreach my $srt (@sorted){
   my $nl = $NET_HASH{$srt};
   push (@numnets,$nl);
  }
  my %wl = &report_net_new;
  for (my $k =0; $k<@sorted;$k++){
    my $num_pin = $sorted[$k];
    my $total_wr_l = $wl{$num_pin};
    my $new_wl = sprintf("%.2f",$total_wr_l);
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('net_data','num_of_pins' => $num_pin,'num_of_nets' => $numnets[$k],'nets_wl' => $new_wl);
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  #----------------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('net_vs_length');
  my ($bin_size,$netsArray) = &net_vs_length;
  my @netsArray_new = @$netsArray;
  for(my $y=0; $y<=$#netsArray_new; $y++){
      my $range = $bin_size*$y."-".$bin_size*($y+1);
      my $num_of_nets;
      $num_of_nets = $netsArray_new[$y];
      if($netsArray_new[$y] eq ""){$num_of_nets = 0;}
      $xml_output .= "\n";
      $xml_output .= "    ";
      $xml->startTag('net_data','len_range' => $range,'num_of_nets' => $num_of_nets);
      $xml->endTag();  
   }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
#-------------------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('net_vs_pin');
  my ($bin_size,$netsarray) = &net_vs_pin;
  my @netsarray_new = @$netsarray;
  for(my $i=0; $i <= $#netsarray_new; $i++){
      my $range = $bin_size*$i."-".$bin_size*($i+1); 
      my $num_of_nets;
      $num_of_nets = $netsarray_new[$i];
      if($netsarray_new[$i] eq ""){$num_of_nets = 0;}
      $xml_output .= "\n";
      $xml_output .= "    "; 
      $xml->startTag('net_data','len_range' => $range,'num_of_nets' => $num_of_nets);
      $xml->endTag();
  }
 $xml_output .= "\n";
 $xml_output .= "   ";
 $xml->endTag(); 
#-------------------------------------------------------------------------#
  my($percentage_of_LVT,$percentage_of_HVT,$percentage_of_SVT) = &get_no_of_instance_of_lvt_hvt_and_svt;
  if(($percentage_of_LVT != "") || ($percentage_of_HVT != "") || ($percentage_of_SVT != "")) {
    $xml_output .= "\n";
    $xml_output .= "   ";
    $xml->startTag('num_of_instance_of_lvt_hvt_and_svt');
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('data','LVT' => $percentage_of_LVT,
                   'HVT' => $percentage_of_HVT,
                   'SVT' => $percentage_of_SVT);
    $xml->endTag();
    $xml_output .= "\n";
    $xml_output .= "   ";
    $xml->endTag();
  }
#-------------------------------------------------------------------------#
  my %function_vs_area = &area_distribution_by_logic_distribution;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("func_vs_area");
  foreach my $func (keys %function_vs_area){
    my $new_area = sprintf("%.4f",$function_vs_area{$func});
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('func','name' => $func,'area' => $new_area);
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  
#-------------------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "  ";
  $xml->endTag("design");
  $xml_output .= "\n";
  $xml_output .= " ";
  $xml->endTag("report_design");
  $xml_output .= "\n";
  $xml_output .= "";
  $xml->endTag("root");
  $xml->end();
  #print "$xml_output\n";
  return $xml_output;
}#sub report_design_xml_new

#--------------------------------------------------------------#
sub get_pins_data {
my %Num_of_pins = ();
foreach my $netName (keys %NETS_ALREADY){
  foreach my $instname (keys %{$NETS_ALREADY{$netName}}){
    my $pinName = $NETS_ALREADY{$netName}{$instname};
    $Num_of_pins{$netName} += 1 ;
  }
}
return(%Num_of_pins);
}#sub get_pins_data
#--------------------------------------------------------------#
sub get_sorted_array_of_net_length {
my @net_length_list = ();
my @sorted_net_length_list = ();
foreach my $netName (keys %NETS_ALREADY){
  my $get_manhattan_wl = &get_net_length_by_manhattan($netName);
  #my $new_wl = sprintf("%.2f",$get_manhattan_wl);
  push (@net_length_list ,$get_manhattan_wl);
}
@sorted_net_length_list = sort{$a<=>$b}@net_length_list; 
}#sub get_sorted_array_of_net_length
#--------------------------------------------------------------#
sub net_vs_length {
my @netsArray = ();
my $bin_size = 10;
my $num_of_bins = 100/$bin_size;
my @sorted_net_length_list = &get_sorted_array_of_net_length;
my $minwl = $sorted_net_length_list[0];
my $maxwl = $sorted_net_length_list[-1];
foreach my $netName (keys %NETS_ALREADY){
  my $get_manhattan_wl = &get_net_length_by_manhattan($netName);
  my $wl = $get_manhattan_wl;
  for($i =0; $i <$num_of_bins; $i++){
     my $lower_range = $minwl + (($maxwl-$minwl)*$bin_size*$i)/100;
     my $upper_range = $minwl + (($maxwl-$minwl)*$bin_size*($i+1))/100;
#     print "$lower_range | $wl | $upper_range\n";
     if($wl == $minwl){
        if($wl <= $upper_range && $wl >= $lower_range ){
#      print "$lower_range | $wl | $upper_range\n";
           $netsArray[$i]++;
           #last;
        }
     }else{
        if($wl <= $upper_range && $wl > $lower_range){
#      print"$lower_range | $wl | $upper_range\n";
           $netsArray[$i]++;
           #last;
        }
        if($wl == $maxwl && $i == ($num_of_bins -1) && $wl > $upper_range){
#      print"$lower_range | $wl | $upper_range\n";
           $netsArray[$i]++;
           #last;
        }#special case when round off value is approx same
     }#if not equal to min length
   }#for each bin
}#foreach net
#return ($bin_size, \@netsArray);
for(my $y=0; $y<=$#netsArray; $y++){
    my $range = $bin_size*$y."-".$bin_size*($y+1);
    print "range $range | $netsArray[$y]\n";
}
}#sub net_vs_length
#--------------------------------------------------------------#
sub net_vs_pin {
my @netsArray = ();
my $bin_size = 5;
my $num_of_bins = 100/$bin_size;
my %NET_HASH= &dbaReportNetWithNPins("--summary");
my @sorted_num_of_pins = sort {$a <=> $b} keys %NET_HASH;
my $min_no_of_pin = $sorted_num_of_pins[0];
my $max_no_of_pin = $sorted_num_of_pins[-1];
foreach my $netName (keys %NETS_ALREADY){
  my %Num_of_pins = &get_num_of_pins_foreach_net($netName);
  my $num_of_pins = $Num_of_pins{$netName}; 
  for(my $i =0 ;$i <$num_of_bins;$i++){
    my $lower_range = $min_no_of_pin + (($max_no_of_pin - $min_no_of_pin)*$bin_size*$i)/100;
    my $upper_range = $min_no_of_pin + (($max_no_of_pin - $min_no_of_pin)*$bin_size*($i+1))/100;
    #print "$lower_range | $num_of_pins | $upper_range\n";
    if($num_of_pins == $min_no_of_pin){
      if($num_of_pins <= $upper_range && $num_of_pins >= $lower_range){
      #print "$lower_range | $num_of_pins | $upper_range\n";
        $netsArray[$i]++;
      }
    }else{
       if($num_of_pins <= $upper_range && $num_of_pins > $lower_range){
       #print "$lower_range | $num_of_pins | $upper_range\n";
         $netsArray[$i]++;
       }
       if($num_of_pins == $max_no_of_pin && $i == ($num_of_bins -1) && $num_of_pins > $upper_range){
       #print "$lower_range | $num_of_pins | $upper_range\n";
         $netsArray[$i]++;
       }
    }
  }#for
}#foreach 
return ($bin_size,\@netsArray);
#for(my $y=0; $y<=$#netsArray; $y++){
#    my $range = $bin_size*$y."-".$bin_size*($y+1);
#    print "range $range | $netsArray[$y]\n";
#}
}#sub net_vs_pin
#--------------------------------------------------------------#
sub cnt_distribution_by_cell_type {
my $no_of_block = 0;
my $no_of_std_cell = 0;
my $no_of_tiehigh = 0;
my $no_of_tielow = 0;
my $no_of_areaio = 0;
my $no_of_pad = 0;
my $no_of_pad_areaio = 0;
my $no_of_cover_bump = 0;
my $no_of_core_feedthru = 0;
my $no_of_core_antennacell = 0;
my $no_of_core_welltap = 0;
my $no_of_core_spacer = 0;
my $no_of_endcap_pre = 0;
my $no_of_core_tielow = 0;
my $no_of_core_tiehigh = 0;
my %cell_type_vs_cnt = ();
foreach my $instance (keys %COMP_ALREADY){
  my $cellref = $CADB{$instance}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my $class = $PLDB{$cellref}->dbMdbGetClass;
    if($class =~ /^CORE$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_std_cell++;
    }elsif($class =~ /^BLOCK$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_block++;
    }elsif($class =~ /^TIEHIGH$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_tiehigh++;
    }elsif($class =~ /^TIELOW$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_tielow++;
    }elsif($class =~ /^AREAIO$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_areaio++;
    }elsif($class =~ /^PAD$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_pad++;
    }elsif($class =~ /^PAD AREAIO$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_pad_areaio++;
    }elsif($class =~ /^COVER BUMP$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_cover_bump++; 
    }elsif($class =~ /^CORE FEEDTHRU$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_feedthru++;
    }elsif($class =~ /^CORE ANTENNACELL$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_antennacell++;
    }elsif($class =~ /^CORE WELLTAP$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_welltap++;
    }elsif($class =~ /^CORE SPACER$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_spacer++;
    }elsif($class =~ /^ENDCAP PRE$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_endcap_pre++;
    }elsif($class =~ /^CORE TIELOW$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_tielow++;
    }elsif($class =~ /^CORE TIEHIGH$/i){
       $cell_type_vs_cnt{$class} += 1;
      $no_of_core_tiehigh++;
    }
  }else{print "Cell $cellref not exist in PLDB\n";}
}#foreach
return(%cell_type_vs_cnt);
}#sub cnt_distribution_by_cell_type
#--------------------------------------------------------------#
sub get_no_of_instance_of_lvt_hvt_and_svt {
  my $cnt_lvt = 0;
  my $cnt_hvt = 0;
  my $cnt_svt = 0;
  my $new_percentage_of_LVT = "";
  my $new_percentage_of_HVT = "";
  my $new_percentage_of_SVT = "";
  foreach my $instance (keys %COMP_ALREADY){
    my $cellref = $CADB{$instance}->dbCadbGetCellref;
    if(exists $PLDB{$cellref}){
      if($cellref =~/LVT/i){
        $cnt_lvt++;
      }elsif($cellref =~/HVT/i){
        $cnt_hvt++;
      }elsif($cellref =~/SVT/i){
        $cnt_svt++;
      }
    }
  }#foreach 
  my $total_instance = &no_of_instances;
  my $percentage_of_LVT = ($cnt_lvt*100)/$total_instance;
  $new_percentage_of_LVT = sprintf("%.4f",$percentage_of_LVT); 
  
  my $percentage_of_HVT = ($cnt_hvt*100)/$total_instance;
  $new_percentage_of_HVT = sprintf("%.4f",$percentage_of_HVT);
  
  my $percentage_of_SVT = ($cnt_svt*100)/$total_instance;
  $new_percentage_of_SVT = sprintf("%.4f",$percentage_of_SVT);
  return ($new_percentage_of_LVT,$new_percentage_of_HVT,$new_percentage_of_SVT);
}#sub get_no_of_instance_of_lvt_hvt_and_svt
#--------------------------------------------------------------#
sub area_distribution_by_logic_distribution {
  my %function_vs_area = ();
  foreach my $instance (keys %COMP_ALREADY){
    my $cellName = $CADB{$instance}->dbCadbGetCellref;
    if(exists $PLDB{$cellName}){
      my $function = $PLDB{$cellName}->dbMdbGetFunction;
      if($function eq "and"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "nand"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "not"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "or"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "nor"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "xor"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "xnor"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "orand"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "aoi"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "mux"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "buf"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "inv"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "flop"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "andor"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "oai"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "sum of full adder"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      }elsif($function eq "carry of full adder"){
       my @size = $PLDB{$cellName}->dbMdbGetSize;
       my $area = ($size[0]*$size[1]);
       $function_vs_area{$function} += $area;
      } 
    }#if exists
  }#foreach
  foreach my $func (keys %function_vs_area){
    #print "$func => $function_vs_area{$func}\n";
  }
  return (%function_vs_area);
}#sub area_distribution_by_logic_distribution
#--------------------------------------------------------------#
sub no_of_std_cell {
  my $total_no_of_std_cell = 0;
  foreach my $instance (keys %COMP_ALREADY){
  my $cellref = $CADB{$instance}->dbCadbGetCellref;
    if(exists $PLDB{$cellref}){
      my $class = $PLDB{$cellref}->dbMdbGetClass;
      if(($class eq "CORE") || ($class eq "core")){
        $total_no_of_std_cell++;
      }
    }
  }
  return($total_no_of_std_cell);
}#sub no_of_std_cell
#--------------------------------------------------------------#
sub area_distribution_by_cell_type {
  my %cell_type_vs_area = ();
  foreach my $instance (keys %COMP_ALREADY){
    my $cellName = $CADB{$instance}->dbCadbGetCellref;
    if(exists $PLDB{$cellName}){
      my $class = $PLDB{$cellName}->dbMdbGetClass;
      if($class =~ /^CORE$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^BLOCK$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^TIEHIGH$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^TIELOW$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^AREAIO$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^PAD$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^PAD AREAIO$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^COVER BUMP$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^CORE FEEDTHRU$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^CORE ANTENNACELL$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^CORE WELLTAP$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^CORE SPACER$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^ENDCAP PRE$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area; 
      }elsif($class =~ /^CORE TIELOW$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }elsif($class =~ /^CORE TIEHIGH$/i){
        my @size = $PLDB{$cellName}->dbMdbGetSize;
        my $area = ($size[0]*$size[1]);
        $cell_type_vs_area{$class} += $area;
      }
    }else{print "Cell $cellName not exist in PLDB\n";}
  }
  return (%cell_type_vs_area);
}#sub area_distribution_by_cell_type
#--------------------------------------------------------------#
sub report_design_xml_old {
  my $no_of_Arguments = @_;
  if($no_of_Arguments < 0 || $_[0] eq "-h"){ print "Usage : report_design_xml\n";
                                             print "      : --print_xml\n";
                                           }
  else {
    my $PRINT_XML = 0;
    for (my $i = 0; $i < $no_of_Arguments; $i++){
      if($_[$i] eq "--print_xml"){$PRINT_XML = 1;}
    }#for
  my $xml_output = "";
  my $xml = new XML::Writer(OUTPUT => \$xml_output);
  my $moduleName = $GLOBAL->dbfGlobalGetTOP;
  $xml->startTag("root");
  $xml_output .= "\n";
  $xml_output .= " ";
  $xml->startTag("report_design");
  $xml_output .= "\n";
  $xml_output .= "  ";
  $xml->startTag("design");
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('top_module','name' => $moduleName);
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $no_of_macros = &no_of_macro_instances;
  $xml->startTag("total_macro");
  $xml->characters($no_of_macros);
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $no_of_std_cell = &no_of_std_cell;
  $xml->startTag("total_std_cells");
  $xml->characters($no_of_std_cell);
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "    ";
  my $total_nets = &no_of_nets;
  $xml->startTag("total_nets");
  $xml->characters($total_nets);
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('net_vs_pin');
  my ($bin_size,$netsarray) = &net_vs_pin;
  my @netsarray_new = @$netsarray;
  for(my $i=0; $i <= $#netsarray_new; $i++){
      my $range = $bin_size*$i."-".$bin_size*($i+1); 
      my $num_of_nets;
      $num_of_nets = $netsarray_new[$i];
      if($netsarray_new[$i] eq ""){$num_of_nets = 0;}
      $xml_output .= "\n";
      $xml_output .= "    "; 
      $xml->startTag('net_data','len_range' => $range,'num_of_nets' => $num_of_nets);
      $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag(); 
  #------------------------------------------------------------#
  my($percentage_of_LVT,$percentage_of_HVT,$percentage_of_SVT) = &get_no_of_instance_of_lvt_hvt_and_svt;
    $xml_output .= "\n";
    $xml_output .= "   ";
    $xml->startTag('percentage_of_instance_of_lvt_hvt_and_svt');
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('data','LVT' => $percentage_of_LVT,
                   'HVT' => $percentage_of_HVT,
                   'SVT' => $percentage_of_SVT);
    $xml->endTag();
    $xml_output .= "\n";
    $xml_output .= "   ";
    $xml->endTag();
  #------------------------------------------------------------#
  my %cell_type_vs_area = &area_distribution_by_cell_type;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("cell_type_vs_area");
  foreach my $cell_type (keys %cell_type_vs_area){
    my $new_area = sprintf("%.4f",$cell_type_vs_area{$cell_type});
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('cell','name' => $cell_type,'area' => $new_area);
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  #------------------------------------------------------------#
  my %cell_type_vs_cnt = &cnt_distribution_by_cell_type;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("cell_type_vs_cnt");
  foreach my $cell_type (keys %cell_type_vs_cnt){
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('cell','name' => $cell_type,'cnt' => $cell_type_vs_cnt{$cell_type});
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  #------------------------------------------------------------#
  my %function_vs_area = &area_distribution_by_logic_distribution;
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("func_vs_area");
  foreach my $func (keys %function_vs_area){
    my $new_area = sprintf("%.4f",$function_vs_area{$func});
    $xml_output .= "   ";
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('func','name' => $func,'area' => $new_area);
    $xml->endTag();
  }
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag("hierarchy_of_design");
  my @arg = ("--xml" ,"--no_print_area");
  my $hierarchy_data = &report_design_hierarchy_bd(@arg);
  $hierarchy_data =~ s/<root>//;
  $hierarchy_data =~ s/\<\/root>//;
  $xml_output .= "$hierarchy_data";
  #$xml->characters($hierarchy_data);
  $xml->endTag();
  #------------------------------------------------------------#
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= " ";
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "";
  $xml->endTag();
  $xml->end();
  print "$xml_output\n" if($PRINT_XML == 1);
  return ($xml_output);
  }#else
}#sub report_design_xml
#--------------------------------------------------------------#
sub report_netlist_qor {
my $no_of_Arguments = @_;
if($no_of_Arguments < 0 || $_[0] eq "-h"){print "Usage : report_netlist_qor\n";
                                          print "      : --black_box\n";
                                          print "      : --empty_module\n";
                                          print "      : --pin_dir\n";
                                          print "      : --timing_model\n";
                                          print "      : --unclocked_flops\n";
                                          print "      : --flt_unconn_ports\n";
                                          print "      : --multi_driver_nets\n";
                                          print "      : --zero_driver_nets\n";
                                          print "      : --zero_pin_net\n";
                                          print "      : --one_pin_net\n";
                                          print "      : --tiehi_tielo_conn\n";
                                          print "      : --high_fannout\n";
                                          print "      : --net_data\n";
                                         }
else {
  my $DEFAULT = 1;
  my $BLACK_BOX = 0;
  my $EMPTY_MODULE = 0;
  my $PIN_DIR = 0;
  my $TIMING_MODEL = 0;
  my $UNCLOCKED_FLOPS = 0;
  my $FLOATING_UNCONN_PORTS = 0;
  my $MULTI_DRIVER_NETS = 0;
  my $ZERO_DRIVER_NETS = 0;
  my $ZERO_SINK_NETS = 0;
  my $ASSIGN_CONN = 0;
  my $ZERO_PIN_NET = 0;
  my $ONE_PIN_NET = 0;
  my $HIGH_FANOUT = 0;
  my $NET_DATA = 0;
  for(my $i=0;$i<$no_of_Arguments;$i++){
    if($_[$i] eq "--black_box"){$BLACK_BOX = 1; $DEFAULT =0;}
    if($_[$i] eq "--empty_module"){$EMPTY_MODULE = 1;$DEFAULT =0;}
    if($_[$i] eq "--pin_dir"){$PIN_DIR = 1;$DEFAULT = 0;}
    if($_[$i] eq "--timing_model"){$TIMING_MODEL = 1;$DEFAULT=0;}
    if($_[$i] eq "--unclocked_flops"){$UNCLOCKED_FLOPS = 1;$DEFAULT=0;}
    if($_[$i] eq "--flt_unconn_ports"){$FLOATING_UNCONN_PORTS = 1;$DEFAULT=0;}
    if($_[$i] eq "--multi_driver_nets"){$MULTI_DRIVER_NETS = 1;$DEFAULT=0;}
    if($_[$i] eq "--zero_driver_nets"){$ZERO_DRIVER_NETS = 1;$DEFAULT=0;}
    if($_[$i] eq "--zero_sink_nets"){$ZERO_SINK_NETS = 1;$DEFAULT=0;}
    if($_[$i] eq "--assign_conn"){$ASSIGN_CONN = 1;$DEFAULT=0;}
    if($_[$i] eq "--zero_pin_net"){$ZERO_PIN_NET = 1;$DEFAULT=0;}
    if($_[$i] eq "--one_pin_net"){$ONE_PIN_NET = 1;$DEFAULT=0;}
    if($_[$i] eq "--tiehi_tielo_conn"){$TIEHI_TIELO_CONN = 1;$DEFAULT=0;}
    if($_[$i] eq "--high_fannout"){$HIGH_FANOUT = 1;$DEFAULT=0;}
    if($_[$i] eq "--net_data"){$NET_DATA = 1;$DEFAULT=0;}
  }
my $xml_output = "";
my $xml = new XML::Writer(OUTPUT => \$xml_output);
my $moduleName = $GLOBAL->dbfGlobalGetTOP;
$xml->startTag("root");
$xml_output .= "\n";
$xml_output .= " ";
$xml->startTag("report_design");
$xml_output .= "\n";
$xml_output .= "  ";
$xml->startTag("design");
$xml_output .= "\n";
$xml_output .= "   ";
$xml->startTag("name");
$xml->characters($moduleName);
$xml->endTag();
#$xml_output .= "\n";
#$xml_output .= "   ";
#-----------------------------------------------------------------------#
if($MULTI_DRIVER_NETS == 1  || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $total_multi_nets = 0;
  foreach my $netName (keys %NETS_ALREADY){
    my @get_data_of_driver_net = &get_multi_driver_net($netName);
    my $multi_data = $#get_data_of_driver_net+1;
    if($multi_data == 4){
      $total_multi_nets++;
    }
  }#foreach 
  $xml->startTag("multi_driver_nets");
  $xml->characters($total_multi_nets);
  $xml->endTag();
}
#-----------------------------------------------------------------------#
if($ZERO_DRIVER_NETS == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $total_zero_nets = 0;
  foreach my $netName (keys %NETS_ALREADY){ 
    my $zero_driver_net = &check_zero_driver_net($netName);
      if($zero_driver_net == 1){
        $total_zero_nets++;
      } 
  }
  $xml->startTag("zero_driver_nets");
  $xml->characters($total_zero_nets);
  $xml->endTag();
}
#------------------------------------------------------------------------#
if($ZERO_SINK_NETS == 1 || $DEFAULT == 1){
 $xml_output .= "\n";
 $xml_output .= "   ";
 my $total_zero_nets = 0;
 foreach my $etName (keys %NETS_ALREADY){
   my $zero_sink_net = &check_zero_sink_net($netName);
     if($zero_sink_net == 1){
       $total_zero_nets++;
     }
 } 
 $xml->startTag("zero_sink_nets");
 $xml->characters($total_zero_nets);
 $xml->endTag();
} 
#------------------------------------------------------------------------#
my ($zero_pin_netCnt,$one_pin_netCnt,$high_fanout_netCnt) = &pin_nets_cnt;
if($ZERO_PIN_NET == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('zero_pin_netCnt');
  $xml->characters($zero_pin_netCnt);
  $xml->endTag();
  #$xml_output .= "\n";
  #$xml_output .= "    ";
}
#------------------------------------------------------------------------#
if($ONE_PIN_NET == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('one_pin_netCnt');
  $xml->characters($one_pin_netCnt);
  $xml->endTag();
  #$xml_output .= "\n";
  #$xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($HIGH_FANOUT == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('high_fanout_netCnt');
  $xml->characters($high_fanout_netCnt);
  $xml->endTag();
  #$xml_output .= "\n";
  #$xml_output .= "    ";
}
#------------------------------------------------------------------------#
if($FLOATING_UNCONN_PORTS == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $portcnt = 0;
  foreach my $portName (keys %PORTS_ALREADY){
    my $unconnected_port = &floating_or_unconnected_port($portName); 
    if($unconnected_port == 1){
      $portcnt++;
    }
  }
  $xml->startTag('floating_or_unconnected');
  $xml->characters($portcnt);
  $xml->endTag();
}
#------------------------------------------------------------------------#
if($UNCLOCKED_FLOPS == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $unclockedFlopsCnt = 0;
  foreach my $instance (keys %COMP_ALREADY){
    my $unclockedFlops = &unclocked_flops($instance);
    if($unclockedFlops == 1){
      $unclockedFlopsCnt++;
    } 
  }
  $xml->startTag('unclocked_flops');
  $xml->characters($unclockedFlopsCnt);
  $xml->endTag();
}
#------------------------------------------------------------------------#
if($BLACK_BOX == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $blackbox_cnt = 0;
  foreach my $module (keys %MODULE_ALREADY){
    my $black_box = &check_black_box($module); 
    if($black_box == 1){
      $blackbox_cnt++; 
    }
  }
  $xml->startTag('total_black_box');
  $xml->characters($blackbox_cnt);
  $xml->endTag();
  #$xml_output .= "\n";
  #$xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($EMPTY_MODULE == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $empty_module_cnt = 0;
  foreach my $module (keys %MODULE_ALREADY){
    my $empty_module = &check_empty_module($module);
    if( $empty_module == 1){
      $empty_module_cnt++;
    }
  }
  $xml->startTag('total_empty_module');
  $xml->characters($empty_module_cnt);
  $xml->endTag();
#  $xml_output .= "\n";
#  $xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($TIMING_MODEL == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $cell_cnt = 0;
  (%CELL_TIMING_RISE_DATA) = &check_timing_models($instance);
  foreach my $cell (keys %CELL_TIMING_RISE_DATA){
    my $timing_data = $CELL_TIMING_RISE_DATA{$cell};
    if($timing_data == 0){
      $cell_cnt++; 
    }
  }
  $xml->startTag('total_cells_without_timing_modles');
  $xml->characters($cell_cnt);
  $xml->endTag();
}
#------------------------------------------------------------------------#
if($PIN_DIR == 1 || $DEFAULT == 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my $netcnt_correct = 0;
  my %CHECKCONN = ();
  foreach my $net (keys %NETS_ALREADY){
    my $check_conn = &check_pin_direction($net);
    if($check_conn eq "correct"){
      $netcnt_correct++;
    }
  }
  $CHECKCONN{$netcnt_correct} = "correct";
  foreach my $cnt (keys %CHECKCONN){
    $xml->startTag('check_conn','total_net' => $cnt,'status' => $CHECKCONN{$cnt});
    $xml->endTag();
  }
  #$xml_output .= "\n";
  #$xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($TIEHI_TIELO_CONN == 1 || $DEFAULT== 1){
  $xml_output .= "\n";
  $xml_output .= "   ";
  my @conn_list = &check_tiehi_tielo_conn;
  my $number_of_conn = @conn_list;
  $xml->startTag('tiehi_tielo');
  $xml->characters($number_of_conn);
  $xml->endTag();
}
#-----------------------------------------------------------------------#
if($NET_DATA == 1 || $DEFAULT == 1){
  #$xml_output .= "\n";
  #$xml_output .= "   ";
  my %NET_HASH = &dbaReportNetWithNPins("--summary");
  my @sorted = sort{$a <=> $b} keys %NET_HASH;
  my @numnets = ();
  foreach my $srt (@sorted){
   my $nl = $NET_HASH{$srt};
   push (@numnets,$nl);
  }
  for (my $k=0; $k<@sorted;$k++){
    my $num_pin = $sorted[$k];
    $xml_output .= "\n";
    $xml_output .= "    ";
    $xml->startTag('net_data','num_of_pins' => $num_pin,'num_of_nets' => $numnets[$k]);
    $xml->endTag();
    #print "$num_pin => $numnets[$k]\n";
  }#for
#$xml_output .= "\n";
#$xml_output .= "    ";
}
#------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "  ";
$xml->endTag("design");
$xml_output .= "\n";
$xml_output .= " ";
$xml->endTag("report_design");
$xml_output .= "\n";
$xml_output .= "";
$xml->endTag("root");
$xml->end();
print "$xml_output\n";
}#else
}#sub report_netlist_qor
#------------------------------------------------------------------------#
sub pin_nets_cnt {
my $one_pin_netCnt = 0;
my $zero_pin_netCnt = 0;
my $high_fanout_netCnt = 0;
foreach my $netName (keys %NETS_ALREADY){
   my $netType = 0;
   if ( exists $NADB{$netName} ) {$netType = $NADB{$netName}->dbNadbGetNetType;}
     if ( $netType == 0 ) { 
      @driver = &get_multi_driver_net($netName);
      my $noOfComponentsConnected = keys %{$NETS_ALREADY{$netName}};
      if($noOfComponentsConnected == 0){
        $zero_pin_netCnt++;
      }elsif($noOfComponentsConnected == 1){
        $one_pin_netCnt++;
      }elsif($noOfComponentsConnected > 100){
        $high_fanout_netCnt++;
        $high_fanout = 1; 
      }
    }
}
return ($zero_pin_netCnt,$one_pin_netCnt,$high_fanout_netCnt);
}#sub pin_nets_cnt
#------------------------------------------------------------------------#
sub get_multi_driver_net {
my $netName = $_[0];
my @driverList = ();
if(exists $NETS_ALREADY{$netName}){
  foreach my $instance (keys %{$NETS_ALREADY{$netName}}){
    if (exists $COMP_ALREADY{$instance}){
      my $cellref = $CADB{$instance}->dbCadbGetCellref;
      if(exists $PLDB{$cellref}){
        my @pins = $PLDB{$cellref}->dbMdbGetPins;
        foreach my $pinName (@pins){
          my $conn_net = $COMP_ALREADY{$instance}{$pinName};
          if($conn_net eq $netName){
            my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName);
            my $pinDir  = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
            if($pinType == 0 && $pinDir == 1){
              $driverInst = $instance;
              push(@driverList,$driverInst); 
              push(@driverList,$pinName);
              return (@driverList);
            }
          }#if conn_net
        }#foreach pin
      }#if exists PLDB
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
      foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if($netName eq $port_nets[0]){
          my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
          if($dir eq "input"){
            $driverInst = $port;
            push(@driverList,$driverInst);
            push(@driverList,"PIN");
            return (@driverList);
          }
        }
      }
    }elsif($instance eq "PIN"){
      foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if($netName eq $port_nets[0]){
          my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
          if($dir eq "input"){
            $driverInst = $port;
  	    push(@driverList,$driverInst); 
  	    push(@driverList,"PIN");
  	    return(@driverList); 
          }
        }
      }
    }else {
      print "ERR : connecting instance is unknown type\n";
    }
  }#foreach
}else{
  print "ERR : net $netName does not exist in the database\n";
}
}#sub get_multi_driver_net
#------------------------------------------------------------------------#
sub get_zero_sink_inst {
my $netName = $_[0];
my @zero_sinkList = (); 
if(exists $NETS_ALREADY{$netName}){
  foreach my $instance (keys %{$NETS_ALREADY{$netName}}){
    if(exists $COMP_ALREADY{$instance}){
      my $cellref = $CADB{$instance}->dbCadbGetCellref;
      my @pins = $PLDB{$cellref}->dbMdbGetPins;
      foreach my $pinName (@pins){
        my $conn_net = $COMP_ALREADY{$instance}{$pinName};
        if($conn_net eq $netName){
          my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName); 
          my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
        }
      } 
    }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
      foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if($netName eq $port_nets[0]){
          my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
          if($dir eq "output"){
            push(@zero_sinkList,$port);
            push(@zero_sinkList,"PIN");
            return(@zero_sinkList);
          }
        }
      }  
    }elsif($instance eq "PIN"){
      foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
        if($netName eq $port_nets[0]){
          my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
          if($dir eq "output"){
            push(@zero_sinkList,$port);
            push(@zero_sinkList,"PIN");
            return(@zero_sinkList);
          }
        }
      }
    }else{
      print "ERR : connecting instance is unknown type\n";
    }
  }
}else {print "ERR : net $netName does not exist in the database\n";  
}
}#sub get_zero_sink_inst
#------------------------------------------------------------------------#
sub floating_or_unconnected_port {
my $portName = $_[0];
my $unconnected_port = 0;
if(exists $PORTS_ALREADY{$TOP_MODULE}{$portName}){
  my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$portName}->dbPortGetConn;
  if($portName eq $port_nets[0]){
    if(!exists $NETS_ALREADY{$portName}){
     $unconnected_port = 1;
     return ($unconnected_port);
    }
  }elsif($portName ne $port_nets[0]){
     $unconnected_port = 1;
     return ($unconnected_port);
  }
  if($port_nets eq ""){
     $unconnected_port = 1;
     return ($unconnected_port);
  }
}
}#sub floating_or_unconnected_port
#------------------------------------------------------------------------#
sub unclocked_flops {
my $instance = $_[0];
my $unclockedFlops = 0;
if(exists $COMP_ALREADY{$instance}){
  my $conn_net = "";
  my $cellName = $CADB{$instance}->dbCadbGetCellref;
  if(exists $PLDB{$cellName}){
    my @pins = $PLDB{$cellName}->dbMdbGetPins;
    foreach my $pinName (@pins){
      my $pinType = $PLDB{$cellName}->dbMdbGetPinType($pinName);
      if($pinType == 3){
         $conn_net = $COMP_ALREADY{$instance}{$pinName};
      }
    }
  }
  if($conn_net eq ""){
    $unclockedFlops = 1;
    return($unclockedFlops);
  }
}
}#sub unclocked_flops
#------------------------------------------------------------------------#
sub check_black_box {
my $instance = $_[0];
my $black_box = 0;
my $class = $MODULE_ALREADY{$instance}->dbVNOMGetClass;
if ($class == 11){
  $black_box = 1;
  return($black_box);
}
}#sub check_black_box
#------------------------------------------------------------------------#
sub check_empty_module {
my $module = $_[0];
my $empty_module = 0;
if(exists $MODULE_ALREADY{$module}){
 my @inPorts = $MODULE_ALREADY{$module}->dbVNOMGetInput;
 my $in = @inPorts;
 my @outPorts = $MODULE_ALREADY{$module}->dbVNOMGetOutput;
 my $out = @outPorts; 
 my @bidiPorts = $MODULE_ALREADY{$module}->dbVNOMGetBidi;
 my $bidi = @bidiPorts;
 if(($in != 0)|| ($out != 0) || ($bidi != 0)){
   my @conn = $MODULE_ALREADY{$module}->dbVNOMGetConn;
   my $number_of_conn = @conn;
   if($number_of_conn == 0){
     $empty_module = 1;
   }
 }
}
return($empty_module);
}#sub check_empty_module
#------------------------------------------------------------------------#
sub check_timing_models {
my %CELL_TIMING_RISE_DATA = ();
foreach my $cell (keys %TLDB){
  my @pins = $TLDB{$cell}->dbTimingLibGetPins; 
  foreach my $pin (@pins){
     my $pinDir = $TLDB{$cell}->dbTimingLibGetPinDir($pin);
     if($pinDir eq ""){next;}
     if($pinDir eq "output"){
       my $pinFunc = $TLDB{$cell}->dbTimingLibGetPinFunc($pin);
       my @reltdPins = $TLDB{$cell}->dbTimingLibGetPinRPin($pin);
       foreach my $reltdPin(@reltdPins){
         my @conds = $TLDB{$cell}->dbTimingLibGetPinCond($pin,$reltdPin);
         push (@conds, "NONE");
         foreach my $condition (@conds){
           my @cellRiseIndexVal = $TLDB{$cell}->dbTimingLibGetPinDelayIndex($pin,$reltdPin,$condition,"riseDelay");
           my @cellRiseDelayVal = $TLDB{$cell}->dbTimingLibGetPinDelay($pin,$reltdPin,$condition,"riseDelay");
           my @cellFallIndexVal = $TLDB{$cell}->dbTimingLibGetPinDelayIndex($pin,$reltdPin,$condition,"fallDelay");
           my @cellFallDelayVal = $TLDB{$cell}->dbTimingLibGetPinDelay($pin,$reltdPin,$condition,"fallDelay");
           $CELL_TIMING_RISE_DATA{$cell} = @cellRiseDelayVal;
         }
       }
     }
   }
}
return(%CELL_TIMING_RISE_DATA);
}#sub check_timing_models
#------------------------------------------------------------------------#
sub check_pin_direction {
my $net = $_[0];
my $pindirection_of_driver_is_correct = 0;
my $pindirection_of_sink_is_correct = 0;
my @driverInst = &getNetDriver($net);
my @sinkInst = &getNetSink($net);
if ($driverInst[0] eq "UND" ){
}elsif ( $driverInst[0] eq ""){
}else {
   my $driverinst = $driverInst[0];
   my $driverpin = $driverInst[1];
   if (exists $COMP_ALREADY{$driverinst}){
     my $cellref = $CADB{$driverinst}->dbCadbGetCellref; 
     if(exists $PLDB{$cellref}){
       my @pins = $PLDB{$cellref}->dbMdbGetPins;
       foreach my $pinName (@pins){
         if($driverpin eq $pinName){
           my $pinType = $PLDB{$cellref}->dbMdbGetPinType($driverpin);
           my $pinDir  = $PLDB{$cellref}->dbMdbGetPinDir($driverpin);
           if($pinType == 0 && $pinDir == 1){
             $pindirection_of_driver_is_correct = 1;
           }  
         }
       }
     }
   }
}
for(my $i = 0;$i<=$#sinkInst;$i=$i+2){
  my $sinkinst = $sinkInst[$i]; 
  my $sinkpin =  $sinkInst[$i+1];
  if (exists $COMP_ALREADY{$sinkinst}){
    my $cellref = $CADB{$sinkinst}->dbCadbGetCellref;
    if(exists $PLDB{$cellref}){
       my @pins = $PLDB{$cellref}->dbMdbGetPins;
       foreach my $pinName (@pins){
         if($sinkpin eq $pinName){
           my $pinType = $PLDB{$cellref}->dbMdbGetPinType($sinkpin);  
           my $pinDir  = $PLDB{$cellref}->dbMdbGetPinDir($sinkpin);
           if(($pinType == 0) || ($pinType == 3) && $pinDir == 0){ 
             $pindirection_of_sink_is_correct = 1;
         }
       }
     }
   }
 }
}
if($pindirection_of_driver_is_correct == 1 && $pindirection_of_sink_is_correct == 1){
 return("correct");
}else{
  return("incorrect");
}
}#sub check_pin_direction
#------------------------------------------------------------------------#
sub check_tiehi_tielo_conn {
my @conn_list = ();
foreach my $instance (keys %COMP_ALREADY){
my $cellref = $CADB{$instance}->dbCadbGetCellref; 
  if(exists $PLDB{$cellref}){
    my @pins = $PLDB{$cellref}->dbMdbGetPins;
    my $function = $PLDB{$cellref}->dbMdbGetFunction;
    if(($function eq "tie 1") || ($function eq "tie 0")){
     foreach my $pinName (@pins){
       my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName);
       my $pinDir  = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
       if($pinType == 0 && $pinDir == 1){
          my $conn_net = $COMP_ALREADY{$instance}{$pinName}; 
          push (@conn_list,$conn_net);
       }
     }
   }
 }
}
return(@conn_list);
}#sub check_tiehi_tielo_conn
#------------------------------------------------------------------------#
sub report_lef_qor {
my $no_of_Arguments = @_;
if($no_of_Arguments < 0 || $_[0] eq "-h"){print "Usage : report_lef_qor\n";
                                          print "      : --block\n";
                                          print "      : --std\n";
                                          print "      : --filler\n";
                                          print "      : --single_pin\n";
                                          print "      : --single_hght\n";
                                          print "      : --multi_hght\n";
                                          print "      : --sig_pin_area\n";
                                          print "      : --pin_density\n";
                                          print "      : --pwr_grd_pins\n";
                                          print "      : --average_pin_target_points\n";
                                         }
else {
  my $DEFAULT = 1;
  my $BLOCK = 0;
  my $STD = 0;
  my $FILLER = 0;
  my $SINGLE_HGHT = 0;
  my $MULTI_HGHT = 0;
  my $SIGNAL_PIN_AREA = 0;
  my $POWER_GROUND_PINS = 0;
  my $AVERAGE_PIN_TARGET_POINTS = 0;
  my $MAX_PIN_LAYER = 0;
  for(my $i=0;$i<$no_of_Arguments;$i++){
    if($_[$i] eq "--block"){$BLOCK = 1; $DEFAULT = 0;}
    if($_[$i] eq "--std"){$STD = 1; $DEFAULT = 0;}
    if($_[$i] eq "--filler"){$FILLER = 1; $DEFAULT = 0;}
    if($_[$i] eq "--single_pin"){$SINGLE_PIN = 1; $DEFAULT = 0;}
    if($_[$i] eq "--single_hght"){$SINGLE_HGHT = 1; $DEFAULT = 0;}
    if($_[$i] eq "--multi_hght"){$MULTI_HGHT = 1;$DEFAULT = 0;}
    if($_[$i] eq "--sig_pin_area"){$SIGNAL_PIN_AREA = 1; $DEFAULT = 0;}
    if($_[$i] eq "--pin_density"){$PIN_DENSITY = 1;$DEFAULT = 0;} 
    if($_[$i] eq "--pwr_grd_pins"){$POWER_GROUND_PINS = 1; $DEFAULT = 0;}
    if($_[$i] eq "--average_pin_target_points"){$AVERAGE_PIN_TARGET_POINTS = 1;$DEFAULT = 0;}
    if($_[$i] eq "--max_pin_layer"){$MAX_PIN_LAYER = 1; $DEFAULT = 0;}
  }
my $xml_output = "";
my $xml = new XML::Writer(OUTPUT => \$xml_output);
$xml->startTag("root");
$xml_output .= "\n";
$xml_output .= " ";
$xml->startTag("report_lef");
$xml_output .= "\n";
$xml_output .= "  ";
#------------------------------------------------------------------------#
if($BLOCK == 1 || $DEFAULT == 1){ 
  my $macro_cnt = 0;
  foreach my $cell (keys %PLDB){
    my $class = $PLDB{$cell}->dbMdbGetClass;
    if($class eq "BLOCK" || $class eq "block"){
      $macro_cnt++;
    }
  }
  $xml->startTag("total_block_macro");
  $xml->characters($macro_cnt);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($STD == 1 || $DEFAULT == 1){
  my $stdcell_cnt = 0;
  foreach my $cell (keys %PLDB){
    my $class = $PLDB{$cell}->dbMdbGetClass;  
    if($class eq "CORE" || $class eq "core"){
      $stdcell_cnt++;
    }  
  }
  $xml->startTag("total_std_cells");
  $xml->characters($stdcell_cnt);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($FILLER == 1 || $DEFAULT == 1){
  my $cnt_filler_cells = 0;
  foreach my $cell (keys %PLDB){
    my $filler = &found_filler_cells($cell);
    if($filler == 1){$cnt_filler_cells++}
  }#foreach   
  $xml->startTag("total_filler_cells");
  $xml->characters($cnt_filler_cells);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($SINGLE_PIN == 1 || $DEFAULT == 1){
  my $cnt_single_pin_cells = &get_single_pin_cells;
  $xml->startTag("total_single_pin_cells");
  $xml->characters($cnt_single_pin_cells);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($SINGLE_HGHT == 1 || $DEFAULT == 1){
  my $single_hght_cell = &get_single_hght_cell;
  $xml->startTag("single_hght_cell");
  $xml->characters($single_hght_cell);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($MULTI_HGHT == 1 || $DEFAULT == 1){
  my $multi_hght_cell = &get_multi_hght_cell;
  $xml->startTag("multi_hght_cell");
  $xml->characters($multi_hght_cell);
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "  ";
}
#------------------------------------------------------------------------#
if($SIGNAL_PIN_AREA == 1 || $DEFAULT == 1){
  foreach my $cellref (keys %PLDB){
    my %PIN_AREA_FOREACH_SIGNAL_PIN = &get_pin_area_for_signal_pin($cellref);
    if(%PIN_AREA_FOREACH_SIGNAL_PIN){ 
      $xml->startTag("cellName","name" => $cellref);
      $xml_output .= "\n";
      $xml_output .= "   ";
      foreach my $pin (keys %PIN_AREA_FOREACH_SIGNAL_PIN){
        $xml->startTag("pin","name" => $pin,"area" => $PIN_AREA_FOREACH_SIGNAL_PIN{$pin});
        $xml->endTag();
        $xml_output .= "\n";
        $xml_output .= "   ";
      }
      $xml->endTag();
      $xml_output .= "\n";
      $xml_output .= "  ";
    }
  }
}
#------------------------------------------------------------------------#
if($PIN_DENSITY == 1 || $DEFAULT == 1){ 
  $xml->startTag("pin_density_per_side");
  $xml_output .= "\n";
  $xml_output .= "   ";
  foreach my $cell (keys %PLDB){
    my $class = $PLDB{$cell}->dbMdbGetClass;
    if($class eq "BLOCK" || $class eq "block"){
      my $pin_density = &pin_density_per_side($cell);
      $xml->startTag("cell","name" => $cell , "pin_density" => $pin_density);
      $xml->endTag();
      $xml_output .= "\n";
      $xml_output .= "   ";
    }
  }
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($MAX_PIN_LAYER == 1 || $DEFAULT == 1){
  $xml->startTag("max_pinLayer_foreach_cell");
  $xml_output .= "\n";
  $xml_output .= "   ";
  foreach my $cell (keys %PLDB){
    $xml_output .= " ";
    my (%PIN_LAYER) = &max_pin_layer($cell);
    my $max_pinLayer = "";
    my @number_data = ();
    my %TEMP_PIN_LAYER_CNT_HASH = ();
    foreach my $pin (keys %PIN_LAYER){
      my @val = (split(/\s+/,$PIN_LAYER{$pin})); 
      shift(@val);
      my $number_of_layer = @val;
      push(@number_data,$number_of_layer);
      $TEMP_PIN_LAYER_CNT_HASH{$number_of_layer} = $pin;
    }
      my @sort_number_data = sort {$a <=> $b} @number_data;
      my $max_number = $sort_number_data[-1];
      my $pinName_of_max_number = $TEMP_PIN_LAYER_CNT_HASH{$max_number};
      $xml->startTag("cell","name" => $cell,"max_pinLayer" => "$pinName_of_max_number $max_number"); 
      $xml->endTag();
      $xml_output .= "\n";
      $xml_output .= "   ";
  }
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "   ";
}
#------------------------------------------------------------------------#
if($AVERAGE_PIN_TARGET_POINTS == 1 || $DEFAULT == 1){
  $xml->startTag("average_of_pintarget_points");
  $xml_output .= "\n";
  $xml_output .= "    ";
  foreach my $cellName (keys %PLDB){
    my $average_of_pintarget_points = &pin_target_points($cellName);
    $xml->startTag("cell","name" => $cellName,"average_of_points" => $average_of_pintarget_points); 
    $xml->endTag();
    $xml_output .= "\n";
    $xml_output .= "    ";
  }
  $xml->endTag();
  $xml_output .= "\n";
  $xml_output .= "   ";
}
#------------------------------------------------------------------------#
#$xml->startTag();
#foreach my $cell (keys %PLDB){
#my ($bottom_side_pinCnt,$top_side_pinCnt) = &get_cnt_pinT_and_pinB($cell);
#}
#------------------------------------------------------------------------#
$xml->endTag("report_lef");
$xml_output .= "\n";
$xml_output .= "";
$xml->endTag("root");
$xml->end();
print "$xml_output\n";
}
}#sub report_lef_qor
#------------------------------------------------------------------------#
sub found_filler_cells {
my $cell = $_[0];
my $filler = 0;
my @pins = $PLDB{$cell}->dbMdbGetPins; 
if(@pins == 2){
  foreach my $pin (@pins){
    my $type = $PLDB{$cell}->dbMdbGetPinType($pin);
    if ( ($type == 1) || ($type == 2)) {$filler = 1; }
  }#foreach
}
return ($filler);
}#sub found_filler_cells
#------------------------------------------------------------------------#
sub get_single_pin_cells {
my $cnt_single_pins_cells = 0;
foreach my $cell (keys %PLDB){
  my @pins = $PLDB{$cell}->dbMdbGetPins; 
  my $number_of_pins = @pins;
  if($number_of_pins == 3){
    $cnt_single_pins_cells++;
  }
}
return($cnt_single_pins_cells);
}#sub get_single_pin_cells
#------------------------------------------------------------------------#
sub get_multi_hght_cell {
my $row_height = $GLOBAL->dbGlobalGetRowHeight;
my $multi_hght_cell = 0;
foreach my $cell (keys %PLDB){
  my @cellsize = $PLDB{$cell}->dbMdbGetSize;
  my $class = $PLDB{$cell}->dbMdbGetClass; 
  my $width = $cellsize[0];
  my $height = $cellsize[1]; 
  if(($class eq "BLOCK") || ($class eq "block")){ 
    my $value = $height/$row_height; 
    if($value =~ /((\d+).(\d+))/){
    }else{
      $multi_hght_cell++;
    }
  } 
}
return($multi_hght_cell);
}#sub get_multi_hght_cell
#------------------------------------------------------------------------#
sub get_pin_area_for_signal_pin {
my $cellref = $_[0];
my %PIN_AREA_FOREACH_SIGNAL_PIN = ();
if(exists $PLDB{$cellref}){
  my @pins = $PLDB{$cellref}->dbMdbGetPins;
  foreach my $pinName (@pins){
    my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName);
    my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
    if($pinType == 0 && $pinDir == 0){
      my $total_pin_area = 0;
      my $rectArea = 0;
      my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
      foreach my $rectLine (@pinRect){
        my($layer,$llx,$lly,$urx,$ury) = (split(/\s+/,$rectLine))[0,2,3,4,5];
        my $x_dis = ($urx - $llx);
        my $y_dis = ($ury - $lly);
        $rectArea = ($x_dis*$y_dis);
        $total_pin_area = $total_pin_area + $rectArea;
        my $new_total_pin_area = sprintf("%.4f",$total_pin_area);
        $PIN_AREA_FOREACH_SIGNAL_PIN{$pinName} = $new_total_pin_area;
      }
    } 
  }
}
return(%PIN_AREA_FOREACH_SIGNAL_PIN);
}#sub get_pin_area_for_signal_pin
#------------------------------------------------------------------------#
sub max_pin_layer {
my $cellref = $_[0];
my %PIN_LAYER = ();
if(exists $PLDB{$cellref}){
  my @pins = $PLDB{$cellref}->dbMdbGetPins;
  foreach my $pinName (@pins){
    my @pinRect = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
    my %TEMP_LAYER_HASH = ();
    my $data = "";
    foreach my $rectLine (@pinRect){
      my $layer = (split(/\s+/,$rectLine))[0];
      $TEMP_LAYER_HASH{$layer} = 1;
    }
    foreach my $lyr (keys %TEMP_LAYER_HASH){
      $data = $data." ".$lyr;
    }
      $PIN_LAYER{$pinName} = $data;
  }
}
return(%PIN_LAYER);
}#sub max_pin_layer
#------------------------------------------------------------------------#
sub pin_density_per_side {
my $cellref = $_[0];
my $pin_density = "";
if(exists $PLDB{$cellref}){
  my $class = $PLDB{$cellref}->dbMdbGetClass;
  if($class eq "BLOCK" || $class eq "block"){
    my @size = $PLDB{$cellref}->dbMdbGetSize;
    my $width = $size[0];
    my $length = $size[1];
    my @pins = $PLDB{$cellref}->dbMdbGetPins; 
    my $number_of_pins = @pins; 
    my $pindensity = $number_of_pins/$length; 
    $pin_density = sprintf("%.4f",$pindensity);
  } 
}
return($pin_density);
}#sub pin_density_per_side 
#------------------------------------------------------------------------#
sub pin_target_points {
my $cellName = $_[0];
my $average_of_pintarget_points = "";
my ($COVERED_POINTS_of_PIN,$SHARED_POINTS_of_PIN,$EMPTY_POINTS_of_PIN,$BLOCKED_POINTS_of_PIN) = &pinPoints($cellName);
my %COVERED_POINTS_OF_PIN = %$COVERED_POINTS_of_PIN;
my %SHARED_POINTS_OF_PIN = %$SHARED_POINTS_of_PIN;
my %EMPTY_POINTS_OF_PIN = %$EMPTY_POINTS_of_PIN;
my %BLOCKED_POINTS_OF_PIN = %$BLOCKED_POINTS_of_PIN;
my @pins = $PLDB{$cellName}->dbMdbGetPins;
my $total_covered_point = 0;
my $pinCnt = 0;
foreach my $pinName (@pins){
  if($pinName eq "VDD" || $pinName eq "VSS"){}
  else {
    $pinCnt++; 
    my @covered_point = @{$COVERED_POINTS_OF_PIN{$pinName}};
    my %cunique = ();
    foreach my $c (@covered_point){
     $cunique{$c} = 1;
    }
    my @cov_uniq = keys %cunique;
    my $no_ofcovered_point = @cov_uniq;
    $total_covered_point = $total_covered_point + $no_ofcovered_point; 
  }
}
if($pinCnt != 0 ){
my $average_of_pin_target_points = $total_covered_point/$pinCnt;
$average_of_pintarget_points = sprintf("%.4f",$average_of_pin_target_points);
}
return($average_of_pintarget_points);
}#sub pin_target_points 
#------------------------------------------------------------------------#
sub check_zero_driver_net {
my $netName = $_[0];
my %NET_TEMP = ();
my $pin_data = "";
my $get_net_zero_driver = 0;
if(exists $NETS_ALREADY{$netName}){
  my $netType = 0;
  if ( exists $NADB{$netName} ) {$netType = $NADB{$netName}->dbNadbGetNetType;}
  if ( $netType == 0 ) { 
    foreach my $instance (keys %{$NETS_ALREADY{$netName}}){
      if(exists $COMP_ALREADY{$instance}){
        my $cellref = $CADB{$instance}->dbCadbGetCellref;
        if(exists $PLDB{$cellref}){
          my @pins = $PLDB{$cellref}->dbMdbGetPins;
          foreach my $pinName (@pins){
            my $conn_net = $COMP_ALREADY{$instance}{$pinName};
            if($conn_net eq $netName){
              my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName);
              my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($pinName);
              if($pinType == 0 && $pinDir == 0){
                 $pin_data = $pin_data."".$pinDir; 
              }elsif($pinType == 0 && $pinDir == 1){
                 $pin_data = $pin_data."".$pinDir; 
              }
            }
          }
        }
      }elsif($instance eq "PIN"){
         foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
           my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
           if($netName eq $port_nets[0]){
             my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
             if($dir eq "output"){
               $pin_data = $pin_data."".0;
             }elsif($dir eq "input"){
               $pin_data = $pin_data."".1;
             } 
           }
         }
      }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
         foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
           my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
           if($netName eq $port_nets[0]){
             my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
             if($dir eq "output"){
               $pin_data = $pin_data."".0;
             }elsif($dir eq "input"){
               $pin_data = $pin_data."".1;
             }
           }
         } 
      }else {
        print "ERR : connecting instance is unknown type\n";
      }
    }#foreach
  }#if
$NET_TEMP{$netName} = $pin_data;
foreach my $netName (keys %NET_TEMP){
   my $vl = $NET_TEMP{$netName};
#   print "$netName $vl\n";
    if($vl !~ /1/){$get_net_zero_driver = 1;}
}
return($get_net_zero_driver);
}else {
  print "ERR : net $netName does not exist in the database\n";
}
}#sub check_zero_driver_net
#------------------------------------------------------------------------#
sub get_single_hght_cell {
my $row_height = $GLOBAL->dbGlobalGetRowHeight;
my $single_hght_cell = 0;
foreach my $cell (keys %PLDB){
  my @cellsize = $PLDB{$cell}->dbMdbGetSize;
  my $class = $PLDB{$cell}->dbMdbGetClass; 
  my $width = $cellsize[0];
  my $height = $cellsize[1];  
  if(($class eq "CORE") || ($class eq "core")){
    if($height == $row_height){
      $single_hght_cell++;
    }
  }
}
return($single_hght_cell);
}#sub get_single_hght_cell
#------------------------------------------------------------------------#
sub check_zero_sink_net {
my $netName = $_[0];
my %NET_TEMP = ();
my $pin_data = "";
my $get_net_zero_sink = 0;
if(exists $NETS_ALREADY{$netName}){
  my $netType = 0;
  if ( exists $NADB{$netName} ) {$netType = $NADB{$netName}->dbNadbGetNetType;}
  if ( $netType == 0 ) { 
    foreach my $instance (keys %{$NETS_ALREADY{$netName}}){
      if(exists $COMP_ALREADY{$instance}){
        my $cellref = $CADB{$instance}->dbCadbGetCellref;
        if(exists $PLDB{$cellref}){
          my @pins = $PLDB{$cellref}->dbMdbGetPins;
          foreach my $pinName (@pins){
            my $conn_net = $COMP_ALREADY{$instance}{$pinName};
            if($conn_net eq $netName){
              my $pinType = $PLDB{$cellref}->dbMdbGetPinType($pinName);
              my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($piName);
              if($pinType == 0 && $pinDir == 0){
                $pin_data = $pin_data."".$pinDir;
              }elsif($pinType == 0 && $pinDir == 1){
                $pin_data = $pin_data."".$pinDir;
              }
            }
          }
        }
      }elsif($instance eq "PIN"){
         foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
           my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
           if($netName eq $port_nets[0]){
             my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
             if($dir eq "output"){
               $pin_data = $pin_data."".0;
             }elsif($dir eq "input"){
               $pin_data = $pin_data."".1;
             }
           }
         }
      }elsif(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
        foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
          my @port_nets = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetConn;
          if($netName eq $port_nets[0]){
            my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir;
            if($dir eq "output"){
              $pin_data = $pin_data."".0;
            }elsif($dir eq "input"){
              $pin_data = $pin_data."".1;
            }
          }
        }
      }else {
         print "ERR : connecting instance is unknown type\n";
      }
    }#foreach 
  }#if 
$NET_TEMP{$netName} = $pin_data;
foreach my $netName (keys %NET_TEMP){
  my $vl = $NET_TEMP{$netName};
  if($vl !~ /0/){$get_net_zero_sink = 1;}
}
return($get_net_zero_sink);
}else {
  print "ERR : net $netName does not exist in the database\n";
}
}#sub check_zero_sink_net
#------------------------------------------------------------------------#
sub get_def_checker {
my $noOfArguments = @_;
if ($noOfArguments < 0 || $_[0] eq "-h") {print "\n";
                                         }
else {
  for(my $i =0; $i < $noOfArguments; $i++){
  }#for
my $TOTAL_WL = 0;
open(WRITE_CHECK,">Def_checker.rpt");
print WRITE_CHECK "Components Section\n";
my @inst_status = &get_inst;
foreach my $inst_fixed (@inst_status[0]){
  my $get_number_of_fixed = @$inst_fixed;
  print WRITE_CHECK "\tnumber of fixed instnaces = $get_number_of_fixed\n";
} 
foreach my $inst_placed (@inst_status[1]){
  my $get_number_of_placed = @$inst_placed;
  print WRITE_CHECK "\tnumber of placed instances = $get_number_of_placed\n"; 
}
foreach my $inst_unplaced (@inst_status[2]){
  my $get_number_of_unplaced = @$inst_unplaced;
  print WRITE_CHECK "\tnumber of unplaced instances = $get_number_of_unplaced\n";
}
#-------------------------------------------------------------------------------------------------#
print WRITE_CHECK "Nets Section\n";
my ($zero_pin_net,$one_pin_net,$high_fanout) = &pin_nets_cnt;
    print WRITE_CHECK "\tnumber of zero pin net = $zero_pin_net\n";
    print WRITE_CHECK "\tnumber of one pin net = $one_pin_net\n";
#-------------------------------------------------------------------------------------------------#
my $dbu = $GLOBAL->dbfGlobalGetDBU;
foreach my $nets (keys %NETS_ALREADY){
  my $get_wl = &get_net_length_by_manhattan($nets);
  my $wl_micron = $get_wl/$dbu;
  $TOTAL_WL = $TOTAL_WL + $get_wl;
}
my $total_wl_micron = $TOTAL_WL/$dbu;
my $total_wire_length = sprintf("%.2f",$total_wl_micron);
print WRITE_CHECK "\tTotal wire length = $total_wire_length micron\n";
#--------------------------------------------------------------------------------------------------#
my ($binsize,$netsarray) = &net_vs_pin;
print WRITE_CHECK "pin_vs_net_distribution\n";
print WRITE_CHECK "\trange => number of nets\n"; 
my @netsarray_new = @$netsarray; 
for(my $w=0; $w<=$#netsarray_new;$w++){
  my $range = $binsize*$w."-".$binsize*($w+1);
  my $num_of_nets;
  $num_of_nets = $netsarray_new[$w];
  if($netsarray_new[$w] eq ""){$num_of_nets = 0;}
  print  WRITE_CHECK "\t$range => $num_of_nets\n";
}
print WRITE_CHECK "Rotuing WL in each Layer\n";
print WRITE_CHECK "\tNetName => \tLayerName => \tLayer Length\n";
foreach my $nets (keys %NETS_ALREADY){
  if(exists $NETS_ROUTING_ALREADY{$nets}){
    my %get_layer_vs_wl = &get_net_length_by_layer($nets);
    if(%get_layer_vs_wl){
      my @layer = sort {$a cmp $b} keys %get_layer_vs_wl;
      my @total_wire_length = ();
      foreach my $lyr (@layer){
        my $layer_wl = $get_layer_vs_wl{$lyr};
        push(@total_wire_length,$layer_wl);
      }
      my $layer_data = join",",@layer;
      my $data_total = join", ",@total_wire_length;
      print WRITE_CHECK "\t$nets => \t$layer_data => \t$data_total\n";
    }
  }
}
close(WRITE_CHECK);
}#else
}#sub get_def_checker
#------------------------------------------------------------------------#

sub report_routing_channel{
format RCHAN_TOP =
 ____________________________________________________________________________
| Component        |       Pin    | Horizontal Channels  | Vertical Channels |
|__________________|______________|______________________|___________________|
.
 my $numOfARG = @_;
 if($numOfARG < 0 || $_[0] eq "-h"){ 
    print "Usage : report_routing_channel -out <report file name>\n";
 }else{ 
    my $report_file = "routing_channel_report.txt";
    my $display = 0;
    for(my $i=0; $i<$numOfARG; $i++){
        if($_[$i] eq "-out"){$report_file = $_[$i+1];}
        if($_[$i] eq "--display"){$display = 1;}
    }
    open(RCHAN,">$report_file") or die "Can't open up myfile: $!\n";
    my $horizontal_pitch = &get_pitch_for_track("HORIZONTAL");
    my $vertical_pitch = &get_pitch_for_track("VERTICAL");
    my $dbu = $GLOBAL->dbfGlobalGetDBU;
    my $MICRONFACTOR = $GLOBAL->dbGlobalGetMicronFactor;
    my $MulFactor = $MICRONFACTOR/$dbu;

    #print "Horizontal pitch is $horizontal_pitch | Vertical pitch is $vertical_pitch\n";
    $horizontal_pitch = $horizontal_pitch*$dbu; 
    $vertical_pitch = $vertical_pitch*$dbu; 
    if(exists $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}){
       my @size = $FLOORPLAN_ALREADY{$FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}}->dbFlplanGetSize;
       my $chip_width = $size[2] - $size[0];
       my $chip_height = $size[3] - $size[1];
       my $num_hor_channels = $chip_height/$horizontal_pitch;
       my $num_ver_channels = $chip_width/$vertical_pitch;
       ##################################################### gui code to display grid ###########################################################
       if($display == 1){
          for(my $j=0; $j<=$num_hor_channels; $j++){
              my $yy = $horizontal_pitch/2+ $horizontal_pitch*$j; 
              $design_worldcanvas->createLine(20,20+$yy*$MulFactor,20+$size[2]*$MulFactor,20+$yy*$MulFactor, -fill => "pink");
          }
          for(my $j=0; $j<=$num_ver_channels; $j++){
              my $xx = $vertical_pitch/2+ $vertical_pitch*$j; 
              $design_worldcanvas->createLine(20+$xx*$MulFactor,20+$size[1]*$MulFactor,20+$xx*$MulFactor,20+$size[3]*$MulFactor, -fill => "pink");
          }
       }#if grid display is high
       ##########################################################################################################################################
       if($num_hor_channels != int $num_hor_channels){
          print RCHAN "WARN: distance between top most channel and upper chip boundary is not equal to offset\n";
       } 
       if($num_ver_channels != int $num_ver_channels){
          print RCHAN "WARN: distance between right most channel and right chip boundary is not equal to offset\n";
       } 
       foreach my $inst ( keys %COMP_ALREADY ) {
         #print "inst $inst\n";
         my @location = $CADB{$inst}->dbCadbGetLoc;
         my $orient =   $CADB{$inst}->dbCadbGetOrient;
         my $cellref =  $CADB{$inst}->dbCadbGetCellref;
         my @cellSize = $PLDB{$cellref}->dbMdbGetSize;
         my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
         my @pins = $PLDB{$cellref}->dbMdbGetPins;
          #print "cell size @cellSize\n";
         if(($cellSize[0]*$dbu/$vertical_pitch) != int($cellSize[0]*$dbu/$vertical_pitch)){
             print RCHAN "WARN: width of instance is not multiple of vertical pitch\n";
         }
         if(($cellSize[1]*$dbu/$horizontal_pitch) != int($cellSize[1]*$dbu/$horizontal_pitch)){
             print RCHAN "WARN: height of instance is not multiple of horizontal pitch\n";
         }
         foreach my $pinName ( @pins ) {
           #print "pin $pinName\n";
            my $horizontal_channels = 0;
            my $vertical_channels = 0;
            my %HChanTemp = ();
            my %VChanTemp = ();

            my @RECTS = $PLDB{$cellref}->dbMdbGetPinRect($pinName);
            my @POLY = $PLDB{$cellref}->dbMdbGetPinPolygon($pinName);
            foreach my $rectLine ( @RECTS ) {
              my ($layer, $rllx1, $rlly1, $rurx1, $rury1)=(split(/\s+/,$rectLine))[0,2,3,4,5];
              my @pinRect = &xformCellPinToInstPin($location[0],$location[1],$cellOrigin[0], $cellOrigin[1],$orient,$cellSize[0],$cellSize[1],$rllx1,$rlly1,$rurx1,$rury1);
              #print "pinrect @pinRect\n";
              my $max_hor_ch = (($pinRect[3] - $size[1]) - $horizontal_pitch/2)/$horizontal_pitch;
              my $min_hor_ch = int ((($pinRect[1] - $size[1]) - $horizontal_pitch/2)/$horizontal_pitch + 1);
              if($max_hor_ch != int $max_hor_ch){ $max_hor_ch = int $max_hor_ch + 1;}

              my $max_ver_ch = (($pinRect[2] - $size[0]) - $vertical_pitch/2)/$vertical_pitch;
              my $min_ver_ch =  int ((($pinRect[0] - $size[0]) - $vertical_pitch/2)/$vertical_pitch + 1);
              if($max_ver_ch != int $max_ver_ch){ $max_ver_ch = int $max_ver_ch + 1;}
              #print "max hor $max_hor_ch | min hor $min_hor_ch\n";
              #print "max ver $max_ver_ch | min ver $min_ver_ch\n";

              for($i=$min_hor_ch+1; $i<=$max_hor_ch; $i++){
                  if(!exists $HChanTemp{$i}){
                     $HChanTemp{$i} = 1;
                     $horizontal_channels++;
                  }
              }
              for($i=$min_ver_ch+1; $i<=$max_ver_ch; $i++){
                  if(!exists $VChanTemp{$i}){
                     $VChanTemp{$i} = 1;
                     $vertical_channels++;
                  }
              }
              #print "numHor $horizontal_channels | numVer $vertical_channels\n";

              
            }# for each rectangle
            foreach my $polyLine ( @POLY ) {
              my @x_coords = ();
              my @y_coords = ();
              my @rect_or_polygon = (split(/\s+/,$polyLine));
              my $layer = shift @rect_or_polygon;
              shift @rect_or_polygon;
              my $color = $PTDB{$layer}->dbTechGetLayerColor;
              my @poly = &xformCellPinPolyToInstPin($location[0],$location[1],$cellOrigin[0], $cellOrigin[1],$orient,$cellSize[0],$cellSize[1],@rect_or_polygon);
              for(my $i=0; $i<=$#poly; $i=$i+2){
                  push(@x_coords, $poly[$i]);
                  push(@y_coords, $poly[$i+1]);
              }
              @x_coords = sort{$a<=>$b} @x_coords;
              @y_coords = sort{$a<=>$b} @y_coords;
              my @poly_bbox = ($x_coords[0], $y_coords[0], $x_coords[-1], $y_coords[-1]);

              my $max_hor_ch = (($poly_bbox[3] - $size[1]) - $horizontal_pitch/2)/$horizontal_pitch;
              my $min_hor_ch = int ((($poly_bbox[1] - $size[1]) - $horizontal_pitch/2)/$horizontal_pitch + 1);
              if($max_hor_ch != int $max_hor_ch){ $max_hor_ch = int $max_hor_ch + 1;}

              my $max_ver_ch = (($poly_bbox[2] - $size[0]) - $vertical_pitch/2)/$vertical_pitch;
              my $min_ver_ch =  int ((($poly_bbox[0] - $size[0]) - $vertical_pitch/2)/$vertical_pitch + 1);
              if($max_ver_ch != int $max_ver_ch){ $max_ver_ch = int $max_ver_ch + 1;}

              for($i=$min_hor_ch+1; $i<=$max_hor_ch; $i++){
                  if(!exists $HChanTemp{$i}){
                     $HChanTemp{$i} = 1;
                     $horizontal_channels++;
                  }
              }
              for($i=$min_ver_ch+1; $i<=$max_ver_ch; $i++){
                  if(!exists $VChanTemp{$i}){
                     $VChanTemp{$i} = 1;
                     $vertical_channels++;
                  }
              }
            }#for each polygon
format RCHAN =
@|||||||||||         @|||||||||||    @#####                   @#####  
$inst,               $pinName,       $horizontal_channels,    $vertical_channels,     
.
            write RCHAN;
            #print "instance: $inst    pin: $pinName   horizontal channel: $horizontal_channels   vertical channels: $vertical_channels\n";
            if($horizontal_channels == 0){
               print RCHAN "WARN: No Horizontal channel found for pin $pinName of instance $inst\n"; 
            }  
            if($vertical_channels == 0){
               print RCHAN "WARN: No Verical channel found for pin $pinName of instance $inst\n"; 
            }    
         }#foreach pin
       }#foreach instance
    }#if floorplan exists
    close RCHAN;
 }#if correct arg
}#sub report_routing_channel

#------------------------------------------------------------------------#
sub get_listed_nets {
use Benchmark;
my $t0 = new Benchmark;

my $noOfArguments = @_;
if($noOfArguments < 1 || $_[0] eq "-h"){ print "Usage : get_listed_nets\n";
                                         print "      : -output<fileName>\n";
                                         print "      : -nets<{net1,net2,......}\n"; 
                                         print "      : --all\n";
                                         print "      : --net_connectivity\n";
                                         print "      : --routed_info\n";
                                         print "      : --sp_routed_info\n";
                                         print "      : --layer_vs_length\n";
                                         print "      : --total_wl\n";
                                       }
else {
  my $OUTPUT_FILE;
  my $net_connectivity = 0;
  my $routed_info = 0;
  my $sp_routed_info = 0;
  my $spnet = 0;
  my $DEFAULT = 1;
  my @nets = ();
  my $listed_nets = 0;
  my $layer_vs_length = 0;
  my $total_wire_length = 0;
  for(my $i=0; $i < $noOfArguments;$i++){
    if($_[$i] eq "-output"){$OUTPUT_FILE = $_[$i+1];}
    if($_[$i] eq "--net_connectivity"){$net_connectivity = 1;$DEFAULT = 0;} 
    if($_[$i] eq "--routed_info"){$routed_info = 1;$DEFAULT = 0;}
    if($_[$i] eq "--sp_routed_info"){$sp_routed_info = 1;$DEFAULT = 0;}
    if($_[$i] eq "--layer_vs_length"){$layer_vs_length = 1;$DEFAULT = 0;}
    if($_[$i] eq "--total_wl"){$total_wire_length = 1;$DEFAULT = 0;}
    if($_[$i] eq "--all"){$net_connectivity = 1;
                          $routed_info = 1;
                          $sp_routed_info = 1;
                          $layer_vs_length = 1;
                          $total_wire_length = 1;
                         }
    if($_[$i] eq "-nets"){$listed_nets = 1; 
	                  my $nets = $_[$i+1]; 
	                  $nets =~ s/\{\s*//; 
	                  $nets =~ s/\s*\}//; 
	                  @nets = split(/\,/,$nets);
                          }
  }#for
  open (WRITE_RPT, ">$OUTPUT_FILE");
  print WRITE_RPT "DEF : \n"if($net_connectivity == 1 || $routed_info == 1 || $sp_routed_info == 1 || $DEFAULT == 1);
####################################################net connectivity#################################################
if (@nets == ""){
  my $temp = keys %NETS_ALREADY;
  print WRITE_RPT "NETS $temp \;\n" if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1 );
  foreach my $netName ( keys %NETS_ALREADY){
    print WRITE_RPT "  - $netName\n"if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1 );
    if ($net_connectivity == 1 || $DEFAULT == 1 ) { 
      foreach my $instance ( keys %{$NETS_ALREADY{$netName}} ){
        if ( exists $PORTS_ALREADY{$TOP_MODULE}{$instance} ) { 
          print WRITE_RPT "\t\( PIN $NETS_ALREADY{$netName}{$instance} \)\n";
        }else {
          print WRITE_RPT "\t\( $instance $NETS_ALREADY{$netName}{$instance} \)\n";
        }
      }#for each instance attached
    }#if net_connectivity
################################################routed info###########################################################
    if($routed_info == 1 || $DEFAULT == 1){
      if ( exists $NETS_ROUTING_ALREADY{$netName} ) {
        my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
        if ( @routes > 0 ) {
          my $l1 = shift @routes;
          print WRITE_RPT "\t \+ ROUTED $l1\n";
          foreach my $l ( @routes ) {
            print WRITE_RPT "\t NEW  $l\n";
          }
        }# if routing information exists
        if ( @fixed_routes > 0 ) {
          my $l1 = shift @fixed_routes;
          print WRITE_RPT "\t \+ FIXED $l1\n";
          foreach my $l ( @fixed_routes ) {
            print WRITE_RPT "\t NEW  $l\n";
          }
        }# if routing information exists
      }#if net routing exists
    }# if routed info 
    print WRITE_RPT " \t\;\n"if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1);
  }#foreach net
  print WRITE_RPT "END NETS\n"if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1);
##########################################sp_routed_info#############################################################
  if($sp_routed_info == 1 || $DEFAULT == 1){
    my $spnetCnt = 0; 
    foreach my $netName ( keys %NETS_ALREADY ) { 
      my $netType = 0;
      if ( exists $NADB{$netName} ) { $netType = $NADB{$netName}->dbNadbGetNetType; }
      if ( $netType >= 1 ) { $spnetCnt++ }
    }#foreach
    print WRITE_RPT "SPECIALNETS $spnetCnt \;\n";
    foreach my $netName (keys %NETS_ALREADY){
      my $netType = 0;
      if ( exists $NADB{$netName} ) {$netType = $NADB{$netName}->dbNadbGetNetType;}
      if ($netType == 1 || $netType == 2 ){
        print WRITE_RPT "  - $netName\n";
        if ( exists $NETS_ROUTING_ALREADY{$netName} ) {
          my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetSpecialRoute;
          my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
          if(@routes > 0){
            my $l1 = shift @routes;
            print WRITE_RPT "\t \+ ROUTED $l1\n";
            foreach my $l ( @routes ){
              print WRITE_RPT "\t NEW  $l\n";
            }
          }#if route
          if(@fixed_routes > 0){
            my $l1 = shift @fixed_routes;
            print WRITE_RPT "\t \+ FIXED $l1\n";
            foreach my $l ( @fixed_routes ){
              print WRITE_RPT "\t NEW  $l\n";
            }
          }#if fixed
          if(@routes > 0 || @fixed_routes > 0){
            my $power = $NETS_ROUTING_ALREADY{$netName}->dbNetGetType;
            print WRITE_RPT "\t + USE $power\n" if($power ne "");
            print WRITE_RPT "\t + USE SIGNAL\n" if($power eq "");
          }
        }#if special net routing exists
        print WRITE_RPT " \t\;\n";
      }#if 
    }#foreach netName 
    print WRITE_RPT "END SPECIALNETS\n";
  }#if spnet
#-------------------------------------------------------------------------------------------------------------------#
  print WRITE_RPT "\n"if($layer_vs_length == 1 || $total_wire_length == 1 || $DEFAULT == 1);
  print WRITE_RPT "WIRE LENGTH : \n"if($layer_vs_length == 1 || $total_wire_length == 1 || $DEFAULT == 1);
  if($layer_vs_length == 1 || $DEFAULT == 1){
    my @net_list = keys %NETS_ALREADY;
    my %get_layer_Vs_length = &get_all_net_length_by_layer_without_lef(\@net_list);
    print WRITE_RPT "\tMETAL LAYER WISE LENGTH\n";
    foreach my $layer (sort {$a cmp $b }keys %get_layer_Vs_length){
      my $wl =  $get_layer_Vs_length{$layer};
      print WRITE_RPT "\t\t\t$layer $wl\n";
    }#foreach
  }#if layer_vs_length
#-------------------------------------------------------------------------------------------------------------------#
  if($total_wire_length == 1  || $DEFAULT == 1){
    my $tmhd = 0;
    my @net_list = keys %NETS_ALREADY;
    my %get_layer_Vs_length = &get_all_net_length_by_layer_without_lef(\@net_list);
    foreach my $layer (sort {$a cmp $b }keys %get_layer_Vs_length){
      my $wl =  $get_layer_Vs_length{$layer};
      $tmhd = $tmhd + $wl;
    }#foreach layer
    print WRITE_RPT "\tTotal wire length = $tmhd\n";
  }#if total_wire_length
}#if nets array empty
#------------------------------------listed nets---------------------------------------------------#
if($listed_nets == 1 ){
  my $total_netCnt = @nets;
  print WRITE_RPT "NETS $total_netCnt \;\n" if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1);
  foreach my $netName (@nets){
    print WRITE_RPT "  - $netName\n"if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1);
    if($net_connectivity == 1 || $DEFAULT == 1){
      foreach my $instance ( keys %{$NETS_ALREADY{$netName}} ){
        if ( exists $PORTS_ALREADY{$TOP_MODULE}{$instance} ) { 
          print WRITE_RPT "\t\( PIN $NETS_ALREADY{$netName}{$instance} \)\n";
        }else {
          print WRITE_RPT "\t\( $instance $NETS_ALREADY{$netName}{$instance} \)\n";
        }
      }#foreach instance attached
    }#if net_connectivity
    if($routed_info == 1 || $DEFAULT == 1){
      if ( exists $NETS_ROUTING_ALREADY{$netName} ) {
        my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetRegularRoute;
        my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
        if ( @routes > 0 ) {
          my $l1 = shift @routes;
          print WRITE_RPT "\t \+ ROUTED $l1\n";
          foreach my $l ( @routes ) {
            print WRITE_RPT "\t NEW  $l\n";
          }
        }# if routing information exists
        if ( @fixed_routes > 0 ) {
          my $l1 = shift @fixed_routes;
          print WRITE_RPT "\t \+ FIXED $l1\n";
          foreach my $l ( @fixed_routes ) {
            print WRITE_RPT "\t NEW  $l\n";
          }
        }# if routing information exists
      }#if net routing exists 
      print WRITE_RPT " \t\;\n";
    }#if routed_info 
  }#foreach netName
  print WRITE_RPT "END NETS\n"if($net_connectivity == 1 || $routed_info == 1 || $DEFAULT == 1);
#---------------------------------------------------------------------------------------------#
  if($sp_routed_info == 1 || $DEFAULT == 1){
    my $spnetCnt = 0;
    foreach my $netName (@nets){
      my $netType = 0;
      if ( exists $NADB{$netName} ) { $netType = $NADB{$netName}->dbNadbGetNetType; }
      if ( $netType >= 1 ) { $spnetCnt++; print WRITE_RPT "\t$netName is a special net\n";}
      else { print WRITE_RPT "\t$netName is a regular net\n";}
    }#foreach netName
    print WRITE_RPT "SPECIALNETS $spnetCnt \;\n";
    foreach my $netName (@nets){
      my $netType = 0;
      if ( exists $NADB{$netName} ) {$netType = $NADB{$netName}->dbNadbGetNetType;}
      if ( $netType == 1 || $netType == 2 ) {
        print "INFO-DES : $netName is a special net\n";
        print WRITE_RPT "  - $netName\n";
        if ( exists $NETS_ROUTING_ALREADY{$netName} ) {
          my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetSpecialRoute;
          my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
          if(@routes > 0){
            my $l1 = shift @routes;
            print WRITE_RPT "\t \+ ROUTED $l1\n";
            foreach my $l ( @routes ){
              print WRITE_RPT "\t NEW  $l\n";
            }
          } 
          if(@fixed_routes > 0){
            my $l1 = shift @fixed_routes;
            print WRITE_RPT "\t \+ FIXED $l1\n";
            foreach my $l ( @fixed_routes ){
              print WRITE_RPT "\t NEW  $l\n";
            }
          }
          if(@routes > 0 || @fixed_routes > 0){
            my $power = $NETS_ROUTING_ALREADY{$netName}->dbNetGetType;
              print WRITE_RPT "\t + USE $power\n" if($power ne "");
              print WRITE_RPT "\t + USE SIGNAL\n" if($power eq "");
          }
        }#if special net routing exists
        print WRITE_RPT " \t\;\n";
      }else {
        print "WARN-DES : $netName is a regular net\n";
      } 
    }#foreach
    print WRITE_RPT "END SPECIALNETS\n";
  }#if sp_routed_info
#-----------------------------------------------------------------------------#
  print WRITE_RPT "\n"if($layer_vs_length == 1 || $total_wire_length == 1  || $DEFAULT == 1);
  print WRITE_RPT "WIRE LENGTH : \n"if($layer_vs_length == 1 || $total_wire_length == 1  || $DEFAULT == 1);
  if($layer_vs_length == 1 || $DEFAULT == 1){
    print WRITE_RPT "\tMETAL LAYER WISE LENGTH\n";
    my %get_layer_Vs_length = &get_all_net_length_by_layer_without_lef(\@nets);
    foreach my $layer (sort {$a cmp $b }keys %get_layer_Vs_length){
      my $wl =  $get_layer_Vs_length{$layer};
      print WRITE_RPT "\t\t\t$layer $wl\n";
    }#foreach
  }#if layer_vs_length
  #-----------------------------------------------------------------------------#
  if($total_wire_length == 1  || $DEFAULT == 1){
    my $tmhd = 0;
    my %get_layer_Vs_length = &get_all_net_length_by_layer_without_lef(\@nets);
    foreach my $layer (sort {$a cmp $b }keys %get_layer_Vs_length){
      my $wl =  $get_layer_Vs_length{$layer};
      $tmhd = $tmhd + $wl;
    }#foreach layer
    print WRITE_RPT "\tTotal wire length = $tmhd\n";
  }#if total_wire_length
#-----------------------------------------------------------------------------#
}#if listed 
close(WRITE_RPT);
}#else
my $t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "command get_listed_nets took:",timestr($td),"\n";
}#sub get_listed_nets
#-----------------------------------------------------------------------------#
sub xformNetSegToPathSeg_withoutlef {
my $netSeg = $_[0];
my @routeBox = ();
my $netSegZ = (split(/\s+/,$netSeg))[0];
if ($netSeg =~ m/\( (\d+) (\d+) \) (\w+)/ ) {
  print "DBG-DES : 001 : matched connection to via $3\n" if ($DEBUG);
  return($1,$2,$1,$2);
}# if only via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( (\d+) \* \) (\w+)/ ) {
  print "DBG-DES : 002 : matched horizontal without extn with via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $3;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal without extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( (\d+) \* (\d+) \) (\w)/ ) {
  print "DBG-DES : 003 : matched horizontal R-extn with via $1,$2,$3,$4,$5  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $3+$4;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal R-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( (\d+) \* (\d+) \)/ ) {
  print "DBG-DES : 004 : matched  horizontal R-extn without via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $3+$4;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal R-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) \* \) (\w)/ ) {
  print "DBG-DES : 005 : matched horizontal L-extn with via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1-$3;
  my $lly = $2;
  my $urx = $4;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal L-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) \* \)/ ) {
  print "DBG-DES : 006 : matched horizontal L-extn without via $1,$2,$3,$4 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1-$3;
  my $lly = $2;
  my $urx = $4;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal L-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) \* (\d+) \)/ ) {
  print "DBG-DES : 006 : matched horizontal L-extn and R-extn without via $1,$2,$3,$4,$5 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1-$3;
  my $lly = $2;
  my $urx = $4+$5;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal L-extn and R-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) \* (\d+) \) (\w)/ ) {
  print "DBG-DES : 006 : matched horizontal L-extn and R-extn with via $1,$2,$3,$4,$5 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1-$3;
  my $lly = $2;
  my $urx = $4+$5;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal L-extn and R-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( (\d+) \* \)/ ) {
  print "DBG-DES : 007 : matched horizontal without extn without via  $1,$2,$3 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $3;
  my $ury = $2;
  return($llx,$lly,$urx,$ury);
}# if horizontal without extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( \* (\d+) \) (\w)/ ) {
  print "DBG-DES : 008 : matched verical without extn with via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $1;
  my $ury = $3;
  return($llx,$lly,$urx,$ury);
}# if verical without extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( \* (\d+) (\d+) \) (\w)/ ) {
  print "DBG-DES : 009 : matched verical T-extn with via $1,$2,$3,$4,$5  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $1;
  my $ury = $3+$4;
  return($llx,$lly,$urx,$ury);
}# if verical T-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( \* (\d+) (\d+) \)/ ) {
  print "DBG-DES : 010 : matched  verical T-extn without via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $1;
  my $ury = $3+$4;
  return($llx,$lly,$urx,$ury);
}# if verical T-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( \* (\d+) \) (\w)/ ) {
  print "DBG-DES : 011 : matched verical B-extn with via $1,$2,$3,$4  and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2-$3;
  my $urx = $1;
  my $ury = $4;
  return($llx,$lly,$urx,$ury);
}# if verical B-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( \* (\d+) \)/ ) {
  print "DBG-DES : 012 : matched verical B-extn without via $1,$2,$3,$4 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2-$3;
  my $urx = $1;
  my $ury = $4;
  return($llx,$lly,$urx,$ury);
}# if verical B-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( \* (\d+) (\d+) \)/ ) {
  print "DBG-DES : 012 : matched verical B-extn and T-extn without via $1,$2,$3,$4,$5 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2-$3;
  my $urx = $1;
  my $ury = $4+$5;
  return($llx,$lly,$urx,$ury);
}# if verical B-extn and T-extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( \* (\d+) (\d+) \) (\w)/ ) {
  print "DBG-DES : 012 : matched verical B-extn and T-extn with via $1,$2,$3,$4,$5 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2-$3;
  my $urx = $1;
  my $ury = $4+$5;
  return($llx,$lly,$urx,$ury);
}# if verical B-extn and T-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( \* (\d+) \)/ ) {
  print "DBG-DES : 013 : matched verical without extn without via  $1,$2,$3 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  my $llx = $1;
  my $lly = $2;
  my $urx = $1;
  my $ury = $3;
  return($llx,$lly,$urx,$ury);
}# if verical without extn without via
#--------------------- temporary code to support jspeed routing text -------------------------#
elsif ($netSeg =~ m/\( (\d+) (\d+) \) \( (\d+) (\d+) \)/ ) {
  print "DBG-DES : 014 : jspeed : matched without extn without via  $1,$2,$3,$4 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
  if ( $1 == $3 ) {
    my $llx = $1;
    my $lly = $2;
    my $urx = $3;
    my $ury = $4;
    return($llx,$lly,$urx,$ury);
  }elsif ( $2 == $4 ) {
    my $llx = $1;
    my $lly = $2;
    my $urx = $3;
    my $ury = $4;
    return($llx,$lly,$urx,$ury);
  }
}# if verical without extn without via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) (\d+) (\d+) \)/ ) {
  if($1 == $4){
    print "DBG-DES : 012 : matched verical B-extn and T-extn without via $1,$2,$3,$4,$5,$6 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
    my $llx = $1;
    my $lly = $2-$3;
    my $urx = $4;
    my $ury = $5+$6;
    return($llx,$lly,$urx,$ury);
  }elsif($3 == $6){
    print "DBG-DES : 012 : matched horizontal L-extn and R-extn without via $1,$2,$3,$4,$5,$6 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
    my $llx = $1-$3;
    my $lly = $2;
    my $urx = $4+$6;
    my $ury = $5;
    return($llx,$lly,$urx,$ury);
  }
}# if verical B-extn and T-extn with via
elsif ($netSeg =~ m/\( (\d+) (\d+) (\d+) \) \( (\d+) (\d+) (\d+) \) (\w)/ ) {
  if($1 == $4){
    print "DBG-DES : 012 : matched verical B-extn and T-extn with via $1,$2,$3,$4,$5,$6 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
    my $llx = $1;
    my $lly = $2-$3;
    my $urx = $4;
    my $ury = $5+$6;
    return($llx,$lly,$urx,$ury);
  }elsif($3 == $6){
    print "DBG-DES : 012 : matched horizontal L-extn and R-extn with via $1,$2,$3,$4,$5,$6 and W\=$W $defaultWidth $dbu\n" if ($DEBUG);
    my $llx = $1-$3;
    my $lly = $2;
    my $urx = $4+$6;
    my $ury = $5;
    return($llx,$lly,$urx,$ury);
  }
}# if verical B-extn and T-extn with via
}#sub xformNetSegToPathSeg_withoutlef
#-----------------------------------------------------------------------------#
sub get_net_length_by_layer_without_lef {
my $nets = $_[0];
my %layer_vs_length = ();
my $total_distance = 0;
if(exists $NETS_ROUTING_ALREADY{$nets}){
  my @routes = $NETS_ROUTING_ALREADY{$nets}->dbNetRoutingDBGetRegularRoute;
  foreach my $l (@routes){
    my $routelayer = (split(/\s+/,$l))[0];
    my @routebbox = &xformNetSegToPathSeg_withoutlef($l);
    my $X_distance = $routebbox[2] - $routebbox[0];
    my $Y_distance = $routebbox[3] -$routebbox[1];
    $total_distance = $X_distance + $Y_distance;
    $layer_vs_length{$routelayer} +=  $total_distance;
  }
}
return(%layer_vs_length);
}#sub get_net_length_by_layer_without_lef
#-----------------------------------------------------------------------------#
sub get_all_net_length_by_layer_without_lef {
my @net_list = @{$_[0]};
my %layer_vs_length = ();
my $total_distance = 0;
foreach my $net (@net_list){
  my $netType = 0;
  if(exists  $NADB{$net}){$netType = $NADB{$net}->dbNadbGetNetType;}
  #if($netType == 0){
    if(exists $NETS_ROUTING_ALREADY{$net}){
      my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
      foreach my $l (@routes){
        my $routelayer = (split(/\s+/,$l))[0];
        my @routebbox = &xformNetSegToPathSeg_withoutlef($l);
        my $X_distance = $routebbox[2] - $routebbox[0];
        my $Y_distance = $routebbox[3] -$routebbox[1];
        $total_distance = $X_distance + $Y_distance;
        $layer_vs_length{$routelayer} +=  $total_distance;
      }
    }
  #}
}#foreach net
return(%layer_vs_length);
}#sub get_all_net_length_by_layer_without_lef
#-----------------------------------------------------------------------------#
sub def_split_and_return_in_xml {
use Benchmark;
my $t0 = new Benchmark;

use XML::Writer;

my $no_of_Arguments = @_;
if($no_of_Arguments < 0 || $_[0] eq "-h"){
                                         }
else {
  my $INPUT_DEF_FILE = "";
  my @section_list = ();
  my @netPatt = ();
  my $routed_info = 0;
  for(my $i=0;$i < $no_of_Arguments;$i++){
    if($_[$i] eq "-def"){$INPUT_DEF_FILE = $_[$i+1]; }
    if($_[$i] =~ /--/) {
                        if($_[$i] ne "--routed_info"){
                          push(@section_list, $_[$i]);
                        }if($_[$i] eq "--netName"){
                          my $netList = $_[$i+1];
                          $netList =~ s/{//;
                          $netList =~ s/}//;
                          @netPatt = split(/\,/,$netList);
                        }
                      }
    if($_[$i] eq "--routed_info"){$routed_info = 1;}
  }#for
  my $xml_output = "";
  my $xml = new XML::Writer(OUTPUT => \$xml_output);   
  &read_defII("-def","$INPUT_DEF_FILE","--all");
  $xml->startTag("root");
  $xml_output .= "\n";
  $xml_output .= " ";
  foreach my $section (@section_list){
    $section =~ s/--//;
    if($section eq "pins"){
      $xml->startTag($section);
      $xml_output .= "\n";
      $xml_output .= " ";
      foreach my $pinName (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
        my @netName = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetConn;
        my $dir = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetDir;
        my $signal = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetSignal; 
        my @loc = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetLoc;
        my $status = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetStatus;
        if($status == 0 || $status == 1){
          $xml->startTag('pin','name' => $pinName, 'net' => $netName[0],'direction' => $dir, 'use' => $signal);  
        }elsif($status == 2){
          my $orient = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetSide;
          my $layer = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetLayer;
          my @size = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetSize;
          my $x1 = -$size[0]/2;
          my $x2 = $size[0]/2; 
          $xml->startTag('pin','name' => $pinName, 'net' => $netName[0],'direction' => $dir, 'use' => $signal,
                         'status' => "PLACED",'loc' => "$loc[0] $loc[1]",'orient' => $orient,'layer' => "$layer ($x1 0) ($x2 $size[1])");  
        }elsif($status == 3){
          my $orient = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetSide;
          my $layer = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetLayer;
          my @size = $PORTS_ALREADY{$TOP_MODULE}{$pinName}->dbPortGetSize;
          my $x1 = -$size[0]/2;
          my $x2 = $size[0]/2; 
          $xml->startTag('pin','name' => $pinName, 'net' => $netName[0],'direction' => $dir, 'use' => $signal,
                         'status' => "FIXED",'loc' => "$loc[0] $loc[1]",'orient' => $orient,'layer' => "$layer ($x1 0) ($x2 $size[1])");  
        }
        $xml->endTag();
        $xml_output .= "\n";
        $xml_output .= " ";
      }#foreach
      $xml->endTag($section);
      $xml_output .= "\n";
      $xml_output .= "  ";
    }elsif($section eq "components"){
      $xml->startTag($section);
      $xml_output .= "\n";
      $xml_output .= "  ";
      foreach my $instance (keys %COMP_ALREADY){
        if(exists $CADB{$instance}){
          my $cellref = $CADB{$instance}->dbCadbGetCellref;
          my @loc = $CADB{$instance}->dbCadbGetLoc;
          my $status = $CADB{$instance}->dbCadbGetStatus;
          my $orient = $CADB{$instance}->dbCadbGetOrient;
          $xml->startTag('instance','name' => $instance,'cellref' => $cellref,'loc' => "$loc[0] $loc[1]",'status' => $status, 'orient' => $orient); 
          $xml->endTag();
          $xml_output .= "\n";
          $xml_output .= " ";
        }#if
      }#foreach 
      $xml->endTag($section);
      $xml_output .= "\n";
      $xml_output .= "  ";
    }elsif($section eq "nets"){
      $xml->startTag($section."_"."data");
      $xml_output .= "\n";
      $xml_output .= "   ";
      foreach my $netName (keys %NETS_ALREADY){
        my $netType = 0;
        if(exists $NADB{$netName}){$netType = $NADB{$netName}->dbNadbGetNetType;}  
        if($netType == 0){
          $xml->startTag('net','name' => $netName);
          $xml_output .= "\n";
          $xml_output .= "   ";
          foreach my $instance (keys %{$NETS_ALREADY{$netName}}){
            if(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
              $xml->startTag('inst','name' => "PIN" ,'pin' => $NETS_ALREADY{$netName}{$instance});
              $xml->endTag();
            }else {
              $xml->startTag('inst','name' => $instance,'pin' => $NETS_ALREADY{$netName}{$instance});
              $xml->endTag();
              $xml_output .= "\n";
              $xml_output .= "   ";
            }   
          }#foreach
          if($routed_info == 1){
            if(exists $NETS_ROUTING_ALREADY{$netName}){
              my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetRegularRoute;
              my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
              if(@routes > 0){
                my $l1 = shift @routes;
                $xml->startTag("routed_info");
                $xml_output .= "\n";
                $xml_output .= "    ";
                $xml->characters("ROUTED $l1"); 
                $xml_output .= "\n";
                foreach my $l (@routes){
                  $xml_output .= "    ";
                  $xml->characters("NEW $l");
                  $xml_output .= "\n";
                }#foreach
                  $xml_output .= "   ";
                  $xml->endTag();
              }#if routed
              if(@fixed_routes > 0){
                my $l1 = shift @fixed_routes;
                $xml->startTag("fixed_info");
                $xml_output .= "\n";
                $xml_output .= "    ";
                $xml->characters("FIXED $l1");
                $xml_output .= "\n";
                foreach my $l (@fixed_routes){
                  $xml_output .= "    ";
                  $xml->characters("NEW $l");
                  $xml_output .= "\n";
                }#foreach 
                  $xml_output .= "   ";
                  $xml->endTag();
              }#if fixed 
              $xml_output .= "\n";
            } 
            $xml_output .= "   ";
          }
          $xml->endTag();
          $xml_output .= "\n";
          $xml_output .= "   ";
        }#if netType
        $xml_output .= "";
      }#foreach
      $xml->endTag($section."_"."data");
    }elsif($section eq "specialNets"){
      $xml_output .= "\n";
      $xml_output .= "   ";
      $xml->startTag($section."_"."data");
      $xml_output .= "\n";
      $xml_output .= "   ";
      foreach my $netName (keys %NETS_ALREADY){
        my $netType = 0;
        if(exists $NADB{$netName}){$netType = $NADB{$netName}->dbNadbGetNetType;}
        if($netType == 1 || $netType == 2){
          $xml->startTag('net','name' => $netName);
          $xml_output .= "\n";
          $xml_output .= "   ";
          foreach my $instance ( keys %{$NETS_ALREADY{$netName}}){
            $xml->startTag('inst','name' => $instance,'pin' => $NETS_ALREADY{$netName}{$instance});     
            $xml->endTag();
            $xml_output .= "\n";
            $xml_output .= "   ";
          }#foreach
          if($routed_info == 1){
            if(exists $NETS_ROUTING_ALREADY{$netName}){
              my @routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetSpecialRoute;
              my @fixed_routes = $NETS_ROUTING_ALREADY{$netName}->dbNetRoutingDBGetFixedRoute;
              if(@routes > 0){
                my $l1 = shift @routes;
                $xml->startTag("routed_info");
                $xml_output .= "\n";
                $xml_output .= "    ";
                $xml->characters("ROUTED $l1");
                $xml_output .= "\n";
                foreach my $l (@routes){
                  $xml->characters("NEW $l");
                  $xml_output .= "\n";
                }
                $xml_output .= "   ";
                $xml->endTag();
              }#if routed
              if(@fixed_routes > 0){
                my $l1 = shift @fixed_routes;
                $xml->startTag("fixed_info");
                $xml_output .= "\n";
                $xml_output .= "    ";
                $xml->characters("FIXED $l1");
                $xml_output .= "\n";
                foreach my $l (@fixed_routes){
                  $xml_output .= "    ";
                  $xml->characters("NEW $l");
                  $xml_output .= "\n";
                }#foreach
                $xml_output .= "   ";
                $xml->endTag();
              }#if fixed
              $xml_output .= "\n";
            }
            $xml_output .= "   ";
          }
          $xml->endTag();
          $xml_output .= "\n";
          $xml_output .= "   ";
        }#if netType 1 or 2
        $xml_output .= "";
      }#foreach
      $xml->endTag($section."_"."data");
    }
  }
  foreach my $pat (@netPatt){
    foreach my $net (keys %NETS_ALREADY){
      if($net =~ /$pat/){
        if(exists $NETS_ALREADY{$net}){
          my $netType = 0;
          if(exists $NADB{$net}){$netType = $NADB{$net}->dbNadbGetNetType;}
          if($netType == 0){
            $xml->startTag('net','name' => $net); 
            $xml_output .= "\n";
            $xml_output .= "   ";
            foreach my $instance (keys %{$NETS_ALREADY{$net}}){
              if(exists $PORTS_ALREADY{$TOP_MODULE}{$instance}){
                $xml->startTag('inst','name' => "PIN",'pin' => $NETS_ALREADY{$net}{$instance});
                $xml->endTag();
              }else{
                $xml->startTag('inst','name' => $instance,'pin' => $NETS_ALREADY{$net}{$instance});
                $xml->endTag();
                $xml_output .= "\n";
                $xml_output .= "   ";
              } 
            }#foreach
            if($routed_info == 1){
              if(exists $NETS_ROUTING_ALREADY{$net}){
                my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
                my @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
                if(@routes > 0){
                  my $l1 = shift @routes;
                  $xml->startTag("routed_info");
                  $xml_output .= "\n";
                  $xml_output .= "    ";
                  $xml->characters("ROUTED $l1"); 
                  $xml_output .= "\n";
                }
                if(@fixed_routes > 0){
                  my $l1 = shift @fixed_routes;
                  $xml->startTag("fixed_info");
                  $xml_output .= "\n";
                  $xml_output .= "    ";
                  $xml->characters("FIXED $l1");
                  $xml_output .= "\n";
                }
                $xml_output .= "\n";
              }
              $xml_output .= "   ";
            }
            $xml->endTag();
            $xml_output .= "\n";
            $xml_output .= "   ";
          }
        }else {print "ERR : $net not exists\n";}
      }
    }#foreach
  }#foreach
  $xml_output .= "\n";
  $xml_output .= "";
  $xml->endTag("root");
  $xml->end();
  print "$xml_output\n"; 
}#else
$t1 = new Benchmark;
my $td = timediff($t1, $t0);
print "command def_split_and_return_in_xml took:",timestr($td),"\n";
}#sub def_split_and_return_in_xml 
#-----------------------------------------------------------------------------#
sub defAnalysis {
 use Benchmark;
 my $t0 = new Benchmark;
 my $no_of_Arguments = @_;
 if($no_of_Arguments < 0 || $_[0] eq "-h"){
    print "Usage : defAnalysis --rpt <write report in txt format>(by default it generates report in xml format)\n";
                                          }
 else {
    my $WRITE_TXT = 0;
    for (my $i =0 ;$i < $no_of_Arguments;$i++){
      if($_[$i] eq "--rpt"){$WRITE_TXT = 1;}
    }#for

    my $xml_output = "";
    my $xml = new XML::Writer(OUTPUT => \$xml_output);
    my $moduleName = $GLOBAL->dbfGlobalGetTOP;
    my $dbu = $GLOBAL->dbfGlobalGetDBU;
    my ($diearea) = &get_diearea;
    my $total_inst = &no_of_instances;
    my $no_of_std_cell = &no_of_std_cell;
    my $no_of_block = &no_of_macro_instances;
    my $cnt_filler_inst = 0;
    foreach my $inst (keys %COMP_ALREADY){
      my $filler = &get_filler_cell($inst); 
      if($filler == 1){$cnt_filler_inst++;}
    }#foreach  
    my $cnt_physical_inst = 0;
    foreach my $inst (keys %COMP_ALREADY){
     my $physical_found = &get_physical_cell($inst);
     if($physical_found == 1){$cnt_physical_inst++;}
    }#foreach

    my %drive_cell_hash = &get_drive_cell;
    my %function_vs_inst = &celltype_distribution_by_function;
    my (%LVT_HASH,%HVT_HASH,%SVT_HASH) = &celltype_distribution_by_lvt_hvt_and_svt;
    my $total_zero_nets = 0;
    foreach my $net (keys %NETS_ALREADY){
      my $zero_driver_net = &check_zero_driver_net($net);
      if($zero_driver_net == 1){$total_zero_nets++;}
    }#foreach
    my $total_zero_sink_nets = 0;
    foreach my $net (keys %NETS_ALREADY){
      my $zero_sink_net = &check_zero_sink_net($net);
      if($zero_sink_net == 1){$total_zero_sink_nets++;}
    }#foreach
    my $inst_with_all_input_grounded_cnt = &inst_with_all_input_grounded;
    my ($zero_pin_net,$one_pin_net,$high_fanout) = &pin_nets_cnt;
    my $cnt_net = 0;
    foreach my $net (keys %NETS_ALREADY){
      my $netType = 0;
      if(exists $NADB{$netName}){$netType = $NADB{$net}->dbNadbGetNetType;}
      if($netType == 0){
        my @routes = ();
        my @fixed_routes = ();
        @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
        @fixed_routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetFixedRoute;
        if((@routes > 0) || (@fixed_routes > 0)){
        }else {
          $cnt_net++;
        }
      }#if neTtype
    }#foreach
    my %get_total_wire_length_by_layer = ();
    foreach my $netName (keys %NETS_ALREADY) {
      if(exists $NETS_ROUTING_ALREADY{$netName}){
        my %get_layer_vs_wl = &get_net_length_by_layer($netName);
        if(%get_layer_vs_wl){
          my @layer = sort {$a cmp $b} keys %get_layer_vs_wl;
          foreach my $lyr (@layer){
            my $layer_wl = $get_layer_vs_wl{$lyr};
            $get_total_wire_length_by_layer{$lyr} += $get_layer_vs_wl{$lyr};
          }#foreach
        }#if
      }#if
    }#foreach
    my %Number_of_pins_vs_net= &dbaReportNetWithNPins("--summary");
    my %Number_of_via_vs_layer = &get_number_of_via_per_layer;
    if($WRITE_TXT == 0){
       $xml->startTag("root");
       $xml_output .= "\n";
       $xml_output .= " ";
       $xml->startTag("design");
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("name");
       $xml->characters($moduleName);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("diearea");
       $xml->characters($diearea);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("component_data");
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag ("total_inst");
       $xml->characters($total_inst);
       $xml->endTag(); 
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("total_std_cells_inst");
       $xml->characters($no_of_std_cell);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("total_block_inst");
       $xml->characters($no_of_block);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("total_filler_inst");
       $xml->characters($cnt_filler_inst);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("total_physical_inst");
       $xml->characters($cnt_physical_inst);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("drive_cell_vs_inst");
       foreach my $cell (keys %drive_cell_hash){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag("drive_cell",'name' => $cell,'inst_cnt' => $drive_cell_hash{$cell}); 
         $xml->endTag();
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("func_vs_inst");
       foreach my $func (keys %function_vs_inst){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag('func','name' => $func, 'inst_cnt' => $function_vs_inst{$func});
         $xml->endTag();
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("vt_vs_inst");
       foreach my $cell (keys %LVT_HASH){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag('cell','name' => $cell, 'inst_cnt' => $LVT_HASH{$cell});  
         $xml->endTag();
       }#foreach
       #$xml_output .= "\n";
       #$xml_output .= "    ";
       foreach my $cell (keys %HVT_HASH){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag('cell','name' => $cell, 'inst_cnt' => $HVT_HASH{$cell});  
         $xml->endTag();
       }#foreach
       foreach my $cell (keys %SVT_HASH){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag('cell','name' => $cell, 'inst_cnt' => $SVT_HASH{$cell});  
         $xml->endTag();
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag();
       $xml_output .= "\n";
       $xml_output .= "   ";
       #-----------------------------------------------------------------------------#
       $xml->startTag("connectivity_data");
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("zero_driver_nets");
       $xml->characters($total_zero_nets);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("zero_sink_nets");
       $xml->characters($total_zero_sink_nets);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("zero_pin_net");
       $xml->characters($zero_pin_net);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("one_pin_net");
       $xml->characters($one_pin_net);
       $xml->endTag();
       
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("cnt_instances_for_all_inputs_grounded");
       $xml->characters($inst_with_all_input_grounded_cnt);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag();
       $xml_output .= "\n";
       $xml_output .= "   ";
       #-----------------------------------------------------------------------------#
       $xml->startTag("net_data");
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("num_of_nets_of_without_routing");
       $xml->characters($cnt_net);
       $xml->endTag();
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->startTag("layer_vs_wl");
       $xml_output .= "    ";
       foreach my $lyr (sort {$a cmp $b} keys %get_total_wire_length_by_layer){
         $xml_output .= "\n";
         $xml_output .= "    ";
         my $wl_in_micron = $get_total_wire_length_by_layer{$lyr}/$dbu;
         #$xml->startTag('layer','name' => $lyr,'total wl' => $get_total_wire_length_by_layer{$lyr});
         $xml->startTag('layer','name' => $lyr,'total wl' => $wl_in_micron);
         $xml->endTag();
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "    ";
       $xml->endTag("layer_vs_wl");
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag("layer_vs_via");
       foreach my $layer (sort {$a cmp $b} keys %Number_of_via_vs_layer){
         $xml_output .= "\n";
         $xml_output .= "   ";
         $xml->startTag('layer','name' => $layer,'total vias' => $Number_of_via_vs_layer{$layer});
         $xml->endTag(); 
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag("layer_vs_via");
       $xml_output .= "\n";
       $xml_output .= "   ";
       #-----------------------------------------------------------------------------#
       $xml->startTag("pins_vs_net");
       $xml_output .= "    ";
       foreach my $pins (sort {$a <=> $b} keys %Number_of_pins_vs_net){
         $xml_output .= "\n";
         $xml_output .= "    ";
         $xml->startTag('pin','num' => $pins,'total nets' => $Number_of_pins_vs_net{$pins}); 
         $xml->endTag();
       }#foreach
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag("pins_vs_net");
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->startTag('routed_wl_vs_hpwl');
       foreach my $netName (keys %NETS_ALREADY){
          my $HPWL = &report_net_wl_given_net($netName);
          my $routed_wl = &get_net_routed_wl($netName);
          $xml_output .= "\n";
          $xml_output .= "   ";
          $xml->startTag('net','name' => $netName,'routed_wl' => $routed_wl,'hpwl' => $HPWL);
          $xml->endTag();
       }#foreach 
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag('routed_wl_vs_hpwl');
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "   ";
       $xml->endTag("net_data");
       #-----------------------------------------------------------------------------#
       $xml_output .= "\n";
       $xml_output .= "  ";
       $xml->endTag();
       $xml_output .= "\n";
       $xml_output .= "";
       $xml->endTag();
       $xml->end();
       open(WRITE ,">$moduleName.xml");
       print WRITE "$xml_output\n";
       close(WRITE);
    }else{
       open(WRITE ,">$moduleName-report.txt");
       print WRITE "Design: $moduleName\n";
       print WRITE "DieArea: [$diearea] in micron\n";
       print WRITE "Component Data:\n";
       print WRITE "  Total Instances: $total_inst\n";
       print WRITE "  Total Std Cells Inst: $no_of_std_cell\n";
       print WRITE "  Total Block Inst: $no_of_block\n";
       print WRITE "  Total Filler Inst: $cnt_filler_inst\n";
       #print WRITE "  Total Physical Inst: $cnt_physical_inst\n";
       if(%drive_cell_hash){
         print WRITE "  Driver cell vs Inst:\n";
         foreach my $cell (keys %drive_cell_hash){
           print WRITE " cell=>$cell  inst_count=>$drive_cell_hash{$cell}\n";
         }#foreach
       } 
       if(%function_vs_inst){
         print WRITE "  Func vs Inst:\n";
         foreach my $func (keys %function_vs_inst){
           print WRITE "  func=>$func  inst_count=>$function_vs_inst{$func}\n";
         }#foreach
       }
       if(%LVT_HASH || %HVT_HASH || %SVT_HASH){ 
         print WRITE "  VT vs Inst:\n";
         foreach my $cell (keys %LVT_HASH){
           print WRITE "  cell=>$dell  inst_count=>$LVT_HASH{$cell}\n";
         }#foreach
         foreach my $cell (keys %HVT_HASH){
           print WRITE "  cell=>$cell  inst_count=>$HVT_HASH{$cell}\n";
         }#foreach
         foreach my $cell (keys %SVT_HASH){
           print WRITE "  cell=>$cell  inst_count=>$SVT_HASH{$cell}\n";
         }#foreach
       }
       print WRITE "Conectivity Data:\n";
       print WRITE "   zero_driver_nets: $total_zero_nets\n";
       print WRITE "   zero_sink_nets: $total_zero_sink_nets\n";
       print WRITE "   zero_pin_net: $zero_pin_net\n";
       print WRITE "   one_pin_net: $one_pin_net\n";
       print WRITE "   inst_for_all_in_grounded: $inst_with_all_input_grounded_cnt\n";
       print WRITE "Net Data:\n";
       print WRITE "   nets_without_routing: $cnt_net\n";
       print WRITE "   Layer\t\t\t\t\t\tLayer_vs_wl\n";  
       foreach my $lyr (sort {$a cmp $b} keys %get_total_wire_length_by_layer){
         my $wl_in_micron = $get_total_wire_length_by_layer{$lyr}/$dbu;
         #print WRITE "   $lyr\t\t\t\t\t$get_total_wire_length_by_layer{$lyr}\n";  
         print WRITE "   $lyr\t\t\t\t\t\t\t$wl_in_micron\n";  
       }#foreach
       print WRITE "   Layer\t\t\t\t\t\tLayer_vs_total_via\n";
       foreach my $layer (sort {$a cmp $b} keys %Number_of_via_vs_layer){
         print WRITE "   $layer\t\t\t\t\t\t\t$Number_of_via_vs_layer{$layer}\n";
       }#foreach 
       print WRITE "   Number of pins\t\t\t\t\ttotal_no_of_nets\n";
       foreach my $pins (sort {$a <=> $b} keys %Number_of_pins_vs_net){
          my $new_pins = sprintf("%8d",$pins);
         print WRITE "   $new_pins\t\t\t\t\t\t$Number_of_pins_vs_net{$pins}\n";
       }#foreach 
       print WRITE "   NetName\t\t\t\t\t\tRouted WL\t\tHPWL\n";
       foreach my $netName (keys %NETS_ALREADY){
          my $HPWL = &report_net_wl_given_net($netName);
          my $routed_wl = &get_net_routed_wl($netName);
          my $new_netName = sprintf("%-50s",$netName);
         print WRITE "   $new_netName\t$routed_wl\t\t\t$HPWL\n"; 
       }#foreach 
       close(WRITE);
    }
 }#else
 $t1 = new Benchmark;
 my $td = timediff($t1, $t0);
 print "command defAnalysis took:",timestr($td),"\n";
}#sub defAnalysis
#-----------------------------------------------------------------------------#
sub get_diearea {
if(exists $FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"}){
  my $flplanID = $FLOORPLAN_LOOKUP{"$TOP_MODULE/_self_"};
  if( exists $FLOORPLAN_ALREADY{$flplanID}){
    my @dieArea = $FLOORPLAN_ALREADY{$flplanID}->dbFlplanGetSize;
    my $fpUnit = $FLOORPLAN_ALREADY{$flplanID}->dbFlplanGetDBUnit; 
    my $gDBU = $GLOBAL->dbfGlobalGetDBU; 
    my $multFactor = $gDBU/$fpUnit;
    my $llx = $dieArea[0]*$multFactor;
    my $lly = $dieArea[1]*$multFactor;
    my $urx = $dieArea[2]*$multFactor;
    my $ury = $dieArea[3]*$multFactor;
    my $width  = $urx - $llx;
    my $height  = $ury - $lly;
    my $diearea = $width*$height;
    #return ($llx,$lly,$urx,$ury);
    my $area_in_micron = $diearea/$gDBU;
    return ($area_in_micron);
  }#if
}#if
}#sub get_diearea
#-----------------------------------------------------------------------------#
sub get_filler_cell {
my $inst = $_[0];
my $filler = 0;
my $cellref = $CADB{$inst}->dbCadbGetCellref;
if(exists $PLDB{$cellref}){
  my @pins = $PLDB{$cellref}->dbMdbGetPins;
  my $number_of_pin = @pins;
  if($number_of_pin == 2){
    foreach my $pin (@pins){
      my $type = $PLDB{$cellref}->dbMdbGetPinType($pin);
      if(($type == 1) || ($type == 2)){$filler = 1;}
    }#foreach
  }
}
return($filler);
}#sub get_filler_cell
#-----------------------------------------------------------------------------#
sub celltype_distribution_by_function {
my %function_vs_inst = ();
  foreach my $inst (keys %COMP_ALREADY){
    my $cellName = $CADB{$inst}->dbCadbGetCellref;
    if(exists $PLDB{$cellName}){
      my $func = $PLDB{$cellName}->dbMdbGetFunction;
      if($func eq "and"){
        $function_vs_inst{$func} += 1; 
      }elsif($func eq "nand"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "not"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "or"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "nor"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "xor"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "xnor"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "orand"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "aoi"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "mux"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "buf"){
        $function_vs_inst{$func} += 1;
      }elsif($func eq "inv"){
        $function_vs_inst{$func} +=1;
      }elsif($func eq "flop"){
        $function_vs_inst{$func} += 1;
      }elsif($function eq "andor"){
        $function_vs_inst{$func} += 1;
      }elsif($function eq "oai"){
        $function_vs_inst{$func} += 1;
      }elsif($function eq "sum of full adder"){
        $function_vs_inst{$func} += 1;
      }elsif($function eq "carry of full adder"){
        $function_vs_inst{$func} += 1;
      }
    }#if exists
  }#foreach 
return(%function_vs_inst);
}#sub celltype_distribution_by_function
#-----------------------------------------------------------------------------#
sub write_rpt_for_defAnalysis {
  my $filehandle = $_[0];
  print $filehandle "Design $TOP_MODULE\n";
  my ($diearea) = &get_diearea;
  print $filehandle "Diearea $diearea\n";
  print $filehandle "Component data\n";
  my $total_inst = &no_of_instances;
  print $filehandle "Total Number of Instance 	$total_inst\n";
  my $num_of_macro = &no_of_macro_instances;
  print $filehandle "Total Number of macro 	$num_of_macro\n";
  my $num_of_std_cell = &no_of_std_cell;
  print $filehandle "Total Number of std cell 	$num_of_std_cell\n"; 
  my $cnt_filler_inst = 0;
  foreach my $inst (keys %COMP_ALREADY){
    my $filler = &get_filler_cell($inst); 
    if($filler == 1){$cnt_filler_inst++;}
  }#foreach  
}#sub write_rpt_for_defAnalysis 
#-----------------------------------------------------------------------------#
sub get_physical_cell {
 my $inst = $_[0];
 my $physical = 0;
 my $cellref = $CADB{$inst}->dbCadbGetCellref;
 if (exists $PLDB{$cellref}){
   my $class = $PLDB{$cellref}->dbMdbGetClass;
   if($class !~ /block/i){
     my @pins = $PLDB{$cellref}->dbMdbGetPins;
     my $func = $PLDB{$cellref}->dbMdbGetFunction;
     if((@pins ne  "") && ($func eq "UND")){$physical = 1;}
   }
 }#if 
return($physical);
}#sub get_physical_cell
#-----------------------------------------------------------------------------#
sub get_drive_cell {
my %drive_cell_hash = ();
 foreach my $inst (keys %COMP_ALREADY){
   my $cellref = $CADB{$inst}->dbCadbGetCellref;
   if($cellref =~ /.*X\d+$/){
     $drive_cell_hash{$cellref} += 1;
   }
 }#foreach
return(%drive_cell_hash);
}#sub get_drive_cell
#-----------------------------------------------------------------------------#
sub celltype_distribution_by_lvt_hvt_and_svt {
 my %LVT_HASH = ();
 my %HVT_HASH = ();
 my %SVT_HASH = ();
 foreach my $inst (keys %COMP_ALREADY){
   my $cellref = $CADB{$inst}->dbCadbGetCellref;
   if(exists $PLDB{$cellref}){
     if($cellref =~ /LVT/i){
       $LVT_HASH{$cellref} += 1;
     }elsif($cellref =~ /HVT/i){
       $HVT_HASH{$cellref} += 1;
     }elsif($cellref =~ /SVT/i){
       $SVT_HASH{$cellref} += 1;
     }
   }
 }#foreach
return(%LVT_HASH,%HVT_HASH,%SVT_HASH);
}#sub celltype_distribution_by_lvt_hvt_and_svt
#-----------------------------------------------------------------------------#
sub inst_with_all_input_grounded {
my $inst_cnt = 0;
foreach my $inst (keys %CADB){
  my $cellref = $CADB{$inst}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my @pins = $PLDB{$cellref}->dbMdbGetPins;
    foreach my $pin (@pins){
      my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($pin);
      if($pinDir == 0){
        if(exists $COMP_ALREADY{$inst}){
          my $net = $COMP_ALREADY{$inst}{$pin};
          my $netType = 0;
          if ( exists $NADB{$net} ) {$netType = $NADB{$net}->dbNadbGetNetType;}
          if($netType > 0){
            if(exists $NETS_ROUTING_ALREADY{$net}){
              my $use = $NETS_ROUTING_ALREADY{$net}->dbNetGetType;
              if($use =~ /ground/i){$inst_cnt++;}
            }
          }
        }
      }#if
    }#foreach 
  }#if
}#foreach
return($inst_cnt);
}#sub inst_with_all_input_grounded 
#-----------------------------------------------------------------------------#
sub inst_with_floating_output {
foreach my $inst (keys %CADB){
  my $cellref = $CADB{$inst}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my @pins = $PLDB{$cellref}->dbMdbGetPins;
    foreach my $pin (@pins){
      my $pinDir = $PLDB{$cellref}->dbMdbGetPinDir($pin);
      if($pinDir == 1){
      }
    }#foreach
  }
}#foreach 
}#sub inst_with_floating_output
#-----------------------------------------------------------------------------#
sub cal_pin_dir {
my $in_cnt = 0;
my $out_cnt = 0;
my $inout_cnt = 0;
foreach my $port (keys %{$PORTS_ALREADY{$TOP_MODULE}}){
  my $dir = $PORTS_ALREADY{$TOP_MODULE}{$port}->dbPortGetDir; 
  if($dir =~ /input/i){
    $in_cnt++;
  }elsif($dir =~ /output/i){
    $out_cnt++;
  }elsif($dir =~ /inout/i){
    $inout_cnt++;
  } 
}#foreach
return($in_cnt,$out_cnt,$inout_cnt);
}#sub cal_pin_dir
#-----------------------------------------------------------------------------#
sub design_rpt_in_xml {
use Benchmark;
my $t0 = new Benchmark;
my $no_of_Arguments = @_;
if($no_of_Arguments < 0 || $_[0] eq "-h"){print "Usage : design_rpt_in_xml\n";
                                         }
else {
my $PIN_INFO = 0;
my $INST_INFO = 0;
my $NET_INFO = 0;
my $ROUTED_INFO = 0;
my $DEFAULT = 1;
for (my $i =0 ;$i < $no_of_Arguments;$i++){
  if($_[$i] eq "--pin_info"){$PIN_INFO = 1;$DEFAULT = 0;}
  if($_[$i] eq "--inst_info"){$INST_INFO = 1;$DEFAULT= 0;}
  if($_[$i] eq "--net_info"){$NET_INFO = 1;$DEFAULT = 0;}
  if($_[$i] eq "--routed_info"){$ROUTED_INFO = 1;$DEFAULT = 0;}
}#for
my $xml_output = "";
my $xml = new XML::Writer(OUTPUT => \$xml_output);
my $moduleName = $GLOBAL->dbfGlobalGetTOP;
$xml->startTag("root");
$xml_output .= "\n";
$xml_output .= " ";
$xml->startTag("design");
$xml_output .= "\n";
$xml_output .= "   ";
$xml->startTag("name");
$xml->characters($moduleName);
$xml->endTag();
#------------------------------------------pin info---------------------------------------------#
if($PIN_INFO == 1 || $DEFAULT == 1){
$xml_output .= "\n";
$xml_output .= "   ";
my ($in_cnt,$out_cnt,$inout_cnt) = &cal_pin_dir;
$xml->startTag("pin_data");
$xml_output .= "\n";
$xml_output .= "   ";
$xml->startTag('dir','input' => $in_cnt,'output' => $out_cnt,'inout' => $inout_cnt);
$xml->endTag();
$xml_output .= "\n";
$xml_output .= "   ";
$xml->endTag();
}#if
#-----------------------------------------------inst info-------------------------------------------#
if($INST_INFO == 1 || $DEFAULT == 1){
$xml_output .= "\n";
$xml_output .= "   ";
$xml->startTag("inst_data");
$xml_output .= "\n";
$xml_output .= "   ";
my $total_inst = &no_of_instances;
$xml->startTag("total_inst");
$xml->characters($total_inst);
$xml->endTag(); 
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my %function_vs_inst = &celltype_distribution_by_function;
$xml->startTag("ff_inst");
foreach my $func (keys %function_vs_inst){
   if($func =~ /flop/i){
     $xml->characters($function_vs_inst{$func});
   }
}#foreach
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my $no_of_block = &no_of_macro_instances;
$xml->startTag("total_block_inst");
$xml->characters($no_of_block);
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my $cnt_filler_inst = 0;
foreach my $inst (keys %COMP_ALREADY){
  my $filler = &get_filler_cell($inst);
  if($filler == 1){$cnt_filler_inst++;}
}
$xml->startTag("total_filler_inst");
$xml->characters($cnt_filler_inst);
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my $total_non_buffer_and_inv_std_cell = &non_buffer_and_inv_std_cell;
$xml->startTag("total_non_buffer_and_inv_std_cell");
$xml->characters($total_non_buffer_and_inv_std_cell);
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my $inst_cnt_of_buf_or_inv = 0;
foreach my $inst (keys %CADB){
  my $is_buffer_or_inv = &check_inst_is_buffer_or_inv($inst);
  if($is_buffer_or_inv == 1){
    $inst_cnt_of_buf_or_inv++;
  } 
}#foreach
$xml->startTag("total_inst_buff_and_inv");
$xml->characters($inst_cnt_of_buf_or_inv);
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
$xml->startTag("vt_vs_inst");
my (%LVT_HASH,%HVT_HASH,%SVT_HASH) = &celltype_distribution_by_lvt_hvt_and_svt;
foreach my $cell (keys %LVT_HASH){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('cell','name' => $cell,'inst_cnt' => $LVT_HASH{$cell});
  $xml->endTag();
}#foreach
foreach my $cell (keys %HVT_HASH){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('cell','name' => $cell,'inst_cnt' => $HVT_HASH{$cell}); 
  $xml->endTag();
}#foreach
foreach my $cell (keys %SVT_HASH){
  $xml_output .= "\n";
  $xml_output .= "   ";
  $xml->startTag('cell','name' => $cell,'inst_cnt' => $SVT_HASH{$cell});
  $xml->endTag();
}#foreach
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my $inst_utilization = &get_utilization_of_all_inst; 
$xml->startTag("inst_utilization");
$xml->characters($inst_utilization);
$xml->endTag();
#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "   ";
my %cell_type_vc_cnt = &cnt_distribution_by_cell_type;
foreach my $cell_type ( keys %cell_type_vs_cnt){
  if(($cell_type =~ /TIEHI/i) || ($cell_type =~ /TIELO/i)){
    $xml->startTag('cell','name' => $cell_type,'cnt' => $cell_type_vs_cnt{$cell_type});
    $xml->endTag();
  }#if
}#foreach
#-----------------------------------------net info--------------------------------------------------#

#----------------------------------------------------------------------------------------------------#
$xml_output .= "\n";
$xml_output .= "    ";
$xml_output .= "\n";
$xml_output .= "   ";
$xml->endTag();
}#if inst info
#--------------------------------------------root tag closed-----------------------------------------#
$xml_output .= "\n";
$xml_output .= "  ";
$xml->endTag();
$xml_output .= "\n";
$xml_output .= "";
$xml->endTag();
$xml->end();
open(WRITE ,">design.xml");
print WRITE "$xml_output\n";
close(WRITE);

}#else
$t1 = new Benchmark;
my $td = timediff($t1, $t0);
}#sub design_rpt_in_xml
#----------------------------------------------------------------------------------------------------#
sub get_utilization_of_all_inst {
my $total_area = 0;
my $utilization = 0;
foreach my $inst (keys %CADB){
  my $cellref = $CADB{$inst}->dbCadbGetCellref;
  if(exists $PLDB{$cellref}){
    my @size = $PLDB{$cellref}->dbMdbGetSize;
    my $width = $size[0];
    my $height = $size[1];
    my $area = $width*$height;
    $total_area = $total_area + $area;
  }#if
}#foreach
my $core_area = &core_size;
my $utilization = ($total_area*100)/$core_area;
return($utilization);
}#sub get_utilization_of_all_inst
#----------------------------------------------------------------------------------------------------#
sub non_buffer_and_inv_std_cell {
 my $total_non_buffer_and_inv_std_cell = 0;
 foreach my $inst (keys %CADB){
   my $is_buffer_or_inv = &check_inst_is_buffer_or_inv($inst);  
   if($is_buffer_or_inv == 0){
     my $cellref = $CADB{$inst}->dbCadbGetCellref; 
     if(exists $PLDB{$cellref}){
       my $class = $PLDB{$cellref}->dbMdbGetClass;
       if($class =~ /core/i){
         $total_non_buffer_and_inv_std_cell++; 
       }
     }
   }
 }#foreach
return($total_non_buffer_and_inv_std_cell);
}#sub non_buffer_and_inv_std_cell
#----------------------------------------------------------------------------------------------------#
sub get_number_of_via_per_layer{
my %Number_of_via_vs_layer = ();
foreach my $net (keys %NETS_ALREADY){
  my $netType = 0;
  if(exists $NADB{$net}){$netType = $NADB{$net}->dbNadbGetNetType;} 
  if($netType == 0){
    my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
    foreach my $netSeg (@routes){
      my @netSeg_data = (split(/\s+/,$netSeg));
      my $layer = shift(@netSeg_data);
      my $via = pop(@netSeg_data);
      if (exists $PTDB{$layer}) {
       if($via =~ /(\w+)/){
         $Number_of_via_vs_layer{$layer} += 1;
       } 
      }#if the routiung layer exists
    }
  }
}#foreach
return(%Number_of_via_vs_layer);
}#sub get_number_of_via_per_layer
#----------------------------------------------------------------------------------------------------#
sub get_net_routed_wl {
my $net = $_[0];
my $dbu = $GLOBAL->dbfGlobalGetDBU;
my $new_wl_in_microns = 0 ;
if ( exists $NETS_ROUTING_ALREADY{$net} ) {
  my $tmhd = 0;
  my @routes = $NETS_ROUTING_ALREADY{$net}->dbNetRoutingDBGetRegularRoute;
  foreach $l ( @routes ) {
    my @routeBox = &xformNetSegToPathSeg($l);
    $mhd = ($routeBox[2]-$routeBox[0]) + ($routeBox[3]-$routeBox[1]);
    $tmhd = $tmhd + $mhd;
  }# foreach
my $wl = $tmhd/$dbu;
$new_wl_in_microns = sprintf("%.2f",$wl);
return($new_wl_in_microns);
}# if exists in NETS_ROUTING_ALREADY                    
}#sub get_net_routed_wl
#----------------------------------------------------------------------------------------------------#
sub get_area_for_physical_inst {
my $total_physical_inst_area = 0;
    my $physical_found = "";
  foreach my $inst (keys %COMP_ALREADY){
    $physical_found = &get_physical_cell($inst);
    if($physical_found == 1){
      my $cellref = $CADB{$inst}->dbCadbGetCellref;
      if(exists $PLDB{$cellref}){
        my @size = $PLDB{$cellref}->dbMdbGetSize;
        my $area = $size[0]*$size[1];
        $total_physical_inst_area = $total_physical_inst_area + $area;
      }#if
    }#if  
  }#foreach
return($total_physical_inst_area);
}#sub get_area_for_physical_inst
#----------------------------------------------------------------------------------------------------#
sub write_single_pin_conn {
  open (WRITE, ">signal_net_single_conn.txt");
  foreach my $netName ( keys %NETS_ALREADY ) {
     my $netType = $NADB{$netName}->dbNadbGetNetType;
     if($netType >= 0){
        my $instance =  (keys %{$NETS_ALREADY{$netName}})[0];
        my $pinName = $NETS_ALREADY{$netName}{$instance};
        if(exists $COMP_ALREADY{$instance} ) {
           my $cellref = $CADB{$instance}->dbCadbGetCellref;
           my @instLoc = $CADB{$instance}->dbCadbGetLoc;
           my $orient = $CADB{$instance}->dbCadbGetOrient;
           if(exists $PLDB{$cellref} ) {
              my @cellSize = $PLDB{$cellref}->dbMdbGetSize;
              my @cellOrigin = $PLDB{$cellref}->dbMdbGetOrigin;
              my @rects =  $PLDB{$cellref}->dbMdbGetPinRect($pinName);
              my ($layer, $llx, $lly, $urx, $ury)=(split(/\s+/,$rects[0]))[0,2,3,4,5];
              my ($minx, $miny, $maxx, $maxy) = &xformCellPinToInstPin($instLoc[0],$instLoc[1],$cellOrigin[0],$cellOrigin[1],$orient,$cellSize[0],$cellSize[1],$llx,$lly,$urx,$ury);
              print WRITE "$netName $instance $pinName ($minx, $miny, $maxx, $maxy)\n";
           }
        }

     } 
  }
  close(WRITE);
}#sub write_single_pin_conn
#----------------------------------------------------------------------------------------------------#

1;
