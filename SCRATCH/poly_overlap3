#!/usr/bin/perl
use Math::Clipper ':all';
use Math::Polygon::Transform;

#my %overlap_layer_hash = (1=>2, 3=>4, 5=>"NONE");
#my %via_hash = (2=>3, 4=>5); 
my %overlap_layer_hash = (1=>2,3=>"NONE");
my %via_hash = (2=>3); 
my %pin_layer_hash = (40=>16, 41=>18);
my %boundary_layer_hash = (1=>[[1,1,2,1,2,3,1,3,1,1],[2,2,3,2,3,4,2,4,2,2], [4,0,5,0,5,1,4,1,4,0],[5,0,6,0,6,3,5,3,5,0]],
                           2=>[[2.2,2.2,2.8,2.2,2.8,2.8,2.2,2.8,2.2,2.2], [5.2,1.2,5.8,1.2,5.8,1.8,5.2,1.8,5.2,1.2],[5.2,2.2,5.8,2.2,5.8,2.8,5.2,2.8,5.2,2.2]],
                           3=>[[1,2,3,2,3,3,1,3,1,2], [5,1,7,1,7,3,5,3,5,1],[7,1,8,1,8,4,7,4,7,1]]);

my %layer_group_hash = ();
  foreach my $l(keys %overlap_layer_hash){
     @poly_arr = @{$boundary_layer_hash{$l}};
     my @group_arr = ();
     for(my $i=0; $i<=$#poly_arr; $i++){
         if($poly_arr[$i] eq ""){next;}
         my @sub_poly = @{$poly_arr[$i]};
         my @overlapped_poly = ();
         my @p = ();
         for(my $k=0; $k<=$#sub_poly; $k=$k+2){
             push(@p,[$sub_poly[$k],$sub_poly[$k+1]]);
         }
         for(my $j=$i+1; $j<=$#poly_arr; $j++){
             if($poly_arr[$j] eq ""){next;}
             my @clip_poly = @{$poly_arr[$j]};     
             my @p1 = ();
             for(my $l=0; $l<=$#clip_poly; $l=$l+2){
                 push(@p1,[$clip_poly[$l],$clip_poly[$l+1]]);
             }
             my $clipper = Math::Clipper->new;
             $clipper->add_subject_polygon([@p]);
             $clipper->add_clip_polygon([@p1]);
             my $result = $clipper->execute(CT_INTERSECTION);
             my @result_arr = @$result;
             my $result_arr_len = @result_arr;
             if($result_arr_len > 0){
                push(@overlapped_poly,[@clip_poly]);
                delete $poly_arr[$j];
             }else{
                my @new_poly = polygon_move(dx=>.0001, @p);
                my $clip = Math::Clipper->new;
                $clip->add_subject_polygon([@new_poly]);
                $clip->add_clip_polygon([@p1]);
                my $res = $clip->execute(CT_INTERSECTION);
                my @res_arr = @$res;
                my $res_arr_len = @res_arr;
                if($res_arr_len > 0){
                   push(@overlapped_poly,[@clip_poly]);
                   delete $poly_arr[$j];
                }else{
                   my @new_poly1 = polygon_move(dx=>-.0001, @p);
                   my $clip1 = Math::Clipper->new;
                   $clip1->add_subject_polygon([@new_poly1]);
                   $clip1->add_clip_polygon([@p1]);
                   my $res1 = $clip1->execute(CT_INTERSECTION);
                   my @res_arr1 = @$res1;
                   my $res_arr_len1 = @res_arr1;
                   if($res_arr_len1 > 0){
                      push(@overlapped_poly,[@clip_poly]);
                      delete $poly_arr[$j];
                   }else{
                      my @new_poly2 = polygon_move(dy=>.0001, @p);
                      my $clip2 = Math::Clipper->new;
                      $clip2->add_subject_polygon([@new_poly2]);
                      $clip2->add_clip_polygon([@p1]);
                      my $res2 = $clip2->execute(CT_INTERSECTION);
                      my @res_arr2 = @$res2;
                      my $res_arr_len2 = @res_arr2;
                      if($res_arr_len2 > 0){
                         push(@overlapped_poly,[@clip_poly]);
                         delete $poly_arr[$j];
                      }else{
                         my @new_poly3 = polygon_move(dy=>-.0001, @p);
                         my $clip3 = Math::Clipper->new;
                         $clip3->add_subject_polygon([@new_poly3]);
                         $clip3->add_clip_polygon([@p1]);
                         my $res3 = $clip3->execute(CT_INTERSECTION);
                         my @res_arr3 = @$res3;
                         my $res_arr_len3 = @res_arr3;
                         if($res_arr_len3 > 0){
                            push(@overlapped_poly,[@clip_poly]);
                            delete $poly_arr[$j];
                         }
                      }
                   }
                }
             }#if touch
         }
         if($#overlapped_poly >= 0){
            unshift(@overlapped_poly,[@sub_poly]);
            delete $poly_arr[$i];
            my @add_overlap = &get_overlap_poly(\@overlapped_poly);
            push(@overlapped_poly,@add_overlap);
            #-------- making group array ------#
            push(@group_arr,[@overlapped_poly]);
         }else{
            push(@group_arr,[[@sub_poly]]);
         }
         @{$layer_group_hash{$l}} = @group_arr;
     }
  }

############################################################################
sub get_overlap_poly{
  my @sub_poly_arr = @{$_[0]};
  my @ovl_poly = ();
  for(my $i=0; $i<=$#sub_poly_arr; $i++){
      my @sub_poly = @{$sub_poly_arr[$i]};
      my @p = ();
      for(my $k=0; $k<=$#sub_poly; $k=$k+2){
          push(@p,[$sub_poly[$k],$sub_poly[$k+1]]);
      }
      for(my $j=0; $j<=$#poly_arr; $j++){
          if($poly_arr[$j] eq ""){next;}
          my @clip_poly = @{$poly_arr[$j]};     
          my @p1 = ();
          for(my $l=0; $l<=$#clip_poly; $l=$l+2){
              push(@p1,[$clip_poly[$l],$clip_poly[$l+1]]);
          }
          my $clipper = Math::Clipper->new;
          $clipper->add_subject_polygon([@p]);
          $clipper->add_clip_polygon([@p1]);
          my $result = $clipper->execute(CT_INTERSECTION);
          my @result_arr = @$result;
          my $result_arr_len = @result_arr;
          if($result_arr_len > 0){
             push(@ovl_poly,[@clip_poly]);
             delete $poly_arr[$j];
          }else{
             my @new_poly = polygon_move(dx=>.0001, @p);
             my $clip = Math::Clipper->new;
             $clip->add_subject_polygon([@new_poly]);
             $clip->add_clip_polygon([@p1]);
             my $res = $clip->execute(CT_INTERSECTION);
             my @res_arr = @$res;
             my $res_arr_len = @res_arr;
             if($res_arr_len > 0){
                push(@overlapped_poly,[@clip_poly]);
                delete $poly_arr[$j];
             }else{
                my @new_poly1 = polygon_move(dx=>-.0001, @p);
                my $clip1 = Math::Clipper->new;
                $clip1->add_subject_polygon([@new_poly1]);
                $clip1->add_clip_polygon([@p1]);
                my $res1 = $clip1->execute(CT_INTERSECTION);
                my @res_arr1 = @$res1;
                my $res_arr_len1 = @res_arr1;
                if($res_arr_len1 > 0){
                   push(@overlapped_poly,[@clip_poly]);
                   delete $poly_arr[$j];
                }else{
                   my @new_poly2 = polygon_move(dy=>.0001, @p);
                   my $clip2 = Math::Clipper->new;
                   $clip2->add_subject_polygon([@new_poly2]);
                   $clip2->add_clip_polygon([@p1]);
                   my $res2 = $clip2->execute(CT_INTERSECTION);
                   my @res_arr2 = @$res2;
                   my $res_arr_len2 = @res_arr2;
                   if($res_arr_len2 > 0){
                      push(@overlapped_poly,[@clip_poly]);
                      delete $poly_arr[$j];
                   }else{
                      my @new_poly3 = polygon_move(dy=>-.0001, @p);
                      my $clip3 = Math::Clipper->new;
                      $clip3->add_subject_polygon([@new_poly3]);
                      $clip3->add_clip_polygon([@p1]);
                      my $res3 = $clip3->execute(CT_INTERSECTION);
                      my @res_arr3 = @$res3;
                      my $res_arr_len3 = @res_arr3;
                      if($res_arr_len3 > 0){
                         push(@overlapped_poly,[@clip_poly]);
                         delete $poly_arr[$j];
                      }
                   }
                }
             }
          }
      }
      if($#ovl_poly >= 0){
        push(@ovl_poly, &get_overlap_poly(\@ovl_poly));
      }
  }
  return @ovl_poly;
}#sub get_overlap_poly

########################################################################### 
my @final_groups = ();
foreach my $layer (sort{$a<=>$b}keys %overlap_layer_hash){
  my $via_layer = $overlap_layer_hash{$layer};
  my @via_poly_arr = @{$boundary_layer_hash{$via_layer}};
  my @layer_group = @{$layer_group_hash{$layer}};
  foreach my $group (@layer_group){
    my @via_overlapped = ();
    my @group_poly = ();
    foreach my $poly (@$group){
       my @sub_poly = @$poly;
       push(@group_poly, [@sub_poly]);
       my @p = ();
       for(my $i=0; $i<=$#sub_poly; $i=$i+2){
           push(@p,[$sub_poly[$i],$sub_poly[$i+1]]);
       }
       for(my $j=0; $j<=$#via_poly_arr; $j++){
           if($via_poly_arr[$j] == ""){next;}
           my @clip_poly = @{$via_poly_arr[$j]};
           #print "layer $layer | sub @sub_poly | via @clip_poly\n";
           my @p1 = ();
           for(my $k=0; $k<=$#clip_poly; $k=$k+2){
               push(@p1,[$clip_poly[$k],$clip_poly[$k+1]]);
           }
           my $clipper = Math::Clipper->new;
           $clipper->add_subject_polygon([@p]);
           $clipper->add_clip_polygon([@p1]);
           my $result = $clipper->execute(CT_INTERSECTION);
           my @result_arr = @$result;
           my $result_arr_len = @result_arr;
           if($result_arr_len > 0){
              push(@via_overlapped,[@clip_poly]);
              push(@group_poly, [@clip_poly]);
              delete $via_poly_arr[$j];
           }
       }
    }#foreach polygon
    my $second_layer = $via_hash{$via_layer};
    my @second_lgrp = @{$layer_group_hash{$second_layer}};
    #print "second $second_layer @second_lgrp\n";
    LOOPA:for(my $i=0; $i<=$#via_overlapped; $i++){
            my @via_poly = @{$via_overlapped[$i]}; 
            #print "via poly @via_poly\n";
            my @p = ();
            for(my $j=0; $j<=$#via_poly; $j=$j+2){
                push(@p,[$via_poly[$j],$via_poly[$j+1]]);
            }
            for(my $j=0; $j<=$#second_lgrp; $j++){
                my @group = @{$second_lgrp[$j]};
                foreach my $polygon (@group){
                  my @clip_poly = @$polygon;
                  my @p1 = ();
                  for(my $k=0; $k<=$#clip_poly; $k=$k+2){
                      push(@p1,[$clip_poly[$k],$clip_poly[$k+1]]);
                  }
                  my $clipper = Math::Clipper->new;
                  $clipper->add_subject_polygon([@p]);
                  $clipper->add_clip_polygon([@p1]);
                  my $result = $clipper->execute(CT_INTERSECTION);
                  my @result_arr = @$result;
                  my $result_arr_len = @result_arr;
                  if($result_arr_len > 0){
                     #print "overlapped\n";
                     delete $second_lgrp[$j];
                     @{$layer_group_hash{$second_layer}} = @second_lgrp;
                     push(@group_poly, @group);
                     last LOOPA;
                  }
                }
            }
    }
    push(@final_groups, [@group_poly]);
    #print "$layer | group $group | @via_overlapped\n";
  }#foreach group
}#foreach layer

foreach my $group (@final_groups){
  print "group $group\n";
  foreach (@$group){
    print "aditya @$_\n";
  }
}
########################################################################### 
#foreach my $layer (keys %layer_group_hash){
#  my @poly_grp = @{$layer_group_hash{$layer}};
#  print "layer $layer, group @poly_grp\n";
#  foreach my $el(@poly_grp){
#    print "group @$el\n";
#    foreach (@$el){
#       print "$layer | @$_\n";
#    }
#  }
#}
#
########################################################################### 

